## template used to generate BeanInfo class for descriptor interfaces
#set ( $bindTag = "binding" )
#set ( $changeTag = "changable" )
#set ( $dependTag = "depends" )
#set ( $declareTag = "declare" )
#set ( $configTag = "configurable" )
#set ( $ddxpathTag = "ddXPath" )
#set ( $keyTag = "key" )
#set ( $dynTag = "dynamic" )
#set ( $nodynTag = "non-dynamic" )
#set ( $classTune = false )
#if ( $target.hasAnnotation($dynTag) )
#set ($classTune = true )
#end

/*
 * This is a generated file. Do not edit this file.
 */
package $target.getPackage();

/** 
 * BeanInfo for $source.getQualifiedName()
 * Generated on $date
 * $copyright
 * $author
 * $version
 */

import java.beans.SimpleBeanInfo;
import java.beans.BeanDescriptor;
import java.beans.PropertyDescriptor;
import java.util.ArrayList;
import java.util.List;

public class ${target.getName()} extends SimpleBeanInfo {
  BeanDescriptor bd;
  static PropertyDescriptor[] pds = null;


  public ${target.getName()}() {
    bd = new BeanDescriptor(${source.getQualifiedName()}Impl.class);
#if ($target.hasAnnotation("description"))
    bd.setShortDescription("${target.getAnnotation("description")}");
#end##description
  }

  public BeanDescriptor getBeanDescriptor() { return bd; }

  public PropertyDescriptor[] getPropertyDescriptors() {
    if (pds != null) return pds;
    PropertyDescriptor pd;
    List plist = new ArrayList();
    try {
#foreach ($method in $target.getMethods())
#if ($method.isGetter())
#set ($depend = $method.hasAnnotation(${dependTag}))
#set ($declare = $method.hasAnnotation(${declareTag}))
#set ($config = $method.hasAnnotation(${configTag}))
#set ($key = $method.hasAnnotation($keyTag))
#set ($tunable = $method.hasAnnotation($dynTag) || $classTune)
#if ( $method.hasAnnotation($nodynTag) )
#set ($tunable = false)
#end
#if ( $binding || $declare )## cant be binding and dynamic
#set ($tunable = false)
#end
      pd =  new PropertyDescriptor("${method.getAnnotatableAttribute().getPropertyName()}",
                               Class.forName("${source.getQualifiedName()}Impl"),
                               "${method.getName()}",
## if is array of dcbs then no setter
#if ($method.hasAnnotation($ddxpathTag) && $method.getReturnType().isArray())
                               null);
#else
## no setter if read-only
#set ($setter = "set${method.getAnnotatableAttribute().getPropertyName()}")
#set ($hasSetter = false)
#foreach ($m in $target.getMethods())
#if ($m.getName().equals($setter))
#set ($hasSetter = true)
#end
#end
#if ($hasSetter)
                               "set${method.getAnnotatableAttribute().getPropertyName()}");
#else## no setter
                               null);
#end## setter check
#end## setters
      pd.setValue("${bindTag}",Boolean.valueOf($depend || $declare));
      pd.setValue("${changeTag}",Boolean.valueOf($depend || $declare || $config));
      pd.setValue("${dependTag}",Boolean.valueOf($depend));
      pd.setValue("${declareTag}",Boolean.valueOf($declare));
      pd.setValue("${configTag}",Boolean.valueOf($config));
      pd.setValue("${keyTag}",Boolean.valueOf($key));
      pd.setValue("${dynTag}",Boolean.valueOf($tunable));
      plist.add(pd);
#end##getters
#end##methods
      pds = (PropertyDescriptor[])plist.toArray(new PropertyDescriptor[]{});
      return pds;
    } catch (Throwable t) {
      t.printStackTrace();
      throw new AssertionError("Failed to create PropertyDescriptors for ${target.getName()}");
    }
  }  

}
