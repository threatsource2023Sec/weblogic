#* @vtlvariable name="class" type="weblogic.descriptor.beangen.BeanClass" *#
#* @vtlvariable name="options" type="weblogic.descriptor.beangen.BeanGenOptions" *#
/*
 * This is a generated file. Do not edit this file.
 */
package $class.getPackageName();

import javax.management.InvalidAttributeValueException;
import javax.management.InvalidAttributeValueException;
import weblogic.descriptor.DescriptorBean;
import weblogic.management.DistributedManagementException;
import weblogic.management.internal.mbean.ReadOnlyMBeanBinder;
import weblogic.utils.codegen.AttributeBinder;
import weblogic.descriptor.internal.AbstractDescriptorBean;
import ${class.getQualifiedImplClassName()};

/**
 * Generated on $date
 * $copyright
 * $author
 * $version
 */
#set ($implClass = "${class.getInterfaceName()}Impl")
public class $class.getClassName()
  extends $class.getQualifiedSuperClassName()
  implements AttributeBinder
{
  private ${implClass} bean;

  protected $class.getClassName()(DescriptorBean bean) {
    super(bean);
    // FIXME ehalpern@bea.com 21-Aug-03 -- Don't hard-code suffix
    this.bean = (${implClass})bean;
  }

  public $class.getClassName()() {
    // FIXME ehalpern@bea.com 21-Aug-03 -- Don't hard-code suffix
    super(new ${implClass}());
    bean = (${implClass})getBean();
  }

  public AttributeBinder bindAttribute(String name, Object value)
    throws IllegalArgumentException
  {
    try {
      AttributeBinder binder = this;
      if ( !(binder instanceof weblogic.management.internal.mbean.SecurityReadOnlyMBeanBinder) &&
          (value != null && value.toString().trim().length() == 0 )) {
        return binder;       
      }     
      

      if (name == null) {
        // ignore

#foreach ($p in $class.getDeclaredProperties())
#if (!$p.isTransient() || $p.isPreviouslyPersisted())
## Only arrays of children are represented as individual components in config.xml
#if ($p.isChild())
      } else if (name.equals("$p.getComponentName()")) {
        ## children are passed in after they've bean created
        #set($value = "(($p.getAbsoluteType())((ReadOnlyMBeanBinder)value).getBean())")
#else
      } else if (name.equals("$p.getName()")) {
#if ($p.isAnnotationDefined("deprecated"))
	handleDeprecatedProperty("$p.getName()", "$p.getDeprecatedString()");
#end##if
        ## all other property values are passed in as Strings
        #set($value = $p.getValueFromString("value"))
#end##if
#if ($p.isBean() && $p.isArray())
        ## Use adder for any bean array property.  Synthetic adders will have
        ## will have been defined for properties that didn't declare them
        #set($setStatement = "bean.add$p.getComponentName()($value);")
        
	#set($clone = "($p.getAbsoluteType())((AbstractDescriptorBean)($value))._cloneIncludingObsolete()")
	#set($setCloneStatement = "bean.add$p.getComponentName()($clone);")
#else
        ## Use setter for all other properties         
        #set($setStatement = "bean.set$p.getName()($value);")
        
	#set($setCloneStatement = "")
#end##if isBean
#if ($p.isReadOnly() && !$p.isBean())
        throw new AssertionError("can't set read-only property $p.getName()");
#elseif ($p.getImplementation().isMarshalledAsString())
#if ($p.getImplementation().isDelegate())
        if (bean.is$p.getName()Set()) {
          throw new IllegalArgumentException("Unencrypted attribute corresponding to $p.getName() [ $p.getBean().getInterfaceName() ] is also present in the config file. For encrypted properties either encrypted or unencrypted attribute can be present in 8.x config.");
        }
#end##if isDelegate
        bean.set$p.getName()AsString((String)value);
#else
    try {
#if ($p.getImplementation().hasDelegate())
          if (bean.is$p.getImplementation().getDelegate().getDeclaration().getName()Set()) {
            throw new IllegalArgumentException("Encrypted attribute corresponding to $p.getName() [ $p.getBean().getInterfaceName() ] is also present in the config file. For encrypted properties either encrypted or unencrypted attribute can be present in 8.x config.");
          }
#end##if isDelegate
          $setStatement
        } catch (weblogic.descriptor.BeanAlreadyExistsException e) {
    // CR197646 and CR193589
          System.out.println("Warning: multiple definitions with same name: "+e.getMessage());
        #if ($p.isBean() && $p.isArray())
          bean.remove$p.getComponentName()(($p.getAbsoluteType())e.getExistingBean());
        #end##if 
        $setCloneStatement
          
        }
#end##if
#end##if !isTransient()
#end##foreach
## Handle properties that can hold subtypes
#foreach ($p in $class.getDeclaredProperties())
#if (!$p.isTransient() || $p.isPreviouslyPersisted())
#if ($p.isSuperProperty())
      } else if (isInstance(${p.getAbsoluteType()}.class, name)) {
        #set($value = "(($p.getAbsoluteType())((ReadOnlyMBeanBinder)value).getBean())")
#if ($p.hasAddressableComponents())
        #set($setStatement = "bean.add$p.getComponentName()($value);")
        
#else
        #set($setStatement = "bean.set$p.getName()($value);")
        
#end##if hasAddressableComponents
  try {
          $setStatement
        } catch (weblogic.descriptor.BeanAlreadyExistsException e) {
    // CR197646 and CR193589
          System.out.println("Warning: multiple definitions with same name : "+e.getMessage());
        #if ($p.isBean() && $p.isArray())
          bean.remove$p.getComponentName()(($p.getAbsoluteType())e.getExistingBean());
        #end##if 
          $setStatement
        }
#end##if
#end##if (!$p.isTransient())
#end##foreach
      } else {
        binder = super.bindAttribute(name, value);
      }
      return binder;
    } catch (ClassCastException e) {
      System.out.println(e + " name: " + name + " class: " + value.getClass().getName());
      throw e;
    } catch (RuntimeException e) {
      throw e;
    } catch (Exception e) {
      if (e instanceof DistributedManagementException) {
        throw new AssertionError("impossible exception: " + e);
      } else if (e instanceof InvalidAttributeValueException) {
        throw new IllegalArgumentException(e.getMessage());
      } else {
        throw new AssertionError("unexpected exception: " + e);
      }
    }
  }
}
