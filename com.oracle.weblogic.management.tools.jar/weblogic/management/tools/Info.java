package weblogic.management.tools;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.PrintStream;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanConstructorInfo;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanOperationInfo;
import weblogic.management.info.ExtendedAttributeInfo;
import weblogic.management.info.ExtendedInfo;
import weblogic.management.info.ExtendedOperationInfo;
import weblogic.utils.StringUtils;

public class Info extends ExtendedInfo {
   static final long serialVersionUID = 1L;
   private static boolean listProtectedAttributesInfo = Boolean.getBoolean("weblogic.management.tools.Info.listProtectedAttributesInfo");
   private static boolean verbose = false;
   private static boolean replacedChars = false;
   private static PrintStream infoOut;
   private String[] interfaces;
   private String shortInterfaceName = null;

   public Info(String className, String[] interfaces, String description, ExtendedAttributeInfo[] attributes, MBeanConstructorInfo[] constructors, ExtendedOperationInfo[] operations, MBeanNotificationInfo[] notifications, boolean cachingDisabled, boolean isPersistent, boolean isAbstract, String legalDeleteCheck, String legalDeleteResponse, String since, boolean isPersistedEvenIfDefaulted, String customizerClass) {
      super(className, description, permute(className, (AttributeInfo[])((AttributeInfo[])attributes)), constructors, (MBeanOperationInfo[])((MBeanOperationInfo[])operations), notifications, cachingDisabled, isPersistent, isAbstract, legalDeleteCheck, legalDeleteResponse, since, isPersistedEvenIfDefaulted, customizerClass);
      this.interfaces = interfaces;
   }

   public static void main(String[] args) throws Exception {
      for(int i = 0; i < args.length; ++i) {
         if ("-verbose".equals(args[i])) {
            verbose = true;
         } else {
            if (args[i].charAt(0) == '-') {
               System.err.println("Usage: java weblogic.management.tools.Info [-verbose] [<filename>]\nThis tool ASSUMES it is being run from the src root and it assumes that all MBeans live under weblogic/management\nerrors are printed on System.err and all the \"results\" go to .out or the file specified as an argument\neg. java -Dweblogic.management.tools.Info.listProtectedAttributesInfo=true weblogic.management.tools.Info > /temp/protectedAttributeNames.properties\neg. java weblogic.management.tools.Info > /temp/attributeNames.properties");
               System.exit(0);
            }

            infoOut = new PrintStream(new FileOutputStream(args[i]));
         }
      }

      infoOut.println("#Please do not Edit this file, use \"java -Dweblogic.management.tools.Info.listProtectedAttributesInfo=<true/false> weblogic.management.tools.Info\" to recreate this file");
      infoOut.println("#Generated on " + new Date());
      walk(new File("weblogic/management"));
   }

   private static AttributeInfo[] permute(String key, AttributeInfo[] attributes) {
      Properties p = new Properties();

      try {
         p.load(Info.class.getResourceAsStream("attributeNames.properties"));
      } catch (IOException var9) {
         throw new Error(var9.toString());
      }

      String orderedAttributes = p.getProperty(key);
      if (orderedAttributes == null) {
         orderedAttributes = "";
      }

      String[] canonical = StringUtils.splitCompletely(orderedAttributes, ",");
      AttributeInfo[] res = new AttributeInfo[attributes.length];
      Map map = new TreeMap();

      int i;
      for(i = 0; i < attributes.length; ++i) {
         map.put(attributes[i].getName(), attributes[i]);
      }

      for(i = 0; i < canonical.length; ++i) {
         res[i] = (AttributeInfo)map.remove(canonical[i]);
         if (res[i] == null) {
            throw new Error("deleted attribute: " + canonical[i]);
         }
      }

      i = canonical.length;

      for(Iterator it = map.values().iterator(); it.hasNext(); res[i++] = (AttributeInfo)it.next()) {
      }

      return res;
   }

   private static String printAttribute(MBeanAttributeInfo info) {
      return info.toString();
   }

   private static void walk(File file) {
      final String path = file.getPath() + File.separatorChar;
      if (verbose) {
         System.err.println("walking : " + file);
      }

      if (file.isDirectory() && file.getName().indexOf("console") < 0) {
         File[] listOfDirs = file.listFiles(new FilenameFilter() {
            public boolean accept(File f, String s) {
               if (f.isDirectory()) {
                  return true;
               } else {
                  Info.checkFileName(path + s);
                  return false;
               }
            }
         });

         for(int i = 0; i < listOfDirs.length; ++i) {
            walk(listOfDirs[i]);
         }
      } else {
         checkFileName(file.getPath());
      }

   }

   private static void checkFileName(String name) {
      if (name.endsWith("MBean.java") && (name.indexOf("descriptors") < 0 || listProtectedAttributesInfo)) {
         if (verbose) {
            System.err.println("checkFileName : " + name);
         }

         name = name.substring(0, name.length() - ".java".length()) + ".mbi";
         if (File.separatorChar != '/') {
            name = name.replace(File.separatorChar, '/');
            replacedChars = true;
         }

         listAttributesForInfo(name);
      }

   }

   private static void listAttributesForInfo(String name) {
      InputStream i = Info.class.getClassLoader().getResourceAsStream(name);

      try {
         if (i != null) {
            Info info = (Info)(new ObjectInputStream(i)).readObject();
            StringBuffer buf = new StringBuffer();
            String sep = ",";
            MBeanAttributeInfo[] attrs = info.getAttributes();

            for(int j = 0; j < attrs.length; ++j) {
               if (!listProtectedAttributesInfo) {
                  buf.append(attrs[j].getName()).append(sep);
               } else if (listProtectedAttributesInfo) {
                  ExtendedAttributeInfo attrInfo = (ExtendedAttributeInfo)attrs[j];
                  if (attrInfo.isEncrypted() || attrInfo.getProtectionLevel() > 0) {
                     buf.append(attrs[j].getName()).append(sep);
                  }
               }
            }

            if (buf.toString().endsWith(sep)) {
               buf.setLength(buf.length() - 1);
            }

            name = name.substring(0, name.indexOf(".mbi"));
            char aChar = File.separatorChar;
            if (replacedChars) {
               aChar = '/';
            }

            name = name.replace(aChar, '.');
            if (listProtectedAttributesInfo && buf.toString().trim().length() != 0) {
               infoOut.println(name + "=" + buf);
            } else if (!listProtectedAttributesInfo) {
               infoOut.println(name + "=" + buf);
            }
         } else if (verbose) {
            System.err.println("Did not find : " + name);
         }
      } catch (Exception var8) {
         var8.printStackTrace();
         System.exit(-1);
      }

   }

   public String[] getInterfaces() {
      return this.interfaces;
   }

   public String getShortInterfaceName() {
      if (this.shortInterfaceName == null) {
         this.shortInterfaceName = AttributeInfo.Helper.trimPackage(this.getClassName());
      }

      return this.shortInterfaceName;
   }

   public String toString(boolean verbose) {
      if (!verbose) {
         return super.toString();
      } else {
         StringBuffer result = new StringBuffer();
         result.append("MBeanInfo for " + this.getClassName());
         result.append("\n\n description: " + this.getDescription());
         result.append("\n\n customizer: " + this.getCustomizerClass());
         result.append("\n\n Attributes:");
         MBeanAttributeInfo[] attributes = this.getAttributes();

         for(int i = 0; i < attributes.length; ++i) {
            result.append("\n\t" + printAttribute(attributes[i]));
         }

         result.append("\n\n operations:");
         MBeanOperationInfo[] operations = this.getOperations();

         for(int i = 0; i < operations.length; ++i) {
            result.append("\n\t" + operations[i].getName());
         }

         return result.toString();
      }
   }

   static {
      infoOut = System.out;
   }
}
