version=1.0
L10nPackage=kodo.bea.jdbc
I18nPackage=kodo.bea.jdbc
subsystem=Kodo JDBC
prefix=WL

2002000=The options supplied to the {0} are not valid. Please check your ant build file.
2002001=Using metadata factory "{0}".
2002002=Using mapping factory "{0}".
2002003=OpenJPA will now connect to the database to attempt to determine what type of database dictionary to use. To prevent this connection in the future, set your org.apache.openjpa.jdbc.DBDictionary configuration property to the appropriate value for your database (see the documentation for available values).
2002004=The target for filter listener "{0}" must be "this" or some field traversal to a related objects, such as "company.address".
2002005=The filter listener "{0}" does not support in-memory operation; it can only be used with queries against the database.
2002006=Field "{0}" is not persistent, and thus cannot be queried.
2002007=Attempt to compare incompatible types "{0}" and "{1}".
2002008=The filter listener "{0}" requires a constant argument.
2002009=The column "{0}" given to filter "{1}" doesn''t exist in the table of the specified target.
2002010=Attempt to get the object id of a non-persistent or embedded object field "{0}".
2002011=Usage: java org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	-action/-a <add | drop | get | set> 	[class name | .java file | .class file | .jdo file] [value]
2002012=Error instantiating named sequence "{0}": Your database dictionary does not support native sequences. To tell the dictionary how to select sequence values, use: org.apache.openjpa.jdbc.DBDictionary: NextSequenceQuery="SELECT NEXT VALUE FOR {0}" Where the above string is replaced with the proper SQL for your database.
2002013=Usage: java org.apache.openjpa.jdbc.kernel.TableJDBCSeq 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	-action/-a <add | drop | get | set> [value]
2002014=Creating sequence.
2002015=Dropping sequence.
2002016=SQL query "{0}" declares a parameter index "{1}" for which no value was given. The given parameters were: {2}
2002017=Cannot instantiate virtual mapping "{0}".
2002018=Though you are using optimistic transactions, OpenJPA is now beginning a datastore transaction because you have requested a lock on some data.
2002019=Updating sequence values.
2002020=JDBC lock manager does not support millisecond-granularity timeouts. Use timeouts that are multiples of 1000 for even second values.
2002021=An error occurred attempting to rollback to the savepoint "{0}"
2002022=This sequence of type "{0}" cannot generate values for persistent type "{1}".
2002023=No rows returned for sql "{0}". Check your configuration.
2002024=Attempt to update the sequence table "{0}" failed. The sequence table is typically created when you run the mappingtool''s refresh action on any datastore identity class. If you have not run the mappingtool but want to create the sequence table, run: java org.apache.openjpa.jdbc.kernel.TableJDBCSeq -action add
2002025=The update count for the statement was an invalid value ({0}). This indicates that your database or JDBC driver does not have complete support for executing batch statements. Batch functionality should be disabled by including "BatchLimit=0" in your org.apache.openjpa.jdbc.DBDictionary configuration property. Statement: {1}
2002026=An unresolvable constraint cycle was detected. This typically means that a mapping in a table other than the class'' primary table has a foreign key that is part of a circular foreign key dependency. OpenJPA sometimes cannot meet circular dependencies when some of the involved mappings are in secondary tables.
2002027=The database is unable to lock this query. Each object matching the query will be locked individually after it is loaded; however, it is technically possible that another transaction could modify the data before the lock is obtained. See the documentation on Object Locking for details. "{0}"
2002028=You have not specified a SQL filter to execute in your SQL query.
2002029=Cannot perform an aggregate query on a hierarchy with unjoined subclasses: {0}
2002030=An unresolvable constraint cycle was detected. This typically means that you are persisting a new object with the same primary key value as an object you are deleting in the same transaction, and at the same time you have circular foreign key dependencies in the transaction. The combination of these two factors can sometimes lead to a situation in which OpenJPA cannot meet all the database constraints.
2002031=There is no row for mapping "{0}" in sequence table "{1}", and the attempt to insert a row has apparently failed.
2002032=Getting current sequence values.
2002033=Inserting row for this mapping into sequence table.
2002034=There is no persistence server configured.
2002035=Creating sequence table.
2002036=Server running. Press enter to stop.
2002037=Usage: java org.apache.openjpa.jdbc.kernel.StartPersistenceServer 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]*
2002038=Usage: java org.apache.openjpa.jdbc.kernel.NativeJDBCSeq 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]*
2002039=Invalid SynchronizeMappings operation ("{0}") specified. Valid operations are: {1}
2002040=Dropping sequence table.
2002041=JDBC lock manager does not support millisecond-granularity timeouts. Use timeouts that are multiples of 1000 for even second values.
2002042=Attempt to add a null/empty fetch join field.
2002043=Database operation failed. Update count for SQL statement was {0}. Statement: {1}
2002044=An error occurred attempting to set the savepoint "{0}". This driver may not support JDBC 3 savepoints.
2002045=Type "{0}" has a mapped superclass, and therefore cannot declare additional lock groups. Use the "lock-groups" extension on the mapped superclass to declare any additional lock groups needed by this type. {1}
2002046=Could not instantiate custom class strategy "{1}" for type "{0}". Make sure this is a valid ClassStrategy implementation.
2002047="{0}" marks its join columns as having a deferred unique constraint, but the existing constraint on these columns is not deferred. OpenJPA cannot change the deferrability of a constraint.
2002048="{0}" is not a valid mapping. Inverse foreign key-based relations to types with unjoined subclasses are not supported.
2002049="{0}" marks its columns as having a deferred unique constraint, but the existing constraint on these columns is not deferred. OpenJPA cannot change the deferrability of a constraint.
2002050=Field "{0}" declared custom mapping strategy "{1}", but this strategy cannot be instantiated.
2002051=Usage: java org.apache.openjpa.jdbc.meta.ReverseMappingTool 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	[-directory/-d <output directory>] 	[-schemas/-s <schema and table list>] 	[-package/-pkg <package name>] 	[-useSchemaName/-sn <true/t | false/f>] 	[-useForeignKeyName/-fkn <true/t | false/f>] 	[-nullableAsObject/-no <true/t | false/f>] 	[-blobAsObject/-bo <true/t | false/f>] 	[-typeMap/-type <types>] 	[-primaryKeyOnJoin/-pkj <true/t | false/f>] 	[-useDatastoreIdentity/-ds <true/t | false/f>] 	[-useBuiltinIdentityClass/-bic <true/t | false/f>] 	[-innerIdentityClasses/-inn <true/t | false/f>] 	[-identityClassSuffix/-is <suffix>] 	[-inverseRelations/-ir <true/t | false/f>] 	[-detachable/-det <true/t | false/f>] 	[-discriminatorStrategy/-ds <strategy>] 	[-versionStrategy/-vs <strategy>] 	[-metadata/-md <package | class>] 	[-customizerClass/-cc <full class name>] 	[-customizerProperties/-cp <properties file or resource>] 	[-customizer/-c.<property name> <property value>]* 	[-codeFormat/-cf.<property name> <property value>]* 	[.schema file]*
2002052="{0}" marks its columns as having a deferred foreign key, but the database dictionary "{1}" reports that it does not support deferred constraints. Creating an undeferred constraint.
2002053="{0}" attmpts to join a constant value to another constant value.
2002054="{0}" marks its join columns as having a deferred unique constraint, but the database dictionary "{1}" reports that it does not support deferred constraints. Creating an undeferred constraint.
2002055=Type "{0}" declares a datastore identity column "{1}" whose jdbc-type is not compatible with the expected type "{2}".
2002056=Type "{0}" declares datastore identity column "{1}", but this column does not exist in table "{2}".
2002057="{0}" marks its join columns as explicitly not having a foreign key delete action, but a database foreign key exists on these columns.
2002058="{0}" declares an order column column that is not compatible with the expected type "{1}". Column details: {2}
2002059="{0}" has mapping strategy "{1}".
2002060=Writing generated application identity classes.
2002061=Mapping tool running on type "{0}" with action "{1}".
2002062=Type "{0}" cannot use a version field because it has multiple lock groups.
2002063="{0}" defines a target of "{1}" for join column "{2}", but that target does not exist in table "{3}".
2002064=The following columns of table "{0}" could not be reverse mapped "{1}".
2002065=Your configured MetaDataFactory or MappingFactory plugin does not support storing information. You must write the information by hand. If you are trying to create a schema using default column and table names, run mappingtool with the "buildSchema" action instead of the "refresh" or "add" actions.
2002066=Writing java code for generated type "{0}".
2002067="{0}" marks its columns as explicitly not having a foreign key delete action, but a database foreign key exists on these columns.
2002068=Cannot synchronize mapping information: the number of version columns is not equal to the number of lock groups.
2002069=Type "{0}" does not supply a target for column "{1}" in its superclass join. Since this mapping can involve multiple columns and the a target column with the same name doesn''t exist, you must give a target explicitly.
2002070=There has been a fatal change to the definition of "{0}" or its schema since it was last mapped, or the mapping you defined is invalid: {1} OpenJPA will attempt to create a new mapping.
2002071=Usage: java org.apache.openjpa.jdbc.meta.MappingTool 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	[-file/-f <stdout | output file or resource>] 	[-schemaFile/-sf <stdout | output file or resource>] 	[-sqlFile/-sql <stdout | output file or resource>] 	[-schemaAction/-sa <add | retain | drop | refresh | build | none>] 	[-schemas/-s <schemas and tables>] 	[-readSchema/-rs <true/t | false/f>] 	[-primaryKeys/-pk <true/t | false/f>] 	[-foreignKeys/-fk <true/t | false/f>] 	[-indexes/-ix <true/t | false/f>] 	[-dropTables/-dt <true/t | false/f>] 	[-openjpaTables/-kt <true/t | false/f>] 	[-dropSequences/-dsq <true/t | false/f>] 	[-sequences/-sq <true/t | false/f>] 	[-ignoreErrors/-i <true/t | false/f>] 	[-action/-a <refresh | add | buildSchema | drop | validate | import | export>] 	<class name | .java file | .class file | .jdo file | .orm file | .mapping file>*
2002072=Result path "{2}" in result type "{1}" of mapping "{0}" attempts to map a field that does not have exactly 1 column.
2002073=The type for "{0}" is mapped to custom strategy "{1}", but this strategy cannot be instantiated.
2002074=No targets were given. Running on all classes listed in your configuration, or all persistent classes in the classpath if no classes are configured.
2002075=No null-indicator column name was given for "{0}".
2002076=Table "{0}" could not be reverse mapped. This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
2002077="{0}" declares a column in table "{1}", but all columns must be in table "{2}".
2002078=No mapping information found for type "{0}".
2002079="{0}" does not supply a name for at least one declared join column. Since this join can involve multiple columns or uses constant joins, each column must give either its name or a non-constant target.
2002080=Cannot use "{0}" as the mapped-by value for a field in "{1}". The target-field "{2}" for column "{3}" is mapped to multiple columns.
2002081=Writing generated class source code.
2002082="{0}" is marked as having a unique constraint, but OpenJPA does not support a constraint on this mapping in this context.
2002083="{0}" defines a target of "{1}" for column "{2}", but that target does not exist in table "{3}".
2002084="{0}" is marked as having a foreign key, but OpenJPA does not support a foreign key on this mapping in this context.
2002085=When mapping "{0}" to table "{1}", found a column mapped to illegal table "{2}".
2002086=Cannot use "{0}" as the mapped-by value for a field in "{1}". There is no target-field "{2}" for column "{3}" in this subclass.
2002087="{0}" declares a join index, but has no join columns.
2002088=Could not instantiate custom version strategy "{1}" for type "{0}". Make sure this is a valid VersionStrategy implementation.
2002089=Cannot order "{0}" on "{1}", because that field is not in the default fetch group. You can only order on fields that will be selected when the related object is loaded.
2002090="{0}" is being mapped with a handler that may not be able to store values over {1} bytes/chars long.
2002091="{0}" marks its join columns as having a deferred foreign key, but the database dictionary "{1}" reports that it does not support deferred constraints. Creating an undeferred constraint.
2002092="{0}" marks its columns as having a unique index, but the existing index on those columns is not unique.
2002093=Type "{0}" does not supply a name for at least one declared superclass join column.
2002094="{0}" uses an unsupported foreign key delete or update action on its columns. Reverting to a logical foreign key.
2002095="{0}" declares an inverse self-join on table "{1}", but this mapping does not allow inverse joins. If you did not intend to make this an inverse join, take the table name out of the column names for this mapping.
2002096=When mapping "{0}", found join with a target-field in class "{1}". This class does not match the expected source or target mappings for the join ("{2}", "{3}").
2002097=Attempt to map "{0}" failed: the owning entity is not mapped.
2002098="{0}" declares invalid constant value target "{1}" for join column with name "{2}".
2002099="{0}" defines target field "{1}" for join column "{2}", but that field is either unmapped or has multiple columns.
2002100=OpenJPA cannot map field "{0}" efficiently. It is of an unsupported type. The field value will be serialized to a BLOB by default.
2002101="{0}" uses an unsupported foreign key delete or update action on its join columns. Reverting to a logical foreign key.
2002102=Could not instantiate library to import or export mapping information.
2002103="{0}" marks its columns as having a unique constraint, but your database does not support unique constraints. Include "SupportsUniqueConstraints=true" in the org.apache.openjpa.jdbc.DBDictionary configuration property to override this default.
2002104=Writing generated metadata.
2002105="{0}" has columns with targets, but OpenJPA does not support any joins on this mapping in this context.
2002106="{0}" uses columns from multiple different tables: "{1}", "{2}"
2002107="{0}" declares a column that is not compatible with the expected type "{1}". Column details: {2}
2002108="{0}" marks its join columns as explicitly not indexed, but an index exists.
2002109=The system has detected an incomplete join on column "{0}". When you specify a join between tables, you must join to all the columns of any fields involved.
2002110=No order column name was given for "{0}".
2002111="{0}" declares an order column "{1}" whose jdbc-type is not compatible with the expected type "{2}".
2002112="{0}" declares a join column in table "{1}", but all join columns must be in table "{2}".
2002113=Field "{0}" declares both a synthetic ordering column and order-by values. You cannot use both.
2002114="{0}" declares order column "{1}", but this column does not exist in table "{2}".
2002115=Missing table name for field "{0}". This field cannot reside in the owning class table.
2002116=No overridden type mapping for column of type name "{0}".
2002117=No column name was given for "{0}".
2002118=No customized name found for class "{0}" of table "{1}".
2002119=Type "{0}" marks its superclass join columns as having a deferred foreign key, but the database dictionary "{1}" reports that it does not support deferred constraints. Creating an undeferred constraint.
2002120="{0}" marks its columns as explicitly not unique, but a unique constraint exists.
2002121="{0}" declares a column "{1}" whose jdbc-type is not compatible with the expected type "{2}".
2002122="{0}" declares column "{1}", but this column does not exist in table "{2}".
2002123="{0}" does not supply a name for at least one declared column.
2002124="{0}" declares a null-indicator column column that is not compatible with the expected type "{1}". Column details: {2}
2002125=The tool is now reading existing schema information; this process may take some time. Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about schema data. Also see the -readSchema tool flag.
2002126=Could not instantiate custom discriminator strategy "{1}" for type "{0}". Make sure this is a valid DiscriminatorStrategy implementation.
2002127="{0}" has an invalid mapping strategy in this context. Expected "{1}" but found "{2}".
2002128="{0}" marks its columns as explicitly not indexed, but an index exists.
2002129=No customized name found for field "{0}" in type "{1}".
2002130="{0}" is marked as indexed, but OpenJPA does not support an index on this mapping in this context.
2002131="{0}" marks its join columns as having a unique constraint, but your database does not support unique constraints. Include "SupportsUniqueConstraints=true" in the org.apache.openjpa.jdbc.DBDictionary configuration property to override this default.
2002132=Type "{0}" marks its superclass join columns as having a deferred foreign key, but the existing constraint on these columns is not deferred. OpenJPA cannot change the deferrability of a constraint.
2002133="{0}" uses join columns from multiple different tables: "{1}", "{2}"
2002134=Reverse-mapped type "{0}" is configured to use application identity, but has no primary key fields.
2002135=Column "{0}" cannot be involved in polymorphic table-per-class relationships because its corresponding field is mapped differently in various classes in the hierarchy.
2002136="{0}" defines target field of "{1}" for join column "{2}", but that field does not exist in type "{3}".
2002137="{0}" declares a target for column "{1}" in table "{3}", but all targets must be in table "{2}".
2002138=No datastore identity column name was given for "{0}".
2002139="{0}" declares a unique constraint, but has no columns.
2002140=Collection field "{0}" declares that it is mapped by "{1}", but this is not a valid inverse relation.
2002141="{0}" defines target field "{1}" for column "{2}", but OpenJPA cannot deterimine the owning class for that field.
2002142=Initializing mapping for "{0}".
2002143=You have supplied columns for "{0}", but this mapping cannot have columns in this context.
2002144="{0}" declares invalid constant value target "{1}" for column with name "{2}".
2002145="{0}" declares a join foreign key, but has no join columns.
2002146=Type "{0}" defines target field "{1}" for superclass join column "{2}", but that field is either unmapped or has multiple columns.
2002147=Customized name found for class "{0}": will rename as "{1}".
2002148=Column "{0}" is type CHAR(1), but OpenJPA cannot reverse map it into a Java char because OpenJPA is currently configured to store Java chars into numeric database columns. To configure OpenJPA to store Java chars into CHAR(1) columns, set the following property: org.apache.openjpa.jdbc.DBDictionary: StoreCharsAsNumbers=false
2002149="{0}" declares an inverse self-join on table "{1}", but this mapping does not allow inverse joins. If you did not intend to make this an inverse join, take the table name out of the column names for this mapping.
2002150="{0}" does not supply a target for column "{1}". Since this mapping can involve multiple columns and the a target column with the same name doesn''t exist, you must give a target explicitly.
2002151=Could not create a backup file for "{0}".
2002152=No table was given for persistent type "{0}".
2002153=Result path "{2}" in result type "{1}" of mapping "{0}" contains invalid fields.
2002154="{0}" does not supply a target for join column "{1}". Since this join can involve multiple columns and the a target column with the same name doesn''t exist, you must give a target explicitly.
2002155=The following customizer properties were not used in the reverse mapping process: {0}.
2002156="{0}" declares a target for join column "{1}" in table "{3}", but all join targets must be in table "{2}".
2002157=Customized name found for field "{0}" in type "{1}": will rename as "{1}".
2002158="{0}" declares a foreign key, but has no columns.
2002159=Removing class "{0}" of table "{1}" from reverse mapped set.
2002160=Type "{0}" marks its superclass join columns as explicitly not having a foreign key delete action, but a database foreign key exists on these columns.
2002161=You cannot join on column "{0}". It is not managed by a mapping that supports joins.
2002162="{0}" defines target field "{1}" for column "{2}", but that field is either unmapped or has multiple columns.
2002163=Type "{0}" declares superclass join column "{1}" with a target in table "{3}", but all targets must be in table "{2}".
2002164=For "{0}", expected {1} column(s), but found {2}.
2002165="{0}" declares a unique join constraint, but has no join columns.
2002166=Type "{0}" declares a superclass join in table "{1}", but all columns must be in table "{2}".
2002167="{0}" marks its columns as having a deferred unique constraint, but the database dictionary "{1}" reports that it does not support deferred constraints. Creating an undeferred constraint.
2002168=Removing field "{0}" in type "{1}" from reverse mapped set.
2002169=Type "{0}" declares a datastore identity column that is not compatible with the expected type "{1}". Column details: {2}
2002170="{0}" marks its columns as having a deferred foreign key, but the existing constraint on these columns is not deferred. OpenJPA cannot change the deferrability of a constraint.
2002171=Some of the following mappings may not have been dropped: {0}. Undropped mappings will not affect the system.
2002172=Type "{0}" is missing information on how to join to its superclass.
2002173=The reverse mapping tool will run on schema file "{0}".
2002174="{0}" defines target field "{1}" for join column "{2}", but OpenJPA cannot deterimine the owning class for that field.
2002175=The schema for type "{0}" may not be dropped, because its mapping could not be parsed.
2002176="{0}" marks its join columns as explicitly not unique, but a unique constraint exists.
2002177=Type "{0}" does not supply a name for at least one declared column in its superclass join. Since this join can involve multiple columns, each column must give either its name or its target.
2002178=Cannot use "{0}" as the mapped-by value for a field in "{1}". There is no column "{2}" in this subclass'' table.
2002179="{0}" declared custom value handler "{1}", but this handler cannot be instantiated.
2002180=The reverse mapping tool will run on the database. The tool is gathering schema information; this process may take some time. Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about schema data.
2002181=Type "{0}" declares invalid constant value target "{1}" for the column with name "{2}" in its superclass join.
2002182="{0}" does not supply a name for at least one declared join column.
2002183=For type "{0}", expected {1} datastore identity column(s), but found {2}.
2002184=Type "{0}" uses an unsupported foreign key delete or update action on its superclass join columns. Reverting to a logical foreign key.
2002185="{0}" has a column with target field "{1}", but that is not a primary key field of the related class.
2002186=Result path "{2}" in result type "{1}" of mapping "{0}" attempts to traverse through a non-relation field.
2002187=Table "{0}" given for "{1}" does not exist.
2002188="{0}" declares an index, but has no columns.
2002189=Some of the columns on "{0}" are missing target field declarations.
2002190=The declared discriminator value "{1}" for type "{0}" cannot be parsed as a number, though it starts with a digit.
2002191="{0}" attmpts to join a constant value to another constant value.
2002192=The superclass join on type "{0}" uses columns from multiple different tables: "{1}", "{2}"
2002193=Type "{0}" defines a target of "{1}" for superclass join column "{2}", but that target does not exist in table "{3}".
2002194="{0}" has mapping strategy "{1}".
2002195="{0}" does not supply a name for at least one declared column. Since this mapping can involve multiple columns or uses constant joins, each column must give either its name or a non-constant target.
2002196="{0}" marks its join columns as having a deferred foreign key, but the existing constraint on these columns is not deferred. OpenJPA cannot change the deferrability of a constraint.
2002197="{0}" declares null-indicator column "{1}", but this column does not exist in table "{2}".
2002198="{0}" defines target field "{1}" for column "{2}", but that field does not exist in type "{3}".
2002199="{0}" defines target field "{1}" for superclass join column "{2}", but OpenJPA cannot deterimine the owning class for that field.
2002200=Recording mapping and schema changes.
2002201=Calculating reverse mappings.
2002202="{0}" marks its join columns as having a unique index, but the existing index on those columns is not unique.
2002203=Type "{0}" defines target field of "{1}" for superclass join column "{2}", but that field does not exist in type "{3}".
2002204=There is no query result mapping for "{0}" with name "{1}".
2002205=Field "{0}" declares the lock-group extension. In order to use custom lock groups, you must have a performance pack or enterprise edition license. Contact sales@oracle.com for details on upgrading your license.
2002206=Overriding type mapping for column of type name "{0}" to Java class "{1}".
2002207=Attempt to add a null or empty path to result type "{1}" in mapping "{0}".
2002208="{0}" attmpts to join a constant value to another constant value.
2002209="{0}" declares a null-indicator column "{1}" whose jdbc-type is not compatible with the expected type "{2}".
2002210="{0}" does not have a valid mapping. It declares that it is mapped by "{2}", but "{1}", a subclass of its declared type, does not inherit that relation field.
2002211=Resolving mapping for "{0}".
2002212="{0}" cannot be mapped without stringifying the oid of the related object to a string column. The related type is unmapped and its "{1}" primary key field does not use a simple mapping.
2002213=Field "{0}" declares a char array field mapping strategy, but is not a char array field.
2002214=Attempt to flush an unmapped object of type "{0}" with oid "{1}".
2002215=Discriminator value "{0}" is used for two different classes in the same inheritance tree: "{1}", "{2}"
2002216=The discriminator for type "{0}" cannot compute the list of its subclasses on its own. You should either use a discriminator strategy that has this ability (such as the class-name strategy), include the set of persistent classes in the "org.apache.openjpa.MetaDataFactory" property so that OpenJPA can discover all persistent classes at startup, or make sure that all subclasses of this type have had their class instantiated in the JVM before performing any persistent operations on this class or its subclasses. If this class does not have any subclasses, consider making the class final or changing its discriminator strategy to "final".
2002217="{0}" species an object id mapping strategy, but it is not an object id field.
2002218=Map field "{0}" is attempting to use a map table, but its key is mapped by another field. Use an inverse key or join table mapping.
2002219=Object id data "{0}" loaded from the database for "{1}" is not in the correct format. Please ensure that your database records are in the correct format.
2002220=Field "{0}" embedded within object id field "{1}" cannot be a primary key value. Its mapping does not it to be a join target.
2002221=Field "{0}" declares a primitive field mapping strategy, but is not of a primitive type.
2002222=Map field "{0}" is attempting to use an inverse key or join table mapping, but its key is not mapped by another field. Use a map table mapping.
2002223=Field "{0}" declares a handler-based mapping strategy, but no value handler is installed.
2002224=The subclass-join class indicator mapped to "{0}" requires outer joins to function. Your database dictionary is configured to use "traditional" join syntax, which does not support outer joins. To use SQL 92 joins instead, set the following property: org.apache.openjpa.jdbc.DBDictionary: JoinSyntax=sql92
2002225=The discriminator column "{1}" for type "{1}" contains a null or empty value.
2002226=Field "{0}" declares a byte array field mapping strategy, but is not a byte array field.
2002227=Inefficient mapping: You have declared that field "{0}" is mapped by collection "{1}". The mapping would be much more efficient if instead you map "{0}" and declare that "{1}" is mapped by it.
2002228=Type "{0}" does not have any fields that participate in optimistic locking. Set its version strategy to "none".
2002229="{0}" is not a valid mapping. The related type has subclasses that are not reachable via joins, so OpenJPA must be able to construct an oid from the mapped foreign key. But your foreign key does not represent all primary key values of the related type.
2002230=Type "{0}" specifies a full class mapping strategy, but has a mapped persistence capable superclass or is embedded. Use a valid subclass or embedded strategy instead.
2002231=Attempt to use an auto-assigned column value in a handler with multiple columns. To use an auto-assigned column value with field "{0}", you will have to write a custom field mapping that implements the org.apache.openjpa.jdbc.meta.Joinable interface.
2002232="{0}" declares a relation mapping strategy, but is not a direct, non-embedded relation to another persistence-capable object.
2002233=Field "{0}" declares "{1}" as its mapped-by field, but this field is not a direct relation.
2002234="{0}" declares a to-many relation strategy, but its elements are not direct, non-embedded relations to another mapped persistence-capable object.
2002235=Field "{0}" cannot declare that it is mapped by another field. Its mapping strategy ({1}) does not support mapping by another field.
2002236=Could not map disciminator value "{0}" to any known subclasses of the requested class "{1}" (known discriminator values: {2}).
2002237=Field "{0}" cannot be mapped by "{1}", because the related type is unmapped.
2002238=Field "{0}" declares a string field mapping strategy, but is not a string field.
2002239=Field "{0}" declares that it uses class criteria for joins, and this field is not owned by an inverse field. As a result, it is impossible to correctly null the inverse foreign keys when the field is deleted. OpenJPA may leave orphan key values in the database if you do not provide an owning inverse relation using the "mapped-by" attribute.
2002240=Type "{0}" specifies a discriminator strategy, but has a mapped persistence capable superclass or is embedded. Subclasses and embedded values must use the discriminator strategy of the base or embedding class.
2002241=Type "{0}" specifies a version strategy, but has a mapped persistence capable superclass or is embedded. Subclasses and embedded values must use the version strategy of the base or embedding class.
2002242=Loading subclasses from discriminator column of "{0}".
2002243=This container was loaded in large result set field "{0}", but has been removed from its owning field. Therefore, it can no longer be used.
2002244="{0}" cannot be used in a projection, because it can only be loaded as part of its owning object.
2002245=Field "{0}" declares "{1}" as its mapped-by field, but this field is not a collection of inverse relations.
2002246=Type "{0}" uses a flat inheritance mapping, but declares a table name of "{1}", which does not match the superclass table "{2}".
2002247=Field "{0}" declares a blob mapping strategy, but the field''s value is not serialized. Set the field''s "serialized" attribute to true.
2002248=Type "{0}" specifies a subclass mapping strategy, but does not have a mapped persistence capable superclass or is embedded. Use a valid base or embedded class strategy instead.
2002249=Field "{0}" declares a map mapping strategy, but is not a map type.
2002250="{0}" specifies an embedded mapping strategy, but it is not embedded.
2002251=Field "{0}" as defined in "{1}" cannot be mapped by "{2}". You cannot use an inverse foreign key to map a superclass field of an unjoined subclass.
2002252=Field "{0}" declares a collection mapping strategy, but is not a collection or array type.
2002253=Cannot join across "{0}". The related type has unjoined subclasses.
2002254=You cannot map a logical foreign key relation to an object with an unknown identity type.
2002255="{0}" is not a valid mapping. Inverse foreign key-based relations to types with unjoined subclasses are not supported.
2002256=Type "{0}" uses the value-map discriminator strategy, but does not declare a discriminator value.
2002257="{0}" is mapped as embedded, but embedded field "{1}" is not embeddable. Embedded element/key/value types are limited to simple fields and direct relations to other persistent types.
2002258=Field "{0}" declares a clob field mapping strategy, but is not a string field.
2002259=Reading schemas
2002260=The sequence "{0}" was not added to the database.
2002261=Reading sequences for schema "{0}"
2002262=The column "{0}" was not dropped from table "{1}".
2002263=Reading table information for schema name "{0}", table name "{1}".
2002264=The column "{1}" specified by foreign key "{0}" on table "{2}" does not exist in that table.
2002265=Gathering schema information to export; this process may take some time. Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about the collection of schema data.
2002266=Reading indexes for schema name "{0}", table name "{1}".
2002267=Existing foreign key "{0}" on table "{1}" is incompatible with the same foreign key in the given schema definition.
2002268=The specified driver "{0}" is neither a java.sql.Driver nor a javax.sql.DataSource class name.
2002269=Unable to get index information for table "{0}": "{1}"
2002270=Your license only permits a maximum of {0} pooled connections; the connection pool will be configured accordingly.
2002271=The index "{0}" was not created on table "{1}", since it would go beyond the maximum index limit of {2}.
2002272=The sequence "{0}" was not dropped.
2002273=The index "{0}" was not dropped from table "{1}".
2002274=Reading indexes for schema "{0}"
2002275=Creating table to hold schema information.
2002276=use a custom DataSource
2002277=Reading foreign keys for schema "{0}"
2002278=Dropping schema table.
2002279=Writing XML representation of schema.
2002280=Usage: java org.apache.openjpa.jdbc.schema.TableSchemaFactory 	[-properties <properties file or resource>] 	[-<property name> <property value>] 	-action/-a <add | drop>
2002281=You must supply a valid name for this schema component.
2002282=Schema tool will run on schema file "{0}".
2002283=Reading schema "{0}"
2002284=The foreign table "{1}" specified in foreign key "{0}" on table "{2}" does not exist or does not have a primary key.
2002285=Reading indexes for table "{1}"
2002286=The index "{0}" was not created on table "{1}".
2002287=The following error was detected when creating a foreign key: "{0}". The foreign key is being ignored.
2002288=Existing index "{0}" on table "{1}" is incompatible with the same index in the given schema definition.
2002289=Existing column "{0}" on table "{1}" is incompatible with the same column in the given schema definition. Existing column: {2}Given column: {3}
2002290=Reading columns for table "{1}"
2002291=Reading primary keys for schema "{0}"
2002292="{1}" is not a recognized foreign key action. Available actions are: {2}
2002293=The foreign key "{0}" was not added to table "{1}".
2002294=Found existing foreign key "{0}" on table "{1} ({2})" linking to table "{3} ({4})". Sequence: "{5}".
2002295=Reading primary keys for schema name "{0}", table name "{1}".
2002296=Storing imported schema data in schema factory.
2002297=Table "{0}" has a foreign key to table "{1}" that has not been generated. You must run the schema generator on all inter-related tables at once.
2002298=Refresh operation cancelled.
2002299=The column "{1}" specified as part of index "{0}" on table "{2}" does not exist in that table.
2002300=Reading foreign keys for table "{1}"
2002301=Existing primary key "{0}" on table "{1}" is incompatible with the same primary key in the given schema definition.
2002302=The foreign key "{0}" was not dropped from table "{1}".
2002303=Reading column information for table "{0}".
2002304=Reading primary keys for table "{1}"
2002305=A JDBC Driver or DataSource class name must be specified in the ConnectionDriverName property.
2002306=Attempt to write the schema information table for the second time failed. See previous log messages for possible reasons.
2002307=First attempt to write to the schema information table failed; will attempt to create the table in case it has been dropped before re-trying: {0}
2002308=Found existing column "{0}" on table "{1}".
2002309=Schema tool running action "{0}". This process may take some time. Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about the collection of schema data, and the org.apache.openjpa.jdbc.SQL category to see generated SQL commands.
2002310=You cannot perform this action until you set the schema group to act on.
2002311=Usage: java org.apache.openjpa.jdbc.schema.SchemaTool 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	[-file/-f <stdout | output file or resource>] 	[-ignoreErrors/-i <true/t | false/f>] 	[-dropTables/-dt <true/t | false/f>] 	[-openjpaTables/-kt <true/t | false/f>] 	[-dropSequences/-dsq <true/t | false/f>] 	[-sequences/-sq <true/t | false/f>] 	[-primaryKeys/-pk <true/t | false/f>] 	[-foreignKeys/-fk <true/t | false/f>] 	[-indexes/-ix <true/t | false/f>] 	[-record/-r <true/t | false/f>] 	[-action/-a <add | retain | drop | refresh | build | reflect 		| createDB | dropDB | import | export>] 	<.schema file or resource>*
2002312=Reflecting on schemas "{0}". This process may take some time. Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about the collection of schema data.
2002313=Reading sequence information for schema "{0}", sequence name "{1}".
2002314=Recording schema changes.
2002315=Reading foreign keys for schema name "{0}", table name "{1}".
2002316=The column "{1}" of table "{2}" joined to by foreign key "{0}" on table "{3}" does not exist or is not a primary key column.
2002317=The primary key "{0}" was not added to table "{1}".
2002318=Found existing index "{0}" on table "{1} ({2})".
2002319=You are attempting to link to a primary key column in table "{0}" in a foreign key that is already linked to primary key columns in table "{1}".
2002320=Found existing primary key "{0}" on table "{1} ({2})".
2002321=The table "{0}" was not dropped.
2002322=Writing schema data to XML.
2002323=The name "{0}" is already taken by a column in this table.
2002324=The primary key "{0}" was not dropped from table "{1}".
2002325=The schema information table could not be created: {0}
2002326=The table "{0}" was not created.
2002327=Unable to get index metadata for table "{0}": {1}
2002328=Writing schema "{0}".
2002329=The column "{0}" was not added to table "{1}".
2002330=Bad numeric constant for attribute in sequence "{0}".
2002331=You are attempting to add a column from table "{0}" to a constraint or index on table "{1}".
2002332=The column "{1}" specified as part of unique constraint "{0}" on table "{2}" does not exist in that table.
2002333="{1}" is not a recognized foreign key action, though it closely resembles the standard action "{2}". Available actions are: {3}
2002334=The column "{0}" specified as a primary key for table "{1}" does not exist in that table.
2002335=Attempt to read the schema information table failed; continuing on the assumption that the table has not been created yet, and there is no data to read: {0}
2002336=This version of the DataDirect JDBC driver has a bug that prevents SELECT FOR UPDATE statements from working. Please use version 3.2 or higher of the driver.
2002337=This database dictionary does not support auto-assigned column values.
2002338=The database "{0}" does not support the indexOf function.
2002339=Informix cannot perform FOR UPDATE selects on multiple tables, or when it is a SELECT DISTINCT. The tables used in this select are: "{0}". You should either configure your application to avoid multi-table/distinct selects, use optimistic locking, or set the "SimulateLocking" DBDictionary property to allow non-locking selects within pessimistic transactions.
2002340=Foreign key "{0}" on table "{1}" references a table ("{2}") that was not found.
2002341=LOB operations not allowed for batched statement: {0}
2002342=The database dictionary in use ("{0}") reports that it does not have feature "{1}". This feature is needed to complete the current operation. To force OpenJPA to try to use the feature anyway, set the following property: org.apache.openjpa.jdbc.DBDictionary: {1}=<value>
2002343=Oracle 8 does not support SQL92 syntax. You can avoid this message by setting the "JoinSyntax" DBDictionary property to "database".For example: org.apache.openjpa.jdbc.DBDictionary: oracle(JoinSyntax=database)
2002344=Could not find an OracleConnection instance from this connection class "{0}".
2002345=The Microsoft JDBC driver has bugs that manifest themselves when prepared statements are pooled. Please disable prepared statement pooling when using the Microsoft JDBC driver by including "MaxCachedStatements=0" in your org.apache.openjpa.ConnectionFactoryProperties configuration property.
2002346=Cannot outer join tables "{0}" and "{1}" using native join syntax and constant joins. If you are using Oracle 9 or higher, you should instead use SQL92 joins by specifying the JoinSyntax value in the org.apache.openjpa.jdbc.DBDictionary configuration property: org.apache.openjpa.jdbc.DBDictionary: oracle(JoinSyntax=sql92).
2002347=The Oracle 9.2 JDBC driver has problems with batch statements and has been disabled by default. You can enable batched statements by setting the "BatchLimit" DBDictionary property. You may be able to bypass this problem by disabling prepared statement pooling. The compatible 9.0.1 driver does not have this behavior.
2002348=The BatchLimit property was set even though the Oracle 9.2 driver may not support this behavior correctly. If you see a number of invalid update count errors, you should disable statement batching by setting the BatchLimit property to 0.
2002349=Could not outer join the given foreign key "{0}" due to syntax and foreign key limitations. The join was converted to an inner join.
2002350=You are using NCHAR or NCLOB columns with a data source or driver that doesn't implement OraclePreparedStatement.setFormOfUse(). Storing unicode values may fail or be corrupted.
2002351=supplied array of result object providers is empty
2002352=The following error was detected when creating a foreign key: "{0}". The foreign key is being ignored.
2002353=This dictionary ({0}) does not support locking, so operations may not be performed using a Broker that does not have optimistic locking enabled.
2002354=DBDictionary configuration: {0}
2002355=SQLResultSetMapping "{0}" does not map the columns "{1}" that are selected by the SQL query "{2}"
2002356=Your license does not have SQL batching capabilities.
2002357=This database dictionary "{0}" does not support auto-assigned column values. The column "{1}" may not behave as desired.
2002358=Aborting UNION: cannot select placeholder for non-column select SQL.
2002359=This database dictionary "{0}" is not officially supported by Oracle.
2002360=OpenJPA is now connecting to the database in order to figure out what JDBC driver you are using, as OpenJPA must alter its behavior for this database depending on the driver vendor. To avoid this connection, set the DriverVendor value in your org.apache.openjpa.jdbc.DBDictionary configuration property to one of the following values: oracle, oracle92 (for the 9.2 driver), datadirect, datadirect61 (for driver versions <= 3.1), other For example: org.apache.openjpa.jdbc.DBDictionary: oracle(DriverVendor=oracle92)
2002361=The JNetDirect JDBC driver has problems when using batch statements. Please disable prepared statement pooling when using the this JDBC driver by including "BatchLimit=0" in your org.apache.openjpa.jdbc.DBDictionary configuration property.
2002362=Aborting UNION: incompatible ordering columns/sql or direction.
2002363=Aborting UNION: your database does not support ordering columns/sql that appear at different positions in the SELECTs that make up the UNION.
2002364=An error occurred when attempting to rollback to an Oracle savepoint "{0}". You must use Oracle driver and database 9.2 or higher.
2002365=They Sybase connection URL "{0}" may be invalid: it does not contain the parameter "BE_AS_JDBC_COMPLIANT_AS_POSSIBLE=true", which is required for the Sybase JConnect driver to behave in a JDBC-compliant way.
2002366=Aborting UNION: different numbers of order-by criteria in selects.
2002367=The last generated key query did not return any results.
2002368=DB2 cannot perform FOR UPDATE selects on multiple tables. The tables used in this select are: "{0}". You should either configure your application to avoid multi-table selects, use optimistic locking, or set the "SimulateLocking" DBDictionary property to allow non-locking selects within pessimistic transactions.
2002369=Your database configuration was not recognized as a supported OpenJPA database. The generic dictionary will be used, which may result in limited functionality. This behavior can be overridden by specifying the appropriate dictionary class in the "org.apache.openjpa.jdbc.DBDictionary" property of the OpenJPA configuration.
2002370={0}.{1}() is illegal to be invoked
2002371=The column "{0}" was marked as being auto-assigned, but the server reported that the assigned value was null.
2002372=You are using CHAR columns with a data source or driver that doesn't implement OraclePreparedStatement.setFixedCHAR(). Comparisons on unpadded string values may fail.
2002373=This version of the PostgreSQL JDBC driver does not support the Statement.setFetchSize() method. OpenJPA will no longer attempt to set the statement fetch size. To suppress this warning, ensure that the org.apache.openjpa.FetchBatchSize configuration property is set to zero. The original PostgreSQL driver exception is being logged for your reference.
2002374=supplied array of result object providers is null
2002375=An error occurred when attempting to set an Oracle savepoint "{0}". You must use Oracle driver and database 9.2 or higher.
2002376=Individual selects involved in a UNION do not support this operation.
2002377=supplied result set is null
2002378=The SQLServer connection URL "{0}" may be invalid: it does not contain the parameter "SelectMethod=cursor", which is necessary for the driver to properly support large result sets.
2002379=The database "{0}" does not support the substring function.
2002380=This query cannot be completed. The SQL SELECTs needed to complete the query have incompatible ordering. Their results cannot be merged.
2002381=The specified parameter of type "{0}" is not a valid query parameter.
2002382=Using dictionary class "{0}"{1}.
2002383=Attempt to set column "{0}" to two different values: ({1})"{2}", ({3})"{4}" This can occur when you fail to set both sides of a two-sided relation between objects, or when you map different fields to the same column, but you do not keep the values of these fields in synch.
2002384=The database "{0}" has restrictions that prevent it from being able to store the value "{1}" of type "{2}". The value will be rounded to "{3}" for storage.
2002385=min
2002386=Size
2002387=The number of milliseconds between runs of the eviction thread. -1 indicates that the thread will never run.
2002388=Redundant statements
2002389=Cache hits
2002390=Force all connections to be rolled back when they are returned to the pool.
2002391=An error occurred attempting to invoke JDBC 3 method. Your driver or database may not support JDBC 3 features.
2002392=The maximum number of milliseconds to block for database login.
2002393=Shutting down connection pool.
2002394=The JDBC URL for the database.
2002395=Created statements
2002396=Attempt to operate on connection "{0}" that has already been returned to the connection pool.
2002397=Connection opening
2002398=The maximum number of database connections in use at one time.
2002399=A connection could not be obtained for driver class "{0}" and URL "{1}". You may have specified an invalid URL.
2002400=Count
2002401=total
2002402=Requests
2002403=The maximum number of milliseconds to wait for a free database connection to become available before giving up.
2002404=Size
2002405=Overflow
2002406=Error loading JDBC 3 method.
2002407=Leaked statements
2002408={0}
2002409=occurances
2002410=The JDBC driver.
2002411=ResultSet closing
2002412=The minimum number of milliseconds that must elapse before a connection will ever be re-validated.
2002413=Number of idle connections in pool.
2002414=Count
2002415=max
2002416=Cached statements
2002417=Properties applied to the JDBC driver or datasource.
2002418=Redundant
2002419=Hits
2002420=average
2002421=An unexpected exception of type "{0}" occurred while getting a connection. This exception will be re-thrown as a SQLException.
2002422=Whether to validate database connections before obtaining them from the pool.
2002423=Commit execution
2002424=The minimum number of milliseconds that a database connection can sit idle before it becomes a candidate for eviction from the pool.
2002425=Statement execution
2002426=Created
2002427=Waited {0} milliseconds for connection {1}. This might indicate that you need to increase your connection pool size.
2002428=slowest statements
2002429=PreparedStatement execution
2002430=Number of active connections in pool.
2002431=Whether to periodically validate idle database connections.
2002432=Cache requests
2002433=The prepared statement cache has overflowed. "{0}" was removed. You may want to increase your prepared statement cache size. The maximum number of cached statements is currently set to {1}.
2002434=The JDBC user name for connecting to the database.
2002435=Count
2002436=SQL used to validate connections
2002437=The maximum number of idle database connections to keep in the pool.
2002438=Cache overflows
2002439=The connection "{0}" has already been closed. The embedded stack trace for this exception details the closure point.
2002440=Statements
2002441=Rollback execution
2002442=ms
2002443=Error caught when issuing close pool SQL: {0}
2002444=Statements
2002445=Leaked
2002446=Attempted to call JDBC 3 method on a non-JDBC 3 JVM.
2002447=Statements
2002448=The maximum number of connections ({0}) for the connection pool have been exhausted.
2002449=Whether to validate database connections before returning them to the pool.
2002450=Number of connections tested per eviction run.
2002451=Found duplicate generator "{0}" in "{1}". Overriding previous definition.
2002452=Detected declared unique constraints on "{0}". OpenJPA does not yet support the @UniqueConstraint annotation.
2002453=Type "{0}" declares an unnamed @SecondaryTable.
2002454=Version property "{0}" cannot map to a secondary table column. Version columns must always be in the primary table of the class.
2002455=Found duplicate generator "{0}" in "{1}". Ignoring.
2002456=Found duplicate result set mapping "{0}" in "{1}". Ignoring.
2002457=Expected "{0}" to have "{1}" column(s), but you specified "{2}" column(s).
2002458=Attempt to declare mapping overrides on non-embedded field "{0}".
2002459="{0}" declares inconsistent secondary tables on its join columns.
2002460=Embedded property "{0}" declares a mapping override for "{1}", but that is not a persistent property in the embedded type.
2002461=No generated table found at "{0}".
2002462=OpenJPA does not yet support "{1}" as used in "{0}".
2002463=The "usePKasFK" attribute is not yet supported. Mapping your OneToOne using JoinColumns that match your id property columns will work.
2002464=Parsing table generator "{0}".
2002465=Missing "name" property on mapping override for "{0}".
2002466=Found duplicate result set mapping "{0}" in "{1}". Overriding previous definition.
2002467="{0}" declares a secondary table on columns that do not support this attribute.
2002468=Detected inconsistent values of "unique" on different columns of "{0}". OpenJPA does not yet support different per-column unique values. All columns for this mapping must use the same values.
2002469=The table generator in "{0}" must declare a name.
2002470=Parsing result set mapping "{0}".

