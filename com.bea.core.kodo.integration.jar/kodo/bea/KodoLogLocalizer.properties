version=1.0
L10nPackage=kodo.bea
I18nPackage=kodo.bea
subsystem=Kodo
prefix=WL

2000000=Found duplicate generator "{0}" in "{1}". Overriding previous definition.
2000001=Invalid EntityManager properties passed to createEntityManager. See nested exceptions for details.
2000002="{0}" is not a recognized query hint.
2000003=Parsing query "{0}".
2000004=Query did not return any results: "{0}".
2000005="{0}" declares an unnamed fetch group. All fetch groups must have names.
2000006=An error occurred invoking system entity listener callback on instance "{0}".
2000007=Object "{0}" is not managed by this context.
2000008=OpenJPA does not yet support "{1}" as used in "{0}".
2000009=The named query "{0}" in "{1}" must declare a query string.
2000010=Could not load id class "{1}" for type "{0}".
2000011=OpenJPA does not currently support XML element "{0}". Ignoring.
2000012=Found duplicate query "{0}" in "{1}". Ignoring.
2000013=Writing query "{1}" in class "{0}".
2000014=There is no managed transaction in progress to sync this EntityManager with.
2000015=Setting the following properties from "{0}" into configuration: {1}
2000016=Parsing package "{0}".
2000017=The named native query "{0}" in "{1}" must declare a query string.
2000018=Found duplicate generator "{0}" in "{1}". Ignoring.
2000019=Writing query "{1}".
2000020=Fetch group "{0}" in type "{1}" sets a non-zero fetch-depth for field "{2}". OpenJPA currently only supports a fetch depth of zero. Resetting depth to 0.
2000021=Fields "{0}" are not a default persistent type, and do not have any annotations indicating their persistence strategy. If you do not want these fields to be persisted, annotate them with @Transient.
2000022=Field "{0}" is included in fetch group "{1}", but is also in the default fetch group. OpenJPA currently limits fields to one fetch group. Set the field''s "fetch" attribute to "FetchType.LAZY" to exclude it from the default fetch group.
2000023=No class attribute was specified.
2000024=Parsing sequence "{0}".
2000025=Parsing class "{0}".
2000026=The type of field "{0}" isn''t supported by declared persistence strategy "{1}". Please choose a different strategy.
2000027=Found duplicate metadata or mapping for "{0}". Ignoring.
2000028=The jar resource "{0}" cannot be loaded.
2000029=Cannot perform a select on update or delete query: "{0}".
2000030=Type "{0}" does not have a managed field named "{1}".
2000031=Cannot perform this operation on removed entity "{0}".
2000032="{0}" declares generator name "{1}", but uses the AUTO generation type. The only valid generator names under AUTO are "uuid-hex" and "uuid-string".
2000033=The named query in "{0}" must declare a name.
2000034=The parameter index {0} is invalid. Parameters must be integers starting at 1.
2000035=Found duplicate query "{0}" in "{1}". Overriding previous definition.
2000036=You must provide a SQL string when creating a native query.
2000037=When using a persistence context type of TRANSACTION, you can only perform this operation during an active transaction.
2000038=Cannot perform an update or delete operation on select query: "{0}".
2000039=There is no known entity class for entity name "{0}". It is possible that the corresponding class has not yet been registered in the JVM.
2000040=Query returned multiple results: "{0}".
2000041=Invalid EntityManager property passed to createEntityManager. Key: "{0}", Value: "{1}".
2000042=Writing class "{0}".
2000043=Field "{0}" is included in fetch group "{1}", but is already in fetch group "{2}". OpenJPA currently limits fields to one fetch group.
2000044=The class "{0}" is not an entity.
2000045=The named native query in "{0}" must declare a name.
2000046=The parameter "{0}" is of type "{1}", but the declaration in the query is for type "{2}".
2000047=Parsing native query "{0}".
2000048=Fetch group "{0}" in type "{1}" includes field "{2}", but this field is not declared in "{1}", or is not persistent. Currently, OpenJPA only supports declared fields in fetch groups.
2000049=Could not find property/field with the name "{0}" in type "{1}".
2000050=Writing sequence "{0}".
2000051=The sequence generator in "{0}" must declare a name.
2000052=The specified XML resource "{0}" for persistence unit "{1}" can''t be found in your class path.
2000053=You cannot access the EntityTransaction when using managed transactions.
2000054=Cannot perform operation with no transaction.
2000055=A NamingException was thrown while obtaining the factory at "{0}" from JNDI.
2000056=Cannot mix named and positional parameters in query "{0}".
2000057=The specified XML resource "{0}" for persistence unit "{1}" can''t be parsed.
2000058=Field "{0}" cannot be annotated by two persistence strategy annotations.
2000059=Cannot perform this operation on detached entity "{0}".
2000060=Your configuration is missing the required "{0}" property naming the concrete store manager to use to interact with your data store.
2000061=The options supplied to the {0} are not valid. Please check your ant build file.
2000062=java.util.Map
2000063=use a DataSource bound to JNDI
2000064=org.apache.openjpa.lib.remote.Transport
2000065=Cache.Queries
2000066=true
2000067=General
2000068=JDO.Remote
2000069=Your system is missing product derivations. Product derivations provide configuration options for supported data stores and specifications. You must have a META-INF/services/{0} file in your classpath listing the available derivation classes, and some listed class must be instantiable. Typically this file is bundled as part of the distribution. Have you unbundled it, or unbundled its listed classes?
2000070=General
2000071=Query compilation cache
2000072=50
2000073=Attempt to configure for multiple specifications. Was configured for "{0}". Attempt to now configure for "{1}". This attempt will be ignored.
2000074=true
2000075=Remote persistence support
2000076=Plugin used to cache query compilation data. Must implement java.util.Map. Does not need to be thread-safe -- it will be wrapped via the Collections.synchronizedMap() method if it does not extend org.apache.openjpa.util.CacheMap.
2000077=50
2000078=Define the remote persistence server.
2000079=Usage statistics for cache {0}: hits: {1}; misses: {2}; hit ratio: {3}
2000080=The cache "{0}" does not support per-class pinning.
2000081=Put key "{0}" into query cache.
2000082=This thread has been interrupted.
2000083=More than one of the data cache instances in the configuration string "{0}" are configured to be the default data cache. There must be one and only one cache whose name is "{1}", or whose name is not specified.
2000084=Query cache hit while removing key "{0}".
2000085=Unpinning key "{0}". Key is currently not in the cache.
2000086=Query cache miss while looking up key "{0}".
2000087=Put key "{0}" into cache.
2000088=Cannot invoke this method, as the cache has already been configured.
2000089=Cache schedule thread will check every "{0}" min.
2000090=This operation failed for some instances. See the nested exceptions array for details.
2000091=The token "{0}" is not in the valid range ({1}, {2}).
2000092=Cache removing class "{0}".
2000093=Token "{0}" is not a valid number or wildcard (*) for schedule.
2000094=Unable to register Datastore Cache {0} MBean.
2000095=Cache hit while removing key "{0}".
2000096=Pinning key "{0}". Key is currently in the cache.
2000097=Clearing query cache.
2000098=Query cache miss while looking up key "{0}". The key was in the cache, but the results have expired.
2000099=Query cache miss while removing key "{0}".
2000100=Invalid cache type "{0}". Allowed types are "distributed", "replicated", or "named".
2000101=Key "{0}" was expired from the cache.
2000102=Pinning key "{0}". Key is currently not in the cache.
2000103=Cache scheduler thread unexpectedly interrupted. Stopping scheduler.
2000104=Cache miss while looking up key "{0}".
2000105=OpenJPA Cache Scheduler
2000106=Query Cache
2000107=Cache miss while removing key "{0}".
2000108=Invalid schedule string: "{0}"
2000109=Invalid number of tokens in string "{0}" for cache schedule. There should be five tokens (minute, hour, dom, month, dow).
2000110=Stopping scheduled cache eviction thread.
2000111=None of the data cache instances in the configuration string "{0}" are configured to be the default data cache. There must be one and only one cache whose name is "{1}", or whose name is not specified.
2000112=Starting cache scheduler thread "{0}"...
2000113=The cache "{0}" does not supper per-class pinning. All pinned keys will be un-pinned.
2000114=Key "{0}" has expired from the query cache.
2000115=An exception was thrown while executing an expiration listener callback method. It was intercepted. The event framework consumes any exceptions that an ExpirationListener may throw.
2000116=Key "{0}" has been removed from the query cache.
2000117=Registered MBean ({0}).
2000118=Clearing datastore cache "{0}".
2000119=Query cache hit while looking up key "{0}".
2000120=The value corresponding to key "{0}" has timed out.
2000121=Deserialization error, unable to find class.
2000122=Scheduled cache eviction at time "{1}" for cache:"{0}"
2000123=This operation cannot be performed on this list, as the list has been closed.
2000124=Performing a commit on the cache. Adding {0}, updating {1} and {2}, and removing {3}.
2000125=The cache "{0}" does not support per-class pinning.
2000126=Unpinning key "{0}". Key is currently in the cache.
2000127=The datacache does not support automatic removal of subclasses.
2000128=Cache hit while looking up key "{0}".
2000129=This operation is not supported.
2000130=Could not perform automatic lookup of EJB container''s javax.transaction.TransactionManager implementation. Please ensure that you are running the application from within an EJB 1.1 compliant EJB container, and then set the org.apache.openjpa.ManagedRuntime property to the appropriate value to obtain the TransactionManager.
2000131=Expected object to be of type Reference, but instead was "{0}".
2000132=An IllegalAccessException occured when trying to obtain the serialVersionUID field for the class "{0}". This is a known bug in JDK 1.4+ when using a custom ClassLoader to enhance a class that implements java.io.Serializable. If compatibility with non-enhanced versions of "{0}" is not needed, this warning can be ignored.
2000133=Type "{0}" is already persistence capable; skipping.
2000134=Dynamic PCData created: name="{0}", for type="{1}"
2000135=Type "{0}" requires a public constructor to support detach on serialize. Making default constructor public.
2000136=Generating dynamic PCData for type: "{0}"
2000137=Enhancing type "{0}".
2000138=The type "{0}" must have a no-args constructor. Adding a {1} no-args constructor.
2000139=The member for for persistent property "{0}" was not a method: "{1}".
2000140=Type "{0}" does not declare an id class.
2000141="{0}" requires runtime enhancement: {1}
2000142=Bytecode analysis of the setter and getter methods for persistent property "{0}" indicates that the two methods might be acting on different backing fields. The setter method assigns to field "{1}", while the getter method returns field "{2}".
2000143=Application identity class for: {0}
2000144=Attempt to run the application id tool under metadata configuration that does not support it. The application id tool can only run under certain metadata factory settings.
2000145=Usage: java org.apache.openjpa.enhance.ApplicationIdTool 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	[-ignoreErrors/-i <true/t | false/f>]* 	[-directory/-d <output directory>] 	[-name/-n <id class name>] 	[-suffix/-s <id class suffix>] 	[-token/-t <token>] 	[-codeFormat/-cf.<property name> <property value>]* 	<class name | .java file | .class file | .jdo file>+
2000146=Detected the following possible violations of the restrictions placed on property access persistent types: {0}
2000147=An error occurred trying to instantiate a custom storage class.
2000148=Type "{0}" does not have metadata, does not use application identity, or inherits the identity class from its superclass; skipping.
2000149=Auto-generated by:
2000150=The id type "{0}" specfied by persistent type "{1}" does not have a public string or class + string constructor.
2000151=The type "{0}" must have a no-args constructor.
2000152=Generating an application id for type "{0}".
2000153=Type "{0}" has no metadata; enhancing as persistence aware. If you intended for "{0}" to be persistence-capable, then this means that OpenJPA could not find any metadata for "{0}". This can happen if the directory containing your metadata is not in your CLASSPATH, or if your metadata files are not named properly. See the documentation on metadata placement for more information.
2000154=Type "{0}" is set to detach on serialize, but implements a custom readExternal and/or writeExternal method. You cannot use custom serialization with detachment.
2000155=The class does not have metadata - enhanced as persistence-aware.
2000156=No getter method found for persistent property "{0}". All persistent properties must have getter methods.
2000157=You have enabled runtime enhancement, but have not specified the set of persistent classes. OpenJPA must look for metadata for every loaded class, which might increase class load times significantly.
2000158=Writing application identity class to file "{0}".
2000159=When you supply the -name option, you must run the tool on exactly one class. Attempt to run on multiple classes: {0}
2000160=The class is already persistence capable - no enhancement performed.
2000161=An exception was thrown while attempting to perform class file transformation on "{0}":
2000162=No setter method found for persistent property "{0}", and bytecode analysis of the getter did not reveal a clear backing field. Please create a setter method for this property (it may be private).
2000163=Type "{0}" does not declare any primary key fields.
2000164=Application identity tool running on type "{0}".
2000165=The type "{0}" implements Cloneable but does not call super.clone (). Adding protected super.clone () invocation.
2000166=Type "{0}" is set to detach on serialize, but implements a custom readObject and/or writeObject method. You cannot use custom serialization with detachment.
2000167=No targets were given. Running on all classes listed in org.apache.openjpa.PersistentClasses, or all metadata files in classpath directories if the property is not specified.
2000168=Enhancer running on oid: {0}
2000169=Enhancing object id type "{0}" to allow member access.
2000170=Enhancer running on type "{0}".
2000171="{1}" uses property access, but its field "{2}" is accessed directly in method "{3}" defined in "{0}".
2000172=Type "{0}" does not have metadata, does not use application identity, uses a built-in identity type, or inherits the identity class from its superclass.
2000173=No identity class was generated for this type.
2000174=Usage: java org.apache.openjpa.enhance.PCEnhancer 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	[-directory/-d <output directory>] 	[-addDefaultConstructor/-adc <true/t | false/f>] 	[-jdoEnhance/-jdo <true/t | false/f>] 	[-enforcePropertyRestrictions/-epr <true/t | false/f>] 	[-tmpClassLoader/-tcl <true/t | false/f>] 	<class name | .java file | .class file | .jdo file>+
2000175=The statically initialized provider listener is null. This means that the provider startup failed.
2000176=Could not instantiate class {0}.
2000177=Sent JMS update to topic "{0}".
2000178=Still unable to send TCP update to "{0}".
2000179=Error when attempting to accept connection from remote host.
2000180=Attempting to reconnect after JMS failure on topic "{0}". Attempt number: {1}
2000181=Received notification of a JMS failure on topic "{0}".
2000182=Error closing connection for topic "{0}".
2000183=Error creating a publisher or subscriber for JMS topic "{0}". TopicConnectionFactory JNDI name: "{1}".
2000184=You have attempted to access the added object Ids for this event, however the RemoteCommitProvider isn't configured to send them. You need to either update your RemoteCommitEventListerner, or change your org.apache.openjpa.RemoteCommitProvider property so that it includes the option TransmitAddedObjectIds.
2000185=Stopped listening for remote commit information on topic "{0}".
2000186=Identified address of "{0}", which is equal to ourself.
2000187=The provider configuration for this TCPRemoteCommitProvider is not the same as for another provider in the current JVM that is listening on the same port. Port: "{0}".
2000188=You have attempted to access extent information for an event that only carries information as object Ids.
2000189=Started listening for remote commit information on port "{0}".
2000190=Error creating data to send to TCP provider.
2000191=Exception thrown while receiving TCP update.
2000192=Closing transmission connection to "{0}" that was using local port "{1}".
2000193=Successfully reconnected to JMS topic "{0}" after failure.
2000194=An exception occurred while configuring the TCPRemoteCommitProvider configured to listen on port "{0}".
2000195=Error sending TCP update to "{0}".
2000196=Received new connection from "{0}"
2000197=Detected possible orphaned reference to deleted object "{0}" in "{1}" of instance "{2}".
2000198=Exceptions were thrown while executing remote commit listener callback methods. They were consumed: {0}
2000199=Detected possible orphaned reference to deleted object "{0}" in "{1}".
2000200=Configured to send to peer "{0}"
2000201=You have attempted to use a RemoteCommitListener without also specifying a RemoteCommitProvider. In order to use a remote commit listener, you must configure a remote commit provider to use through the org.apache.openjpa.RemoteCommitProvider configuration property.
2000202=You have attempted to access object Ids for an event that only carries information as extents for the modified objects.
2000203=All attempts to reconnect to JMS topic "{0}" failed. Giving up after {1} attempts.
2000204=Exception thrown while closing connection from "{0}".
2000205=Started listening for remote commit information on topic "{0}".
2000206=Attempt to reconnect to JMS topic "{0}" failed.
2000207=Sent TCP update to "{0}" using local port "{1}".
2000208=Exception thrown while closing connection pool.
2000209=Received packet from "{0}" with invalid version number. Check if a prior release of OpenJPA is being used on this host.
2000210=Received event from peer "{0}"
2000211=Error broadcasting JMS update to topic "{0}". Remote BrokerFactories may be out-of-date.
2000212=Closing connection from "{0}".
2000213=Exception thrown while closing TCP remote commit provider.
2000214=Received an unexpected message type on topic "{0}". Message class: "{1}".
2000215=Received JMS update on topic "{0}".
2000216=Creating new socket connection to "{0}", using local port "{1}".
2000217=Received an unexpected object of type "{0}" on topic "{1}".
2000218=Stopped listening for remote commit information on port "{0}".
2000219=Exception thrown while setting NODELAY option for TCP remote commit provider.
2000220=JMSException thrown while retrieving object from an ObjectMessage.
2000221=Method "{1}" not found in class "{0}".
2000222=Received TCP update from "{0}".
2000223=The regular expression string "{0}" is invalid.
2000224=value of type {0}
2000225=The wildcard string "{0}" is invalid.
2000226=field {0} of type {1}
2000227=An error occurred while parsing the query filter "{1}". Error message: {0}
2000228=Subqueries are not supported for queries that execute in-memory. If you do not intend for this query to execute in-memory, consider setting IgnoreCache to true for the query.
2000229=The evaluation of the ordering expression of this query produced non-comparable values "{0}" and "{1}". Please check that the ordering clause is valid.
2000230=Filter invalid. Cannot compare {0} to {1}. Numeric comparisons must be between numeric types only. To enable such comparisons for backwards-compatibility, add "QuotedNumbersInQueries=true" to the org.apache.openjpa.Compatibility setting in your configuration.
2000231=If you use an aggregate function in a query filter, you must make sure to only invoke the aggregate on collections.
2000232=Cannot determine the type of field "{0}".
2000233=The variable "{0}" was found where a constant or field value was expected.
2000234=No "from" clause in expression.
2000235=Wrong number of arguments to expression of type "{1}": should have been {0}, but the following arguments were specified: "{2}".
2000236=Alias "{0}" was declared twice.
2000237=No field named "{1}" in class "{0}".
2000238=The JPQL string "{0}" is not valid. Make sure all parentheses are matched and that you use proper JPQL syntax.
2000239=The positional parameter "{0}" is invalid. Positional parameters must be integers greater than zero.
2000240=Expressions of type "{0}" are not yet supported.
2000241=The entity "{0}" cannot be resolved; please ensure that the entity name has been declared for the class.
2000242=Could not resolve result class named "{0}".
2000243=An error occurred while parsing the query filter ''{1}''. Error message: {0}
2000244=Unknown query operation "{0}".
2000245=Expression "{0}" does not allow mutliple children ("{1}").
2000246=The alias "{0}" was not declared in the statement (declared aliases are: {1}). All aliases must be declared in the "from" section of the JPQL statement.
2000247=The field named "{1}" in class "{0}" could not be accessed.
2000248=The specified node ("{0}") is not a valid identifier.
2000249=Could not resolve entity named "{0}".
2000250=Unknown comparison operator "{0}".
2000251=Attempt to query field "{0}" from non-entity class "{1}".
2000252=An alias is required for the schema name "{0}" in the expression.
2000253=The JPQL statement is not valid: encountered a node of type "{0}".
2000254=The name "{0}" is not a recognized entity or identifier.
2000255=Undeclared identifier "{0}".
2000256=Expression "{0}" requires at least one child.
2000257=JPQL does not support declared parameters.
2000258=Encountered "{0}" at character {1}, but expected: {2}.
2000259=Update expression "{0}" may only use literals or parameters as update values.
2000260=A savepoint with the name "{0}" already exists. Each savepoint name must be unique.
2000261=Attempt to construct a query from an extent or class. You must pass a (possibly null) query string or template to the query factory method when creating the query.
2000262=Executing query: [{0}] with parameters: {1}
2000263=Unable to execute a query on type "{0}". This class or interface is not mapped, and does not have any mapped implementors.
2000264=Some of the object ids passed to getObjectsById were null.
2000265=Cannot perform find using null object id.
2000266=Encountered unmanaged object "{0}" in persistent field "{1}" of managed object "{2}" during flush. However, this field does not allow cascade persist. You cannot flush unmanaged objects.
2000267=The file named "{0}" could not be found.
2000268=Parameter "{0}" was declared with a primtive type, but has been given a null value.
2000269=Could not invoke the static getInstance method on the named factory class "{0}".
2000270=To perform writes on persistent data outside of a transaction, the "NontransactionalWrite" property must be set to true.
2000271=The instance "{0}" has an unknown state manager which prevents field inspection.
2000272=The type "{0}" as used in the parameter declarations could not be found in the imports.
2000273=Detected attempt to modify field "{0}" with value strategy "restrict".
2000274=Query hint value "{0}" ({1}) cannot be converted into an aggregate listener.
2000275=Bulk update queries when executed in memory may only change the value of primitives and simple Object fields.
2000276=This broker is not configured to use managed transactions.
2000277=The factory has been closed. The stack trace at which the factory was closed is held in the embedded exception.
2000278=There was an error packing the projection and/or aggregate results of the query into result type "{0}". See the nested throwable for details.
2000279=The parameter name or position "{0}" passed to execute() is not valid. All map keys must be a declared parameter name or a number matching the parameter position.
2000280=This operation failed for some instances. See the nested exceptions array for details.
2000281=Attempt to change a primary key field of an instance that already has a final object id. Only new, unflushed instances whose id you have not retrieved can have their primary keys changed.
2000282=OpenJPA cannot provide the initial value for field "{0}" because the field was never loaded before being changed.
2000283=Attempted to attach deleted instance type "{0}" with oid "{1}". If the instance is new, the version field should be left to its default value.
2000284=Cannot convert object "{0}" of type "{1}" into an instance of "{2}".
2000285=The specified type "{0}" could not be loaded. Please ensure that the class exists in the project class path.
2000286=Attempt to set an embedded value for unembeddable field "{0}". Please report this error to OpenJPA support.
2000287=Attempt to persist detached object "{0}".
2000288=Queries of this type ("{0}") cannot be executed in-memory. Either set IgnoreCache to true, set the org.apache.openjpa.FlushBeforeQueries property to true, or execute the query before changing any instances in the transaction.
2000289=Attempt to cast instance "{0}" to PersistenceCapable failed. Ensure that it has been enhanced.
2000290=The class "{0}" does not declare the "detachable" metadata extension, so cannot be detached.
2000291=You are attempting to access an embedded object reference that was obtained before the last transaction status change. After transactions begin and end, all references to embedded objects become invalid; you have to re-acquire the reference from the owning persistent object.
2000292=Cannot create an instance of "{0}": abstract classes and interfaces are not yet supported.
2000293=This operation is illegal when called during transaction completion.
2000294=The query cannot be executed because it has no valid expressions.
2000295=You cannot make a property access object created with "new" nontransactional.
2000296=Method "{0}" named in the org.apache.openjpa.MethodQL query must be static.
2000297=You are attempting to directly mutate a persistent second class object (such as a collection or map field) that you obtained before the transaction began. After beginning a datastore transaction, you must re-obtain any references to mutable second class objects from the owning persistent object. Detected attmpt to mutate value of field "{0}" in instance "{1}". This instance may not be locked correctly.
2000298=The given value "{0}" cannot be converted into an identity for "{2}". The value is the wrong type ({1}).
2000299=To perform this operation, you must be withing a transaction, or your settings must allow nontransactional writes and must not detach all nontransactional reads.
2000300=An error occured processing callbacks for instance of type "{0}".
2000301=An exception occurred while ending the transaction. This exception will be re-thrown.
2000302=Detected reentrant flush. Make sure your flush-time instance callback methods or event listeners do not invoke any operations that require the in-progress flush to complete.
2000303=This query on candidate type "{0}" with filter "{1}" involves combining the results of multiple queries in memory. You have chosen to order the results on "{2}", but you have not selected this data in your setResult() clause. Please include this ordering data in setResult() so that OpenJPA can extract it for in-memory ordering.
2000304=This lock manager does not recognize lock level "{0}".
2000305=Queries that have been serialized do not support this operation.
2000306=Attempt to initialize a state manager with a null persistence-capable instance for type "{0}". This is often caused by attempting to load an instance of an abstract class, or neglecting to use a class indicator when the base persistence-capable class in an inheritance tree is abstract.
2000307=More parameters were passed to execute() than were declared: {1} parameters were specified for query execution, but only {0} parameters were declared in the query.
2000308=Encountered unknown dependent instance "{0}". This error is often caused by either removing a dependent instance from one dependent field, but not other dependent fields that reference it, or by removing a dependent instance from its owning field, flushing (causing the unreferenced dependent instance to be deleted), and then trying to assign the deleted instance to another field before commit. The instance cannot be un-deleted, resulting in an error. Make sure not to leave dangling dependent references to objects, and to reassign dependent objects before flush so that OpenJPA does not think they are unreferenced and therefore safe to delete.
2000309=There was an error creating an instance of type "{0}" when packing the projection and/or aggregate results of the query. Ensure that you have defined a public no-args constructor in "{0}".
2000310=This query on type "{0}" must load the entire candidate class extent and evaluate the query in-memory. This may be very slow. The query must be executed in memory because OpenJPA is configured with IgnoreCache=false and FlushBeforeQueries=false and there are dirty instances that may affect the query''s outcome in the cache.
2000311=The context has been closed. The stack trace at which the context was closed is held in the embedded exception.
2000312=Released lock "{0}".
2000313=A candidate Class must be specified before executing a query.
2000314=Queries with aggregates or projections using variables currently cannot be executed in-memory. Either set IgnoreCache to true, set the org.apache.openjpa.FlushBeforeQueries property to true, or execute the query before changing any instances in the transaction. The offending query was on type "{0}" with filter "{1}".
2000315=Attempt to add null/empty field name to fetch configuration.
2000316=A query that declares unique results cannot be used to perform bulk updates.
2000317=The RestoreValues option is off, so initial values are not available. Turn on RestoreValues to be able to obtain initial values.
2000318=This query on candidate type "{0}" with filter "{1}" involves combining the results of multiple sub-queries. However, because this query is for aggregate data, OpenJPA cannot combine the sub-query aggregates into correct final values.
2000319=Could not invoke the static newInstance method on the named factory class "{0}".
2000320=You have modified the object id field of "{2}". Its old value was "{0}", and its new value is "{1}". Object id fields are immutable once the object id of the instance has been assigned.
2000321=This operation cannot be performed while a Transaction is active.
2000322=Attempt to initialize a state manager with an instance that is already managed ("{0}"). You might be trying to persist this instance in two threads at the same time.
2000323=Method "{0}(StoreContext, ClassMetaData, boolean, Map, FetchConfiguration)" is not declared in type "{1}". Check the method name supplied in your org.apache.openjpa.MethodQL query filter. OpenJPA is attempting to execute this query against the datastore; if you implemented the in-memory method instead (a method with the same signature but with an Object argument) and want this query to execute in-memory, supplly a Collection of candidates to filter.
2000324=Attempt to add null/empty fetch group name to fetch configuration.
2000325=Illegal operation attempted on a newly persisted instance: new objects cannot be evicted or made transient or non-transactional.
2000326=You must set the query filter to the name of the method to execute for this org.apache.openjpa.MethodQL query instance.
2000327=A query that declares a result range cannot be used to perform bulk updates.
2000328=The query on candidate type "{0}" with filter "{1}" was configured to have a unique result, but more than one instance matched the query.
2000329=The RestoreValues option is not set to "all", initial values of mutable fields are not available. Set RestoreValues to "all" in your properties to be able to obtain initial mutable values.
2000330=Invoking the setter for hint key "{0}" on "{1}" with value "{2}" caused an error.
2000331=Cannot access the detached object id of class "{0}". Ensure that the class has the "detachable" metadata extension, and the the class has been re-enhanced.
2000332=The field "{0}" of instance "{1}" contained a null value; the metadata for this field specifies that nulls are illegal.
2000333=Cannot instantiate abstract class of type "{0}" with object id "{1}"; this may indicate that the inheritance discriminator for the class is not configured correctly.
2000334=A query that declares a result class cannot be used to perform bulk updates.
2000335=The instance "{0}" is managed by another context and cannot be inspected for field values.
2000336=The object "{0}" with id "{1}" has been deleted and cannot be attached.
2000337=Attempt to assign id "{0}" to new instance "{1}" failed; there is already an object in the L1 cache with this id. You must delete this object (in a previous transaction or the current one) before reusing its id. This error can also occur when a horizontally or vertically mapped classes uses auto-increment application identity and does not use a hierarchy of application identity classes.
2000338=Attempted to attach instance "{0}" of type "{1}", but this instance is already in the datastore as type "{2}".
2000339=Attempt to modify a read-only query object.
2000340=Operation attempted on a deleted instance.
2000341=You cannot perform operation {0} on detached object "{1}". This operation only applies to managed objects.
2000342=Acquired an exclusive lock on oid "{0}": "{1}".
2000343=A NamingException was thrown while obtaining the factory at "{0}" from JNDI.
2000344=You cannot use the modulo operator (%) on numbers of type BigDecimal.
2000345=You cannot refresh an instance that has been flushed to the data store.
2000346=Unable to copy field "{0}" for savepoint.
2000347=An inverse inconsistency in the object model was detected while flushing the field "{0}" of the instance with id "{1}" in context "{2}".
2000348=The transaction has been rolled back. See the nested exceptions for details on the errors that occurred.
2000349=Encountered deleted object "{0}" in persistent field "{1}" of managed object "{2}" during flush.
2000350=Query projections cannot include array, collection, or map fields. Invalid query: "{0}"
2000351=Query hint value "{0}" ({1}) cannot be converted into a filter listener.
2000352=Attempt to access an unloaded field of detached instance "{0}".
2000353=Cannot manipulate identity of type "{0}": it''s identity type is unknown.
2000354=You cannot assign managed object "{0}" to the primary key field of "{1}". Embedded primary key values must be transient objects.
2000355=Method "{0}(StoreContext, ClassMetaData, boolean, Object, Map, FetchConfiguration)" is not declared in type "{1}". Check the method name supplied in your MethodQL query filter. OpenJPA is attempting to execute this query in-memory; if you implemented the datastore method instead (a method with the same signature but without the Object argument) and want this query to execute in the datastore, either make the query before modifying objects in the current transaction, set IgnoreCache to true, or set the openjpa.FlushBeforeQueries property to true.
2000356=The "{0}" transaction property cannot be set during an active transaction.
2000357=This savepoint has already been initialized.
2000358=The named BrokerFactory "{0}" is not valid.
2000359=The given instance "{0}" is not managed by this context.
2000360=Attempt to commit a null javax.transaction.Transaction. Some application servers set the transaction to null if a rollback occurs.
2000361=Cannot load object with id "{0}". Instance "{1}" with the same id already exists in the L1 cache. This can occur when you assign an existing id to a new instance, and before flushing attempt to load the existing instance for that id.
2000362=Result type "{0}" does not have any public fields or setter methods for the projection or aggregate result element "{1}", nor does it have a generic put(Object,Object) method that can be used, nor does it have a public constructor that takes the types {2}.
2000363=Invoking the getter for hint key "{0}" on "{1}" caused an error.
2000364=There was an error when invoking the static newInstance method on the named factory class "{0}". See the nested exception for details.
2000365=The range of the query is too big. Start index: "{0}", end index: "{1}". The range must be less than Integer.MAX_VALUE.
2000366=There was an error invoking method "{0}" with arguments "{1}".
2000367="{0}" is not the index of any managed field in "{1}".
2000368=This datastore does not support optimistic transactions. Set the Optimistic property to false.
2000369=The query range from {0} to {1} is not valid.
2000370=Can only perform operation while a transaction is active.
2000371=You have not set a savepoint with the name "{0}"
2000372=Illegal operation attempted on a dirty instance: dirty objects cannot be evicted or made transient or non-transactional.
2000373=Cannot create new application identity instance for abstract class "{0}".
2000374=Illegal operation attempted on a transient instance.
2000375=There was an error when invoking the static getInstance method on the named factory class "{0}". See the nested exception for details.
2000376=This data store does not support nontransactional reads. Set the NontransactionalRead property to false.
2000377=Starting OpenJPA {0}
2000378=The "{0}" query type does not support this operation.
2000379=Properties: {0}
2000380=To perform reads on persistent data outside of a transaction, the "NontransactionalRead" property must be set on the Transaction.
2000381=Encountered new object "{0}" in persistent field "{1}" of managed object "{2}" during attach. However, this field does not allow cascade attach. You cannot attach a reference to a new object without cascading.
2000382=This data store cannot return connections.
2000383=Encountered object "{0}" without a version field during attach. In order to attach an object, it must either be enhanced or must have a version field.
2000384=Field "{0}" is not declared in "{1}", or is not managed.
2000385=The transaction cannot be committed, because it was already marked for rollback only. The transaction will be rolled back instead.
2000386=You did not name the factory class with the required property org.apache.openjpa.BrokerFactory.
2000387=Cannot execute query; some declared parameters were not given values. You must supply a value for each of the following parameters, in the given order: {0}
2000388=The configured SavepointManager does not support incremental flushing when a savepoint has been set. You must release your savepoints before flushing.
2000389=Cannot rollback/release last savepoint as no savepoint has been set.
2000390=The {1} declaration "{0}" is not valid. Variables and imports must be delimited with ";". Parameters and orderings must be delimited with ",". Imports require the "import" keyword, and orderings require the "ascending" or "descending" keyword.
2000391=There is no conversion between query projection type "{0}" and result type "{1}".
2000392=Attempt to copy field "{0}" failed. The field is not copyable. This can occur with custom SCO types or with large result set fields. Only standard or immutable SCO types can be attached and detached.
2000393=Cannot execute query; the declared parameter "{0}" was not given a value.
2000394=An object of type "{0}" with oid "{1}" already exists in this context; another cannot be persisted.
2000395=The instance of type "{0}" with oid "{1}" no longer exists in the data store. This may mean that you deleted the instance in a separate transaction, but this context still has a cached version.
2000396=The type "{0}" declares datastore identity but the value passed to lookup of type "{1}" is not a OpenJPA id instance.
2000397=You set the method name of this openjpa.MethodQL query to "{1}", but class "{0}" is not a valid class name. Make sure to fully qualify the class name or to import its package into this query if the class is not in the query candidate class'' package.
2000398=Executing query: {0}
2000399=This data store does not support incremental flushing. If you got this error while performing a query, make sure that you have not set the FlushBeforeQueries option to true, either by setting that option in your configuration file, or by programmatically setting the current FetchConfiguration''s FlushBeforeQueries property to QueryFlushModes.FLUSH_TRUE.
2000400=Type "{0}" and its persistent superclass "{1}" declare different access types. All persistent classes in an inheritance hierarchy must use the same access type (field vs. property access).
2000401=Concrete type "{0}" with application identity does not declare any primary key fields.
2000402=A potentially serious error occurred while processing registered class "{0}". Deferring processing of this class until next opportunity.
2000403=The metadata for some of the following classes may not have been dropped: {0}
2000404=Field "{0}" is not a type that is persistent by default. If you want this field to be persistent, you have to explicitly set it to persistent in your metadata.
2000405=Array fields do not support large result sets. Remove the "lrs" extension from field "{0}".
2000406=Generating default metadata for type "{0}".
2000407=Type "{0}" is an interface and therefore cannot be made persistent.
2000408=There was an error invoking the factory for field "{0}" on datastore value "{1}": {2}
2000409=Field "{0}" is named as the detach state field in type "{1}", but is a managed field. Detach state fields cannot be managed.
2000410=Attempt to add an unnamed fetch group to "{0}".
2000411="{0}" declares a read only value of "{1}". This is not a recognized strategy. Available strategies are: {2}
2000412=The identity class specified by type "{0}" is not valid, as the hashCode method is not overridden. Implement hashCode so that two instances with the same primary key values have the same hash code.
2000413=The extension key "{1}" for "{0}" is not recognized and will be ignored, although the name closely matches the valid key "{3}". Valid extension keys are "{2}".
2000414=Could not locate metadata for the class using alias "{0}". Registered alias mappings: "{1}"
2000415=Attempt to include non-existent fetch group "{1}" in fetch group "{0}".
2000416=The map value type of field "{0}" a derived key must be a persistent class with exactly one primary key field.
2000417=Your configured MetaDataIO cannot create metadata. You must create it by hand.
2000418=Metadata tool running on type "{0}" with action "{1}".
2000419=The class name "{0}" used in a metadata extension on field "{1}" is not valid.
2000420=The class "{0}" listed in the openjpa.MetaDataFactory configuration property could not be loaded; ignoring.
2000421=Type "{0}" with application identity and no superclass does not declare an id class. This type is not eligible for builtin identity, so it must declare an id class.
2000422=Field "{0}" attempts to recursively embed its declaring type.
2000423=Large result set fields must be of type java.util.Collection or java.util.Map. No concrete classes or other interfaces are allowed. Remove the "lrs" extension from field "{0}" or change it to one of these types.
2000424=An invalid null external-value was declared for field "{0}".
2000425=The identity class specified by type "{0}" is not valid, as the equals method is not overridden. Implement the equals method so that two two instances will compare equal if and only if they have the same primary key values.
2000426=Field "{0}" is marked as embedded, but the store manager in use cannot embed first-class object fields. Treating as non-embedded.
2000427=Superclass field "{0}" is mapped in the metadata for subclass "{1}", but is not a persistent field.
2000428=Field "{0}" declares a logical inverse of "{1}", but that is a not a field of the related type.
2000429=Initializing mapping for "{0}".
2000430=Attempt to include fetch group "{1}" in fetch group "{0}" creates an inclusion cycle.
2000431=The data store does not support application identity. Alter "{0}" to use datastore identity.
2000432=An error occurred while processing registered class "{0}".
2000433=Type "{0}" uses application identity; it cannot also declare a datastore identity strategy.
2000434=Field "{0}" named as the detach state field for type "{1}" does not exist.
2000435=Field "{0}", named as the detach state field for type "{1}", must be of type Object.
2000436=The map value type of field "{0}" with a derived key must be a persistent class.
2000437=Named sequence "{0}" declares an invalid class "{1}".
2000438="{0}" declared that it is mapped by "{1}", but that is a not a field of the related type.
2000439=Type "{0}" declares a detach object id field, but uses application identity. Detach object id fields are only used for datastore identity classes.
2000440=Field "{0}" cannot be ordered. Ordering is only supported for collection and array fields.
2000441=Resolving field "{0}".
2000442=Fetch group "{0}" specifies invalid recursion depth "{2}" for field "{1}". Recursion depth must be greater than or equal to -1.
2000443=Could add the following callback adapters to "{0}", as the lifecycle metadata is already resolved: {1}
2000444=No method was found for the persistent property "{0}" declared in "{1}" or one of its superclasses. Searched for methods called "{2}" and "{3}".
2000445=Field "{0}" cannot be a primary key. Primary key fields can only be declared in base persistent classes that also declare their identity-type to be "application".
2000446=jdbc-
2000447="{0}" declares that it is mapped by "{1}", but that field also declares that it is mapped by another. Only one side of a relation can declare that it is mapped by another field.
2000448=Field "{0}", named as the detach object id field for type "{1}", must be of type String.
2000449=The id class specified by type "{0}" does not match the primary key fields of the class. Make sure your identity class has the same primary keys as your persistent type, that the access types are the same, and if you are getting this error at runtime, that you have your persistent class since last compiling your identity class.
2000450=No metadata was found for type "{0}". The class does not appear in the list of persistent types: {1}.
2000451=Guessing persistence-capable class name for identity class "{0}".
2000452=Field "{0}" is marked as embedded, but OpenJPA is unable to embed the field. OpenJPA cannot embed first-class object fields produced through an externalizer. Treating as non-embedded.
2000453=Errors encountered while resolving metadata. See nested exceptions for details.
2000454=There was an error instantiating named sequence "{0}".
2000455=Resolving embedded metadata for "{0}".
2000456=Preparing mapping for "{0}".
2000457=No metadata was found for type "{0}". The class is not enhanced.
2000458=Clearing metadata repository "{0}".
2000459=Unable to resolve type "{0}" due to previous errors resolving related type "{1}".
2000460=Externalized fields do not support large result sets. Remove the "lrs" extension from field "{0}".
2000461=Processing registered persistence-capable class "{0}".
2000462=Field "{0}" cannot be a primary key. It is of an unsupported type.
2000463=Usage: java org.apache.openjpa.meta.MetaDataTool 	[-properties/-p <properties file or resource>] 	[-<property name> <property value>]* 	[-verbose/-v <true/t | false/f>] 	[-file/-f <stdout | output file or resource>] 	[-action/-a <add | drop>] 	<class name | .java file | .class file>+
2000464=The factory method supplied for field "{0}" does not exist or is not a valid constructor or method. If the factory is a method of the owning class and not the field type, make sure you have declared the method in the form "<owning-class>.<method-name>". Also, make sure the specified factory method is static.
2000465=No metadata was found for type "{0}". Ensure that the class is enhanced (if necessary), that the class has appropriate metadata, and that if you list your persistent classes, the class is included in your list.
2000466=Type "{0}" is an enumeration and therefore cannot be made persistent.
2000467=No method was found for the persistent property "{0}" declared in "{1}" or one of its superclasses. Searched for a method called "{2}".
2000468=The metadata for "{0}" sets its value or identity strategy to sequence, but does not name the sequence to use.
2000469=Loading mapping for "{0}" under mode "{1}".
2000470=Could not locate the sequence with name "{0}". It is possible that the metadata file containing the sequence has not been parsed yet. Make sure to use a persistent class whose metadata is in the same file somewhere in your application before requesting the sequence.
2000471=The externalizer method "{1}" on field "{0}" is not valid. If this is a method of the owning class type and not the field type, make sure you have declared the method in the form "<owning-class>.<method-name>", and that the method is static.
2000472=The ClassMetaData access type must be set to either ClassMetaData.ACCESS_FIELD or ClassMetaData.ACCESS_PROPERTY. Attempt to set it to "{0}" failed.
2000473=Type "{0}" declares an id class "{1}" that does not match or extend its persistent superclass "{2}" identity class "{3}".
2000474=The field "{0}" cannot use the external-values property. External values can only be declared for fields of primitives, primitive wrappers, or strings.
2000475=Type "{0}" declares field "{1}" as a primary key, but keys of type "{2}" are not supported.
2000476=Field "{0}" uses an invalid combination of in-memory and datastore ordering for its values. If a combination is used, all in-memory orderings must appear in the ordering declaration before datastore orderings.
2000477=Recording metadata changes.
2000478="{0}" declares an unsupported strategy of "{1}" for its {2}.
2000479=Type "{0}" declares an invalid data-cache-timeout value. Valid timeout values are -1 (to disable timeouts), or positive integers. Timeout was set to {1}.
2000480=Resolving mapping for "{0}".
2000481=There was an error invoking the externalizer for field "{0}" on Java value "{1}": {2}
2000482=The field "{0}" cannot declare both an externalizer method and external values.
2000483=Type "{0}" declares a detach object id field, but is not the least-derived detachable class in the inheritance tree. Only the least-derived detachable class can name the detach object id and state fields.
2000484=Type "{0}" is mapped to the data store, but does not have an identity type. Alter its metadata to declare datastore identity or to have at least one primary key field.
2000485=You cannot declare that "{0}" is mapped by another field. Only direct field values and map keys can be mapped by another field.
2000486=Type "{0}" declares a cache name of "{1}", but its persistent superclass "{2}" uses a different cache name ("{3}").
2000487=Could not locate metadata for the class using oid "{0}" of type "{1}". Registered oid type mappings: "{2}"
2000488=The field "{0}" declares an external-values property but does not declare any values in the string: "{1}".
2000489=Type "{0}" declares a detach state field, but is not the least-derived detachable class in the inheritance tree. Only the least-derived detachable class can name the detach object id and state fields.
2000490=Type "{0}" has multiple version fields: [{1}, {2}]
2000491="{0}" declares an identity or value strategy of "{1}". This is not a recognized strategy, though it closely resembles the standard strategy "{2}". Available strategies are: {3}
2000492=Cannot order "{0}" on "{1}", because {0} is not a relation to another persistent type. For non-relation fields, you can only order on the field element values themselves, represented by "#element".
2000493=The data store does not support datastore identity. Alter "{0}" to use application identity.
2000494=Cannot order "{0}" on "{1}", because that is not a persistent field in the related type.
2000495=The type "{0}" has not been enhanced.
2000496=Field "{0}" named as the detach object id field for type "{1}" does not exist.
2000497=Field "{0}" is marked as having an embedded element or value type, but the store manager in use cannot embed collection/map elements. Treating as non-embedded.
2000498=There is no named query defined for the class "{0}" with the name "{1}".
2000499=Field "{0}" declares that it is mapped by a field that is different from its logical inverse field. You do not need to name the logical inverse if you''ve already declared that the field is mapped by another, but if you do, then the logical inverse must point to the mapping field.
2000500=Loading metadata for "{0}" under mode "{1}".
2000501=The extension key "{1}" for "{0}" is not recognized and will be ignored. Valid extension keys are "{2}".
2000502=Field "{0}" is marked as having an embedded key type, but the store manager in use cannot embed map keys. Treating as non-embedded.
2000503=The id class specified by type "{0}" does not have public a no-args constructor.
2000504=Resolving metadata for "{0}".
2000505=Type "{0}" attempts to use both field and property access. Only one access method is permitted.
2000506=Set persistence-capable superclass of "{0}" to "{1}".
2000507="{0}" declares an identity or value strategy of "{1}". This is not a recognized strategy. Available strategies are: {2}
2000508=The data store does not support fields of type {0}.
2000509=Using reflection for metadata generation.
2000510=Field "{0}" is named as the detach object id field in type "{1}", but is a managed field. Detach object id fields cannot be managed.
2000511=Type "{0}" does not declare the same identity-type as its persistent superclass.
2000512=No field was found for the persistent property "{0}" declared in "{1}" or one of its superclasses.
2000513=Found {0} classes with metadata in {1} milliseconds.
2000514=Attempt to add fetch group "{0}" to type field "{1}" failed. This fetch group has not been defined.
2000515="{0}" declares a read only value of "{1}". This is not a recognized strategy, though it closely resembles the standard strategy "{2}". Available strategies are: {3}
2000516=A unique constraint violation has occurred.
2000517=Missing getter for property "{1}" in type "{0}".
2000518=Unable to create second class object proxy for type: "{0}".
2000519=Encountered object id "{0}" in serialized data, but the corresponding persistent object no longer exists. Substituting null into the deserialization stream.
2000520=Could not obtain a lock on object "{0}" in {1} milliseconds.
2000521=The instance "{0}" cannot be persisted, because it conflicts with an existing instance.
2000522=No store-specific facade found matching "{0}". Using default.
2000523=A duplicate object id exception has occurred. Each object you insert into the data store must have unique primary key field values.
2000524=The given type "{0}" does not use single field identity.
2000525=While creating datastore identity for "{0}", unknown id value "{1}" of type "{2}" encountered. Cannot convert to org.apache.openjpa.util.Id.
2000526=Nested:
2000527=An exception was thrown while creating a new instance of custom proxy collection type "{0}". This could mean that there is no public no-args constructor for this type.
2000528=Bad single primary key field "{0}"
2000529=The follwing instnaces do not exist in the data store: {0}
2000530=A referential integrity constraint has occurred.
2000531=The instance "{0}" does not exist in the data store.
2000532=The given element does not meet the requirements for this field. The container requires that all non-null objects are of the type declared in the XML metadata for this container. "{1}(loader={0}).isAssignableFrom ({3}(loader={2}))" failed.
2000533=You cannot transfer large result set fields from one object or field to another.
2000534=Missing setter for property "{1}" in type "{0}".
2000535=An optimistic lock violation was detected when flushing object instance "{0}" to the data store. This indicates that the object was concurrently modified in another transaction.
2000536=Unable to copy array: {0}.
2000537=An invalid key was found in a CacheMap while flushing data from it. CacheMap: "{0}". Key: "{1}". All unpinned objects were cleared from the CacheMap in order to re-establish a consistent cache.
2000538=Optimistic locking errors were detected when flushing to the data store. The following objects may have been concurrently modified in another transaction: {0}
2000539=Invalid single identity declaration for type "{0}". Only a single field can be declared for single field identity.
2000540=Unable to obtain an object lock on "{0}".
2000541=Optimistic locking errors were detected when flushing to the data store. This indicates that some objects were concurrently modified in another transaction. Each exception in the nested throwables array contains a failed object representing a concurrently modified object.
2000542=Failed:
2000543=Null id value encountered while creating datastore identity for "{0}".
2000544=Unable to create a valid id from string "{0}".
2000545=No filesets specified.
2000546=An exception occurred while invoking close() on "{0}". This exception will be consumed.
2000547=Instantiation of plugin "{0}" with value "{1}" caused an error "{2}". The alias or class name may have been misspelled (as it closely matches the valid plugin alias "{4}"), or the class may not be available in the class path. Valid aliases for this plugin are: {3}
2000548=An instance of the class "{0}" could not be instantiated. Make sure the class has a public no-args constructor.
2000549=The configuration is read only; it cannot be modified.
2000550=There was an error while setting up the configuration option "{0}", and it was set to "{1}". All possible values for this setting are: {2}.
2000551=The property named "{0}" was not recognized and will be ignored.
2000552=Errors occurred while creating property descriptors for the following properties: {0}.
2000553=Configuration information loaded via "{0}".
2000554=You cannot set the value of property "{0}" as an object. The property cannot use a single value; it must be recreated on each request.
2000555=An exception occurred while creating a plugin for value {0}. This exception will be consumed.
2000556=There was an error duing JNDI lookup of the name "{0}".
2000557=An exception occurred while invoking afterConfigurationLoad() on "{0}". This exception will be consumed.
2000558=An exception occurred while invoking beforeConfigurationLoad() on "{0}". This exception will be consumed.
2000559=You cannot supply a configuration unit name only. You must also supply the name of the resource in which the unit appears.
2000560=Instantiation of plugin "{0}" with value "{1}" caused an error "{2}". The alias or class name may have been misspelled, or the class may not be available in the class path.
2000561=Found multiple properties with different valid prefixes. Properties: {0}, {1}.
2000562=No registered configuration provider could load "{0}".
2000563=Default configuration information couldn''t be loaded from any configuration provider.
2000564=Your system is missing configuration providers. Configuration providers load configuration information for supported specifications. You must have a META-INF/services/{0} file in your classpath listing the available provider classes, and some listed class must be instantiable. Typically this file is bundled as part of the distribution. Have you unbundled it, or unbundled its listed classes?
2000565=There was an error parsing the properties string "{0}". Please check that the format is: "<name1>=<value1> <name2>=<value2> ...".
2000566=The property named "{0}" was not recognized and will be ignored, although the name closely matches a valid property called "{1}".
2000567=Configuration property "{0}" cannot be set from a string. You must supply the object value.
2000568=There was an error while setting up the configuration plugin option "{0}". The plugin was of type "{1}". Setter methods for the following plugin properties were not available in that type: {2}. Possible plugin properties are: {3}. Ensure that your plugin configuration string uses key values that correspond to setter methods in the plugin class.
2000569=There were errors initializing your configuration: {0}
2000570=Instantiation of plugin "{0}" with value "{1}" caused an error "{2}". The alias or class name may have been misspelled, or the class may not have be available in the class path. Valid aliases for this plugin are: {3}
2000571=There was an error while setting up the configuration plugin option "{0}". The plugin was of type "{1}". The plugin property "{2}" had no corresponding setter method or accessible field. The plugin property closely matches "{3}"; perhaps the property was misspelled. Ensure that your plugin configuration string uses key values that correspond to setter methods in the plugin class. All possible plugin properties are: {4}.
2000572=FATAL
2000573=UNKNOWN
2000574=ERROR
2000575=The file name "{0}" is not valid.
2000576=An error occurred while trying to create a LogFactory of type "{0}", as specified by the openjpa.Log system property. Created a org.apache.openjpa.lib.log.LogFactoryImpl instead.
2000577=INFO
2000578=TRACE
2000579=The log level string "{0}" is not valid. Valid values are TRACE, INFO, WARN, ERROR or FATAL.
2000580={0}
2000581=WARN
2000582=Source file locations:
2000583=Serializing contents: {0}
2000584=Too many files to scan for metadata. Reached limit of {0} files.
2000585=Parsing class "{0}".
2000586=An exception occurred while parsing {0} at location {1}. This exception has been translated to a SAXException, and will be re-thrown. The original exception is being logged along with this message.
2000587=An error was encountered while parsing element "{0}". Make sure the metadata file is correctly formatted.
2000588={0}: {1}
2000589=Skipping resource "{0}"; it was parsed previously.
2000590=Writing to file "{0}".
2000591=XML schema validation is disabled due to bugs detected in the SAX parser.
2000592=Writing object "{0}".
2000593=No source file found for "{0}".
2000594=Adding parse result: "{0}"
2000595=<file location unknown>
2000596=Location:
2000597=Error extracting class information from "{0}".
2000598=Finished parsing metadata resource "{0}".
2000599=Clearing cache of parsed files in "{0}".
2000600=Parsing resource "{0}".
2000601=Type "{0}" could not be instantiated.
2000602=Unable to differentiate between given package and class elements for class arg parsing. No element can be a complete prefix of another.
2000603=The result list has been closed.
2000604=The RangeResultObjectProvider can only be used for ranges that are below Integer.MAX_VALUE. Start index: "{0}", end index: "{1}".
2000605=Result lists are read-only.
2000606=Duplicate keys are not allowed in this properties file. Key: {0}, first value: {1}, second value: {2}.
2000607=Illegal load value of {0} specified.
2000608=Illegal initial value of {0} specified.
2000609=Line: {0}, C: {1}
2000610=Unknown

