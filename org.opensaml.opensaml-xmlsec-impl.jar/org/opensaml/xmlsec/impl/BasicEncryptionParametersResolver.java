package org.opensaml.xmlsec.impl;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Collections2;
import java.security.Key;
import java.security.KeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import net.shibboleth.utilities.java.support.annotation.constraint.NotEmpty;
import net.shibboleth.utilities.java.support.logic.Constraint;
import net.shibboleth.utilities.java.support.resolver.CriteriaSet;
import net.shibboleth.utilities.java.support.resolver.ResolverException;
import org.opensaml.security.credential.Credential;
import org.opensaml.security.credential.CredentialSupport;
import org.opensaml.xmlsec.EncryptionConfiguration;
import org.opensaml.xmlsec.EncryptionParameters;
import org.opensaml.xmlsec.EncryptionParametersResolver;
import org.opensaml.xmlsec.KeyTransportAlgorithmPredicate;
import org.opensaml.xmlsec.algorithm.AlgorithmRegistry;
import org.opensaml.xmlsec.algorithm.AlgorithmSupport;
import org.opensaml.xmlsec.criterion.EncryptionConfigurationCriterion;
import org.opensaml.xmlsec.criterion.EncryptionOptionalCriterion;
import org.opensaml.xmlsec.criterion.KeyInfoGenerationProfileCriterion;
import org.opensaml.xmlsec.encryption.support.RSAOAEPParameters;
import org.opensaml.xmlsec.keyinfo.KeyInfoGenerator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class BasicEncryptionParametersResolver extends AbstractSecurityParametersResolver implements EncryptionParametersResolver {
   private Logger log = LoggerFactory.getLogger(BasicEncryptionParametersResolver.class);
   private AlgorithmRegistry algorithmRegistry = AlgorithmSupport.getGlobalAlgorithmRegistry();
   private boolean autoGenerateDataEncryptionCredential;

   public AlgorithmRegistry getAlgorithmRegistry() {
      return this.algorithmRegistry == null ? AlgorithmSupport.getGlobalAlgorithmRegistry() : this.algorithmRegistry;
   }

   public void setAlgorithmRegistry(@Nonnull AlgorithmRegistry registry) {
      this.algorithmRegistry = (AlgorithmRegistry)Constraint.isNotNull(registry, "AlgorithmRegistry was null");
   }

   public boolean isAutoGenerateDataEncryptionCredential() {
      return this.autoGenerateDataEncryptionCredential;
   }

   public void setAutoGenerateDataEncryptionCredential(boolean flag) {
      this.autoGenerateDataEncryptionCredential = flag;
   }

   @Nonnull
   public Iterable resolve(@Nonnull CriteriaSet criteria) throws ResolverException {
      EncryptionParameters params = this.resolveSingle(criteria);
      return params != null ? Collections.singletonList(params) : Collections.emptyList();
   }

   @Nullable
   public EncryptionParameters resolveSingle(@Nonnull CriteriaSet criteria) throws ResolverException {
      Constraint.isNotNull(criteria, "CriteriaSet was null");
      Constraint.isNotNull(criteria.get(EncryptionConfigurationCriterion.class), "Resolver requires an instance of EncryptionConfigurationCriterion");
      Predicate whitelistBlacklistPredicate = this.getWhitelistBlacklistPredicate(criteria);
      EncryptionParameters params = new EncryptionParameters();
      this.resolveAndPopulateCredentialsAndAlgorithms(params, criteria, whitelistBlacklistPredicate);
      if (params.getDataEncryptionCredential() != null) {
         params.setDataKeyInfoGenerator(this.resolveDataKeyInfoGenerator(criteria, params.getDataEncryptionCredential()));
      }

      if (params.getKeyTransportEncryptionCredential() != null) {
         params.setKeyTransportKeyInfoGenerator(this.resolveKeyTransportKeyInfoGenerator(criteria, params.getKeyTransportEncryptionCredential()));
      }

      boolean encryptionOptional = false;
      EncryptionOptionalCriterion encryptionOptionalCrit = (EncryptionOptionalCriterion)criteria.get(EncryptionOptionalCriterion.class);
      if (encryptionOptionalCrit != null) {
         encryptionOptional = encryptionOptionalCrit.isEncryptionOptional();
      }

      if (this.validate(params, encryptionOptional)) {
         this.logResult(params);
         return params;
      } else {
         return null;
      }
   }

   protected void logResult(@Nonnull EncryptionParameters params) {
      if (this.log.isDebugEnabled()) {
         this.log.debug("Resolved EncryptionParameters:");
         Key keyTransportKey = CredentialSupport.extractEncryptionKey(params.getKeyTransportEncryptionCredential());
         if (keyTransportKey != null) {
            this.log.debug("\tKey transport credential with key algorithm: {}", keyTransportKey.getAlgorithm());
         } else {
            this.log.debug("\tKey transport credential: null");
         }

         this.log.debug("\tKey transport algorithm URI: {}", params.getKeyTransportEncryptionAlgorithm());
         if (params.getRSAOAEPParameters() != null) {
            this.log.debug("\t\tKey transport RSA OAEP digest method URI: {}", params.getRSAOAEPParameters().getDigestMethod());
            this.log.debug("\t\tKey transport RSA OAEP MGF URI: {}", params.getRSAOAEPParameters().getMaskGenerationFunction());
            this.log.debug("\t\tKey transport RSA OAEP OAEPparams: {}", params.getRSAOAEPParameters().getOAEPParams());
         }

         this.log.debug("\tKey transport KeyInfoGenerator: {}", params.getKeyTransportKeyInfoGenerator() != null ? "present" : "null");
         Key dataKey = CredentialSupport.extractEncryptionKey(params.getDataEncryptionCredential());
         if (dataKey != null) {
            this.log.debug("\tData encryption credential with key algorithm: {}", dataKey.getAlgorithm());
         } else {
            this.log.debug("\tData encryption credential: null");
         }

         this.log.debug("\tData encryption algorithm URI: {}", params.getDataEncryptionAlgorithm());
         this.log.debug("\tData encryption KeyInfoGenerator: {}", params.getDataKeyInfoGenerator() != null ? "present" : "null");
      }

   }

   /** @deprecated */
   protected boolean validate(@Nonnull EncryptionParameters params) {
      return this.validate(params, false);
   }

   protected boolean validate(@Nonnull EncryptionParameters params, boolean encryptionOptional) {
      String msg;
      if (params.getKeyTransportEncryptionCredential() == null && params.getDataEncryptionCredential() == null) {
         msg = "Validation failure: Failed to resolve both a data and a key encryption credential";
         if (encryptionOptional) {
            this.log.debug(msg);
         } else {
            this.log.warn(msg);
         }

         return false;
      } else if (params.getKeyTransportEncryptionCredential() != null && params.getKeyTransportEncryptionAlgorithm() == null) {
         msg = "Validation failure: Unable to resolve key encryption algorithm URI for credential";
         if (encryptionOptional) {
            this.log.debug(msg);
         } else {
            this.log.warn(msg);
         }

         return false;
      } else if (params.getDataEncryptionCredential() != null && params.getDataEncryptionAlgorithm() == null) {
         msg = "Validation failure: Unable to resolve data encryption algorithm URI for credential";
         if (encryptionOptional) {
            this.log.debug(msg);
         } else {
            this.log.warn(msg);
         }

         return false;
      } else if (params.getKeyTransportEncryptionCredential() != null && params.getDataEncryptionCredential() == null && params.getDataEncryptionAlgorithm() == null) {
         msg = "Validation failure: Unable to resolve a data encryption algorithm URI for auto-generation of data encryption key";
         if (encryptionOptional) {
            this.log.debug(msg);
         } else {
            this.log.warn(msg);
         }

         return false;
      } else {
         return true;
      }
   }

   @Nonnull
   protected Predicate getWhitelistBlacklistPredicate(@Nonnull CriteriaSet criteria) {
      return this.resolveWhitelistBlacklistPredicate(criteria, ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations());
   }

   protected void resolveAndPopulateCredentialsAndAlgorithms(@Nonnull EncryptionParameters params, @Nonnull CriteriaSet criteria, @Nonnull Predicate whitelistBlacklistPredicate) {
      List keyTransportCredentials = this.getEffectiveKeyTransportCredentials(criteria);
      List keyTransportAlgorithms = this.getEffectiveKeyTransportAlgorithms(criteria, whitelistBlacklistPredicate);
      this.log.trace("Resolved effective key transport algorithms: {}", keyTransportAlgorithms);
      List dataEncryptionCredentials = this.getEffectiveDataEncryptionCredentials(criteria);
      List dataEncryptionAlgorithms = this.getEffectiveDataEncryptionAlgorithms(criteria, whitelistBlacklistPredicate);
      this.log.trace("Resolved effective data encryption algorithms: {}", dataEncryptionAlgorithms);
      if (dataEncryptionCredentials.isEmpty()) {
         params.setDataEncryptionAlgorithm(this.resolveDataEncryptionAlgorithm((Credential)null, dataEncryptionAlgorithms));
      } else {
         Iterator var8 = dataEncryptionCredentials.iterator();

         while(var8.hasNext()) {
            Credential dataEncryptionCredential = (Credential)var8.next();
            String dataEncryptionAlgorithm = this.resolveDataEncryptionAlgorithm(dataEncryptionCredential, dataEncryptionAlgorithms);
            if (dataEncryptionAlgorithm != null) {
               params.setDataEncryptionCredential(dataEncryptionCredential);
               params.setDataEncryptionAlgorithm(dataEncryptionAlgorithm);
               break;
            }

            this.log.debug("Unable to resolve data encryption algorithm for credential with key type '{}', considering other credentials", CredentialSupport.extractEncryptionKey(dataEncryptionCredential).getAlgorithm());
         }
      }

      KeyTransportAlgorithmPredicate keyTransportPredicate = this.resolveKeyTransportAlgorithmPredicate(criteria);
      Iterator var14 = keyTransportCredentials.iterator();

      while(var14.hasNext()) {
         Credential keyTransportCredential = (Credential)var14.next();
         String keyTransportAlgorithm = this.resolveKeyTransportAlgorithm(keyTransportCredential, keyTransportAlgorithms, params.getDataEncryptionAlgorithm(), keyTransportPredicate);
         if (keyTransportAlgorithm != null) {
            params.setKeyTransportEncryptionCredential(keyTransportCredential);
            params.setKeyTransportEncryptionAlgorithm(keyTransportAlgorithm);
            break;
         }

         this.log.debug("Unable to resolve key transport algorithm for credential with key type '{}', considering other credentials", CredentialSupport.extractEncryptionKey(keyTransportCredential).getAlgorithm());
      }

      this.resolveAndPopulateRSAOAEPParams(params, criteria, whitelistBlacklistPredicate);
      this.processDataEncryptionCredentialAutoGeneration(params);
   }

   protected void resolveAndPopulateRSAOAEPParams(@Nonnull EncryptionParameters params, @Nonnull CriteriaSet criteria, @Nonnull Predicate whitelistBlacklistPredicate) {
      if (AlgorithmSupport.isRSAOAEP(params.getKeyTransportEncryptionAlgorithm())) {
         if (params.getRSAOAEPParameters() == null) {
            params.setRSAOAEPParameters(new RSAOAEPParameters());
         }

         this.populateRSAOAEPParams(params.getRSAOAEPParameters(), criteria, whitelistBlacklistPredicate);
      }
   }

   protected void populateRSAOAEPParams(@Nonnull RSAOAEPParameters rsaParams, @Nonnull CriteriaSet criteria, @Nonnull Predicate whitelistBlacklistPredicate) {
      if (!rsaParams.isComplete()) {
         Predicate algoSupportPredicate = this.getAlgorithmRuntimeSupportedPredicate();
         Iterator var5 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

         EncryptionConfiguration config;
         do {
            if (!var5.hasNext()) {
               return;
            }

            config = (EncryptionConfiguration)var5.next();
            RSAOAEPParameters rsaConfig = config.getRSAOAEPParameters();
            if (rsaConfig != null) {
               if (rsaParams.getDigestMethod() == null && rsaConfig.getDigestMethod() != null && whitelistBlacklistPredicate.apply(rsaConfig.getDigestMethod()) && algoSupportPredicate.apply(rsaConfig.getDigestMethod())) {
                  rsaParams.setDigestMethod(rsaConfig.getDigestMethod());
               }

               if (rsaParams.getMaskGenerationFunction() == null && rsaConfig.getMaskGenerationFunction() != null && whitelistBlacklistPredicate.apply(rsaConfig.getMaskGenerationFunction())) {
                  rsaParams.setMaskGenerationFunction(rsaConfig.getMaskGenerationFunction());
               }

               if (rsaParams.getOAEPParams() == null && rsaConfig.getOAEPParams() != null) {
                  rsaParams.setOAEPparams(rsaConfig.getOAEPParams());
               }
            }
         } while(!rsaParams.isComplete() && config.isRSAOAEPParametersMerge());

      }
   }

   @Nullable
   protected KeyTransportAlgorithmPredicate resolveKeyTransportAlgorithmPredicate(@Nonnull CriteriaSet criteria) {
      Iterator var2 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

      EncryptionConfiguration config;
      do {
         if (!var2.hasNext()) {
            return null;
         }

         config = (EncryptionConfiguration)var2.next();
      } while(config.getKeyTransportAlgorithmPredicate() == null);

      return config.getKeyTransportAlgorithmPredicate();
   }

   @Nullable
   protected String resolveKeyTransportAlgorithm(@Nonnull Credential keyTransportCredential, @Nonnull List keyTransportAlgorithms, @Nullable String dataEncryptionAlgorithm, @Nullable KeyTransportAlgorithmPredicate keyTransportPredicate) {
      if (this.log.isTraceEnabled()) {
         Key key = CredentialSupport.extractEncryptionKey(keyTransportCredential);
         this.log.trace("Evaluating key transport encryption credential of type: {}", key != null ? key.getAlgorithm() : "n/a");
      }

      Iterator var7 = keyTransportAlgorithms.iterator();

      while(var7.hasNext()) {
         String algorithm = (String)var7.next();
         this.log.trace("Evaluating key transport credential against algorithm: {}", algorithm);
         if (this.credentialSupportsAlgorithm(keyTransportCredential, algorithm) && this.isKeyTransportAlgorithm(algorithm)) {
            if (keyTransportPredicate == null) {
               return algorithm;
            }

            if (keyTransportPredicate.apply(new KeyTransportAlgorithmPredicate.SelectionInput(algorithm, dataEncryptionAlgorithm, keyTransportCredential))) {
               return algorithm;
            }
         }
      }

      return null;
   }

   @Nullable
   protected String resolveKeyTransportAlgorithm(@Nonnull Credential keyTransportCredential, @Nonnull CriteriaSet criteria, @Nonnull Predicate whitelistBlacklistPredicate, @Nullable String dataEncryptionAlgorithm) {
      return this.resolveKeyTransportAlgorithm(keyTransportCredential, this.getEffectiveKeyTransportAlgorithms(criteria, whitelistBlacklistPredicate), dataEncryptionAlgorithm, this.resolveKeyTransportAlgorithmPredicate(criteria));
   }

   @Nullable
   protected String resolveDataEncryptionAlgorithm(@Nullable Credential dataEncryptionCredential, @Nonnull List dataEncryptionAlgorithms) {
      if (this.log.isTraceEnabled()) {
         Key key = CredentialSupport.extractEncryptionKey(dataEncryptionCredential);
         this.log.trace("Evaluating data encryption credential of type: {}", key != null ? key.getAlgorithm() : "n/a");
      }

      if (dataEncryptionCredential == null) {
         this.log.trace("Data encryption credential was null, selecting algorithm based on effective algorithms alone");
         return !dataEncryptionAlgorithms.isEmpty() ? (String)dataEncryptionAlgorithms.get(0) : null;
      } else {
         Iterator var5 = dataEncryptionAlgorithms.iterator();

         String algorithm;
         do {
            if (!var5.hasNext()) {
               return null;
            }

            algorithm = (String)var5.next();
            this.log.trace("Evaluating data encryption credential against algorithm: {}", algorithm);
         } while(!this.credentialSupportsAlgorithm(dataEncryptionCredential, algorithm) || !this.isDataEncryptionAlgorithm(algorithm));

         return algorithm;
      }
   }

   @Nullable
   protected String resolveDataEncryptionAlgorithm(@Nonnull Credential dataEncryptionCredential, @Nonnull CriteriaSet criteria, @Nonnull Predicate whitelistBlacklistPredicate) {
      return this.resolveDataEncryptionAlgorithm(dataEncryptionCredential, this.getEffectiveDataEncryptionAlgorithms(criteria, whitelistBlacklistPredicate));
   }

   @Nonnull
   protected List getEffectiveDataEncryptionCredentials(@Nonnull CriteriaSet criteria) {
      ArrayList accumulator = new ArrayList();
      Iterator var3 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

      while(var3.hasNext()) {
         EncryptionConfiguration config = (EncryptionConfiguration)var3.next();
         accumulator.addAll(config.getDataEncryptionCredentials());
      }

      return accumulator;
   }

   @Nonnull
   protected List getEffectiveDataEncryptionAlgorithms(@Nonnull CriteriaSet criteria, @Nonnull Predicate whitelistBlacklistPredicate) {
      ArrayList accumulator = new ArrayList();
      Iterator var4 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

      while(var4.hasNext()) {
         EncryptionConfiguration config = (EncryptionConfiguration)var4.next();
         accumulator.addAll(Collections2.filter(config.getDataEncryptionAlgorithms(), Predicates.and(this.getAlgorithmRuntimeSupportedPredicate(), whitelistBlacklistPredicate)));
      }

      return accumulator;
   }

   @Nonnull
   protected List getEffectiveKeyTransportCredentials(@Nonnull CriteriaSet criteria) {
      ArrayList accumulator = new ArrayList();
      Iterator var3 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

      while(var3.hasNext()) {
         EncryptionConfiguration config = (EncryptionConfiguration)var3.next();
         accumulator.addAll(config.getKeyTransportEncryptionCredentials());
      }

      return accumulator;
   }

   @Nonnull
   protected List getEffectiveKeyTransportAlgorithms(@Nonnull CriteriaSet criteria, @Nonnull Predicate whitelistBlacklistPredicate) {
      ArrayList accumulator = new ArrayList();
      Iterator var4 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

      while(var4.hasNext()) {
         EncryptionConfiguration config = (EncryptionConfiguration)var4.next();
         accumulator.addAll(Collections2.filter(config.getKeyTransportEncryptionAlgorithms(), Predicates.and(this.getAlgorithmRuntimeSupportedPredicate(), whitelistBlacklistPredicate)));
      }

      return accumulator;
   }

   @Nullable
   protected KeyInfoGenerator resolveDataKeyInfoGenerator(@Nullable CriteriaSet criteria, @Nullable Credential dataEncryptionCredential) {
      if (dataEncryptionCredential == null) {
         return null;
      } else {
         String name = null;
         if (criteria.get(KeyInfoGenerationProfileCriterion.class) != null) {
            name = ((KeyInfoGenerationProfileCriterion)criteria.get(KeyInfoGenerationProfileCriterion.class)).getName();
         }

         Iterator var4 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

         KeyInfoGenerator kig;
         do {
            if (!var4.hasNext()) {
               return null;
            }

            EncryptionConfiguration config = (EncryptionConfiguration)var4.next();
            kig = this.lookupKeyInfoGenerator(dataEncryptionCredential, config.getDataKeyInfoGeneratorManager(), name);
         } while(kig == null);

         return kig;
      }
   }

   @Nullable
   protected KeyInfoGenerator resolveKeyTransportKeyInfoGenerator(@Nonnull CriteriaSet criteria, @Nullable Credential keyTransportEncryptionCredential) {
      if (keyTransportEncryptionCredential == null) {
         return null;
      } else {
         String name = null;
         if (criteria.get(KeyInfoGenerationProfileCriterion.class) != null) {
            name = ((KeyInfoGenerationProfileCriterion)criteria.get(KeyInfoGenerationProfileCriterion.class)).getName();
         }

         Iterator var4 = ((EncryptionConfigurationCriterion)criteria.get(EncryptionConfigurationCriterion.class)).getConfigurations().iterator();

         KeyInfoGenerator kig;
         do {
            if (!var4.hasNext()) {
               return null;
            }

            EncryptionConfiguration config = (EncryptionConfiguration)var4.next();
            kig = this.lookupKeyInfoGenerator(keyTransportEncryptionCredential, config.getKeyTransportKeyInfoGeneratorManager(), name);
         } while(kig == null);

         return kig;
      }
   }

   @Nonnull
   protected Predicate getAlgorithmRuntimeSupportedPredicate() {
      return new AlgorithmRuntimeSupportedPredicate(this.getAlgorithmRegistry());
   }

   protected boolean credentialSupportsAlgorithm(@Nonnull Credential credential, @Nonnull @NotEmpty String algorithm) {
      return AlgorithmSupport.credentialSupportsAlgorithmForEncryption(credential, this.getAlgorithmRegistry().get(algorithm));
   }

   protected boolean isKeyTransportAlgorithm(@Nonnull String algorithm) {
      return AlgorithmSupport.isKeyEncryptionAlgorithm(this.getAlgorithmRegistry().get(algorithm));
   }

   protected boolean isDataEncryptionAlgorithm(String algorithm) {
      return AlgorithmSupport.isDataEncryptionAlgorithm(this.getAlgorithmRegistry().get(algorithm));
   }

   @Nullable
   protected Credential generateDataEncryptionCredential(@Nonnull String dataEncryptionAlgorithm) {
      try {
         return AlgorithmSupport.generateSymmetricKeyAndCredential(dataEncryptionAlgorithm);
      } catch (KeyException | NoSuchAlgorithmException var3) {
         this.log.warn("Error generating a symmetric key credential using algorithm URI: " + dataEncryptionAlgorithm, var3);
         return null;
      }
   }

   protected void processDataEncryptionCredentialAutoGeneration(@Nonnull EncryptionParameters params) {
      if (this.isAutoGenerateDataEncryptionCredential() && params.getKeyTransportEncryptionCredential() != null && params.getDataEncryptionCredential() == null && params.getDataEncryptionAlgorithm() != null) {
         this.log.debug("Auto-generating data encryption credential using algorithm URI: {}", params.getDataEncryptionAlgorithm());
         params.setDataEncryptionCredential(this.generateDataEncryptionCredential(params.getDataEncryptionAlgorithm()));
      }

   }
}
