package weblogic.management.configuration;

import java.beans.BeanDescriptor;
import java.beans.IntrospectionException;
import java.beans.MethodDescriptor;
import java.beans.ParameterDescriptor;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.util.Map;
import weblogic.management.internal.mbean.BeanInfoHelper;

public class WLDFServerDiagnosticMBeanImplBeanInfo extends ConfigurationMBeanImplBeanInfo {
   public static final Class INTERFACE_CLASS = WLDFServerDiagnosticMBean.class;

   public WLDFServerDiagnosticMBeanImplBeanInfo(boolean readOnly, String targetVersion) throws IntrospectionException {
      super(readOnly, targetVersion);
   }

   public WLDFServerDiagnosticMBeanImplBeanInfo() throws IntrospectionException {
   }

   protected BeanDescriptor buildBeanDescriptor() {
      Class beanClass = null;

      try {
         beanClass = Class.forName("weblogic.management.configuration.WLDFServerDiagnosticMBeanImpl");
      } catch (Throwable var4) {
         beanClass = INTERFACE_CLASS;
      }

      BeanDescriptor beanDescriptor = new BeanDescriptor(beanClass, (Class)null);
      beanDescriptor.setValue("since", "9.0.0.0");
      beanDescriptor.setValue("package", "weblogic.management.configuration");
      String description = (new String("<p>Use this interface to configure the WebLogic Diagnostic Framework (WLDF) components that are defined for each WebLogic Server instance.</p> ")).intern();
      beanDescriptor.setShortDescription(description);
      beanDescriptor.setValue("description", description);
      beanDescriptor.setValue("interfaceclassname", "weblogic.management.configuration.WLDFServerDiagnosticMBean");
      beanDescriptor.setValue("generatedByWLSInfoBinder", Boolean.TRUE);
      return beanDescriptor;
   }

   protected void buildPropertyDescriptors(Map descriptors) throws IntrospectionException {
      PropertyDescriptor currentResult = null;
      String getterName;
      String setterName;
      if (!descriptors.containsKey("DiagnosticDataArchiveType")) {
         getterName = "getDiagnosticDataArchiveType";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticDataArchiveType";
         }

         currentResult = new PropertyDescriptor("DiagnosticDataArchiveType", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticDataArchiveType", currentResult);
         currentResult.setValue("description", "<p>Determines whether the current server persists its harvested metrics and event data in a diagnostic store (file-based store) or a JDBC based archive. The default store is file-based. </p> ");
         setPropertyDescriptorDefault(currentResult, "FileStoreArchive");
         currentResult.setValue("legalValues", new Object[]{"FileStoreArchive", "JDBCArchive"});
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (BeanInfoHelper.isVersionCompliant("12.2.1.1.0", (String)null, this.targetVersion) && !descriptors.containsKey("DiagnosticDumpsDir")) {
         getterName = "getDiagnosticDumpsDir";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticDumpsDir";
         }

         currentResult = new PropertyDescriptor("DiagnosticDumpsDir", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticDumpsDir", currentResult);
         currentResult.setValue("description", "<p>Directory where heap and thread dumps will be generated by actions. This directory is a relative path with respect to the server directory</p> ");
         setPropertyDescriptorDefault(currentResult, WLDFServerDiagnosticMBean.DEFAULT_DUMP_DIR);
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "12.2.1.1.0");
      }

      String[] seeObjectArray;
      if (!descriptors.containsKey("DiagnosticJDBCResource")) {
         getterName = "getDiagnosticJDBCResource";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticJDBCResource";
         }

         currentResult = new PropertyDescriptor("DiagnosticJDBCResource", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticJDBCResource", currentResult);
         currentResult.setValue("description", "<p>The JDBC data source that the server uses to archive its harvested metrics and event data.</p> ");
         seeObjectArray = new String[]{BeanInfoHelper.encodeEntities("#getDiagnosticDataArchiveType")};
         currentResult.setValue("see", seeObjectArray);
         currentResult.setValue("relationship", "reference");
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticJDBCSchemaName")) {
         getterName = "getDiagnosticJDBCSchemaName";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticJDBCSchemaName";
         }

         currentResult = new PropertyDescriptor("DiagnosticJDBCSchemaName", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticJDBCSchemaName", currentResult);
         currentResult.setValue("description", "<p>The schema name to use for accessing JDBC-based archive tables.</p>  <p>If multiple WLDF JDBC archive schemas exist in the same database, this value specifies the correct schema to use for accessing JDBC-based archive tables in that database.</p>  <p>There is no default value. If a schema name is not specified, no schema name is applied when WLDF validates the run-time table or is used for the SQL statements.</p> ");
         seeObjectArray = new String[]{BeanInfoHelper.encodeEntities("#getDiagnosticDataArchiveType")};
         currentResult.setValue("see", seeObjectArray);
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticStoreBlockSize")) {
         getterName = "getDiagnosticStoreBlockSize";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticStoreBlockSize";
         }

         currentResult = new PropertyDescriptor("DiagnosticStoreBlockSize", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticStoreBlockSize", currentResult);
         currentResult.setValue("description", "<p>The smallest addressable block, in bytes, of a file. When a native <code>wlfileio</code> driver is available and the block size has not been configured by the user, the store selects the minimum OS specific value for unbuffered (direct) I/O, if it is within the range [512, 8192].</p> A file store's block size does not change once the file store creates its files. Changes to block size only take effect for new file stores or after the current files have been deleted. See \"Tuning the Persistent Store\" in <i>Performance and Tuning for Oracle WebLogic Server</i>. ");
         setPropertyDescriptorDefault(currentResult, new Integer(-1));
         currentResult.setValue("legalMax", new Integer(8192));
         currentResult.setValue("legalMin", new Integer(-1));
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticStoreDir")) {
         getterName = "getDiagnosticStoreDir";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticStoreDir";
         }

         currentResult = new PropertyDescriptor("DiagnosticStoreDir", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticStoreDir", currentResult);
         currentResult.setValue("description", "<p>The directory in which the current server maintains its diagnostic store.</p> ");
         seeObjectArray = new String[]{BeanInfoHelper.encodeEntities("#getDiagnosticDataArchiveType")};
         currentResult.setValue("see", seeObjectArray);
         setPropertyDescriptorDefault(currentResult, "data/store/diagnostics");
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticStoreIoBufferSize")) {
         getterName = "getDiagnosticStoreIoBufferSize";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticStoreIoBufferSize";
         }

         currentResult = new PropertyDescriptor("DiagnosticStoreIoBufferSize", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticStoreIoBufferSize", currentResult);
         currentResult.setValue("description", "<p>The I/O buffer size, in bytes, automatically rounded down to the nearest power of 2, controls the largest write size.</p>  <ul> <li>When a native <code>wlfileio</code> driver is available, the setting applies to off-heap (native) memory.</li> <li>When a native <code>wlfileio</code> driver is not available, the setting applies to JAVA heap memory.</li> <li>For the best runtime performance, Oracle recommends setting <code>DiagnosticStoreIOBufferSize</code> so that it is larger than the largest write (multiple concurrent store requests may be combined into a single write).</li>  <li>See <code>AllocatedIOBufferBytes</code> to find out the actual allocated off-heap (native) memory amount. It is a multiple of <code>IOBufferSize</code></li> </ul> ");
         setPropertyDescriptorDefault(currentResult, new Integer(-1));
         currentResult.setValue("legalMax", new Integer(67108864));
         currentResult.setValue("legalMin", new Integer(-1));
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticStoreMaxFileSize")) {
         getterName = "getDiagnosticStoreMaxFileSize";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticStoreMaxFileSize";
         }

         currentResult = new PropertyDescriptor("DiagnosticStoreMaxFileSize", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticStoreMaxFileSize", currentResult);
         currentResult.setValue("description", "<p>The maximum file size, in bytes.</p>  <ul> <li>The <code>DiagnosticStoreMaxFileSize</code> value affects the number of files needed to accommodate a diagnostic store of a particular size (number of files = diagnostic store size/MaxFileSize rounded up).</li>  <li>A diagnostic store automatically reuses space freed by deleted records and automatically expands individual files up to <code>DiagnosticStoreMaxFileSize</code> if there is not enough space for a new record. If there is no space left in exiting files for a new record, a diagnostic store creates an additional file.</li>  <li> A small number of larger files is normally preferred over a large number of smaller files as each file allocates Window Buffer and file handles.</li>  <li> If <code>DiagnosticStoreMaxFileSize</code> is larger than 2^24 * <code>DiagnosticStoreBlockSize</code>, then <code>DiagnosticStoreMaxFileSize</code> is ignored, and the value becomes 2^24 * <code>DiagnosticStoreBlockSize</code>. The default <code>DiagnosticStoreBlockSize</code> is 512, and 2^24 * 512 is 8 GB. </li> </ul>  <p>Oracle recommends not setting the Diagnostic Store Max File Size above the default value of 1,342,177,280.</p> ");
         setPropertyDescriptorDefault(currentResult, new Long(1342177280L));
         currentResult.setValue("legalMin", new Long(10485760L));
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticStoreMaxWindowBufferSize")) {
         getterName = "getDiagnosticStoreMaxWindowBufferSize";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticStoreMaxWindowBufferSize";
         }

         currentResult = new PropertyDescriptor("DiagnosticStoreMaxWindowBufferSize", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticStoreMaxWindowBufferSize", currentResult);
         currentResult.setValue("description", "<p>The maximum amount of data, in bytes and rounded down to the nearest power of 2, mapped into the JVM's address space per diagnostic store file. Applies only when a native <code>wlfileio</code> library is loaded.</p>  <p>A window buffer does not consume Java heap memory, but does consume off-heap (native) memory. If the store is unable to allocate the requested buffer size, it allocates smaller and smaller buffers until it reaches <code>DiagnosticStoreMinWindowBufferSize</code>, and then fails if it cannot honor <code>DiagnosticStoreMinWindowBufferSize</code>.</p>  <p>Oracle recommends setting the max window buffer size to more than double the size of the largest write (multiple concurrently updated records may be combined into a single write), and greater than or equal to the file size, unless there are other constraints. 32-bit JVMs may impose a total limit of between 2 and 4GB for combined Java heap plus off-heap (native) memory usage.</p> ");
         setPropertyDescriptorDefault(currentResult, new Integer(4194304));
         currentResult.setValue("legalMax", new Integer(1073741824));
         currentResult.setValue("legalMin", new Integer(-1));
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticStoreMinWindowBufferSize")) {
         getterName = "getDiagnosticStoreMinWindowBufferSize";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticStoreMinWindowBufferSize";
         }

         currentResult = new PropertyDescriptor("DiagnosticStoreMinWindowBufferSize", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticStoreMinWindowBufferSize", currentResult);
         currentResult.setValue("description", "<p>The minimum amount of data, in bytes and rounded down to the nearest power of 2, mapped into the JVM's address space per diagnostic store file. Applies only when a native <code>wlfileio</code> library is loaded. See <a href='#getDiagnosticStoreMinWindowBufferSize'>Diagnostic Store Maximum Window Buffer Size</a>.</p> ");
         setPropertyDescriptorDefault(currentResult, new Integer(-1));
         currentResult.setValue("legalMax", new Integer(1073741824));
         currentResult.setValue("legalMin", new Integer(-1));
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("EventPersistenceInterval")) {
         getterName = "getEventPersistenceInterval";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setEventPersistenceInterval";
         }

         currentResult = new PropertyDescriptor("EventPersistenceInterval", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("EventPersistenceInterval", currentResult);
         currentResult.setValue("description", "<p>The interval, in milliseconds, at which queued up instrumentation events will be periodically dispatched to the archive.</p> ");
         setPropertyDescriptorDefault(currentResult, new Long(5000L));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("EventsImageCaptureInterval")) {
         getterName = "getEventsImageCaptureInterval";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setEventsImageCaptureInterval";
         }

         currentResult = new PropertyDescriptor("EventsImageCaptureInterval", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("EventsImageCaptureInterval", currentResult);
         currentResult.setValue("description", "<p>The time span, in milliseconds, for which recently archived events will be captured in the diagnostic image. All events archived on or after ( <code>System.currentTimeMillis() - interval</code> ) will be captured.</p> ");
         setPropertyDescriptorDefault(currentResult, new Long(60000L));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("ImageDir")) {
         getterName = "getImageDir";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setImageDir";
         }

         currentResult = new PropertyDescriptor("ImageDir", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("ImageDir", currentResult);
         currentResult.setValue("description", "<p>The default directory where the server stores captured diagnostic images.</p>  <p>If you specify a relative pathname, the root of that path is the server's root directory.</p>  <p>If the directory does not exist, it will be created when the WebLogic Diagnostic Framework is initialized on the server. Note that each image capture request can override this default directory location.</p> ");
         seeObjectArray = new String[]{BeanInfoHelper.encodeEntities("weblogic.management.runtime.WLDFImageRuntimeMBean")};
         currentResult.setValue("see", seeObjectArray);
         currentResult.setValue("restDerivedDefault", Boolean.TRUE);
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("ImageTimeout")) {
         getterName = "getImageTimeout";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setImageTimeout";
         }

         currentResult = new PropertyDescriptor("ImageTimeout", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("ImageTimeout", currentResult);
         currentResult.setValue("description", "<p>The default timeout period, in minutes, that the server uses to delay future diagnostic image-capture requests.</p> ");
         setPropertyDescriptorDefault(currentResult, new Integer(1));
         currentResult.setValue("legalMax", new Integer(1440));
         currentResult.setValue("legalMin", new Integer(0));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
      }

      if (BeanInfoHelper.isVersionCompliant("12.2.1.1.0", (String)null, this.targetVersion) && !descriptors.containsKey("MaxHeapDumpCount")) {
         getterName = "getMaxHeapDumpCount";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setMaxHeapDumpCount";
         }

         currentResult = new PropertyDescriptor("MaxHeapDumpCount", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("MaxHeapDumpCount", currentResult);
         currentResult.setValue("description", "<p>Returns the maximum number of heap dump files to be retained which are generated by heap dump actions. If this limit is reached, oldest heap dumps will be deleted while creating new heap dump so that this limit is not exceeded.</p> ");
         setPropertyDescriptorDefault(currentResult, new Integer(8));
         currentResult.setValue("legalMax", new Integer(50));
         currentResult.setValue("legalMin", new Integer(1));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "12.2.1.1.0");
      }

      if (BeanInfoHelper.isVersionCompliant("12.2.1.1.0", (String)null, this.targetVersion) && !descriptors.containsKey("MaxThreadDumpCount")) {
         getterName = "getMaxThreadDumpCount";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setMaxThreadDumpCount";
         }

         currentResult = new PropertyDescriptor("MaxThreadDumpCount", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("MaxThreadDumpCount", currentResult);
         currentResult.setValue("description", "<p>Returns the maximum number of thread dump files to be retained which are generated by thread dump actions. If this limit is reached, oldest thread dump files will be deleted while creating new thread dump file so that this limit is not exceeded.</p> ");
         setPropertyDescriptorDefault(currentResult, new Integer(100));
         currentResult.setValue("legalMax", new Integer(1000));
         currentResult.setValue("legalMin", new Integer(1));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "12.2.1.1.0");
      }

      if (!descriptors.containsKey("Name")) {
         getterName = "getName";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setName";
         }

         currentResult = new PropertyDescriptor("Name", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("Name", currentResult);
         currentResult.setValue("description", "<p>The user-specified name of this MBean instance.</p>  <p>This name is included as one of the key properties in the MBean's <code>javax.management.ObjectName</code>:</p>  <p><code>Name=<i>user-specified-name</i></code></p> ");
         currentResult.setValue("restDerivedDefault", Boolean.TRUE);
         currentResult.setValue("legalNull", Boolean.TRUE);
         currentResult.setValue("key", Boolean.TRUE);
      }

      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion) && !descriptors.containsKey("PreferredStoreSizeLimit")) {
         getterName = "getPreferredStoreSizeLimit";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setPreferredStoreSizeLimit";
         }

         currentResult = new PropertyDescriptor("PreferredStoreSizeLimit", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("PreferredStoreSizeLimit", currentResult);
         currentResult.setValue("description", "<p>Return the preferred limit on the size of diagnostic store file in MB.</p> ");
         setPropertyDescriptorDefault(currentResult, new Integer(100));
         currentResult.setValue("legalMin", new Integer(10));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "10.0.0.0");
      }

      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion) && !descriptors.containsKey("StoreSizeCheckPeriod")) {
         getterName = "getStoreSizeCheckPeriod";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setStoreSizeCheckPeriod";
         }

         currentResult = new PropertyDescriptor("StoreSizeCheckPeriod", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("StoreSizeCheckPeriod", currentResult);
         currentResult.setValue("description", "<p>Return the period in hours at which diagnostic store file size check will be performed</p> ");
         setPropertyDescriptorDefault(currentResult, new Integer(1));
         currentResult.setValue("legalMin", new Integer(1));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "10.0.0.0");
      }

      if (BeanInfoHelper.isVersionCompliant("12.2.1.0.0", (String)null, this.targetVersion) && !descriptors.containsKey("Tags")) {
         getterName = "getTags";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setTags";
         }

         currentResult = new PropertyDescriptor("Tags", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("Tags", currentResult);
         currentResult.setValue("description", "<p>Return all tags on this Configuration MBean</p> ");
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("since", "12.2.1.0.0");
      }

      if (!descriptors.containsKey("WLDFBuiltinSystemResourceDescriptorBean")) {
         getterName = "getWLDFBuiltinSystemResourceDescriptorBean";
         setterName = null;
         currentResult = new PropertyDescriptor("WLDFBuiltinSystemResourceDescriptorBean", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("WLDFBuiltinSystemResourceDescriptorBean", currentResult);
         currentResult.setValue("description", " ");
         currentResult.setValue("relationship", "containment");
         currentResult.setValue("transient", Boolean.TRUE);
         currentResult.setValue("owner", "");
      }

      if (BeanInfoHelper.isVersionCompliant("12.1.2.0.0", (String)null, this.targetVersion) && !descriptors.containsKey("WLDFBuiltinSystemResourceType")) {
         getterName = "getWLDFBuiltinSystemResourceType";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setWLDFBuiltinSystemResourceType";
         }

         currentResult = new PropertyDescriptor("WLDFBuiltinSystemResourceType", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("WLDFBuiltinSystemResourceType", currentResult);
         currentResult.setValue("description", "<p>This attribute specifies the WLDF built-in system resource type in use for this server.</p>  <p>This attribute has the following settings:</p> <ul> <li><code>None</code> No WLDF built-in system resource in use.</li> <li><code>Low</code> The Low WLDF built-in system resource. This is the default.</li> <li><code>Medium</code> The Medium built-in system resource.</li> <li><code>High</code> The High built-in system resource.</li> </ul> ");
         currentResult.setValue("restProductionModeDefault", "Low");
         setPropertyDescriptorDefault(currentResult, "None");
         currentResult.setValue("legalValues", new Object[]{"None", "Low", "Medium", "High"});
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "12.1.2.0.0");
      }

      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion) && !descriptors.containsKey("WLDFDataRetirementByAges")) {
         getterName = "getWLDFDataRetirementByAges";
         setterName = null;
         currentResult = new PropertyDescriptor("WLDFDataRetirementByAges", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("WLDFDataRetirementByAges", currentResult);
         currentResult.setValue("description", "<p>Return the WLDFDataRetirementByAgeMBeans parented by this WLDFServerDiagnosticMBean.</p> ");
         currentResult.setValue("relationship", "containment");
         currentResult.setValue("destroyer", "destroyWLDFDataRetirementByAge");
         currentResult.setValue("creator", "createWLDFDataRetirementByAge");
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "10.0.0.0");
      }

      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion) && !descriptors.containsKey("WLDFDataRetirements")) {
         getterName = "getWLDFDataRetirements";
         setterName = null;
         currentResult = new PropertyDescriptor("WLDFDataRetirements", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("WLDFDataRetirements", currentResult);
         currentResult.setValue("description", "<p>Return the WLDFDataRetirementMBeans parented by this WLDFServerDiagnosticMBean.</p> ");
         currentResult.setValue("relationship", "reference");
         currentResult.setValue("transient", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "10.0.0.0");
      }

      if (BeanInfoHelper.isVersionCompliant("10.3.3", (String)null, this.targetVersion) && !descriptors.containsKey("WLDFDiagnosticVolume")) {
         getterName = "getWLDFDiagnosticVolume";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setWLDFDiagnosticVolume";
         }

         currentResult = new PropertyDescriptor("WLDFDiagnosticVolume", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("WLDFDiagnosticVolume", currentResult);
         currentResult.setValue("description", "<p>Specifies the volume of diagnostic data that is automatically produced by WebLogic Server at run time. Note that the WLDF diagnostic volume setting does not affect explicitly configured diagnostic modules. For example, this controls the volume of events generated for Flight Recorder.</p>  <p>This attribute has the following settings:</p> <ul> <li><code>Off</code> No diagnostic data is produced.</li> <li><code>Low</code> Minimal amounts of automatic diagnostic data are produced. This is the default.</li> <li><code>Medium</code> Additional diagnostic data is automatically generated beyond the amount generated for <code>Low</code>.</li> <li><code>High</code> Additional diagnostic data is automatically generated beyond the amount generated for <code>Medium</code>.</li> </ul> ");
         setPropertyDescriptorDefault(currentResult, "Low");
         currentResult.setValue("legalValues", new Object[]{"Off", "Low", "Medium", "High"});
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "10.3.3");
      }

      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion) && !descriptors.containsKey("DataRetirementEnabled")) {
         getterName = "isDataRetirementEnabled";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDataRetirementEnabled";
         }

         currentResult = new PropertyDescriptor("DataRetirementEnabled", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DataRetirementEnabled", currentResult);
         currentResult.setValue("description", "<p>This attribute controls if configuration based data retirement functionality is enabled on the server. If disabled, all retirement policies will be disabled.</p> ");
         setPropertyDescriptorDefault(currentResult, new Boolean(true));
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
         currentResult.setValue("since", "10.0.0.0");
      }

      if (!descriptors.containsKey("DiagnosticContextEnabled")) {
         getterName = "isDiagnosticContextEnabled";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticContextEnabled";
         }

         currentResult = new PropertyDescriptor("DiagnosticContextEnabled", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticContextEnabled", currentResult);
         currentResult.setValue("description", "<p>If true, diagnostic context creation is enabled. If false, the diagnostic context will not be created when requested. However, if the diagnostics context already exists because it was propagated from another VM or was created through the DyeInjection monitor, the context will be made available.</p> ");
         setPropertyDescriptorDefault(currentResult, new Boolean(true));
         currentResult.setValue("deprecated", "12.2.1.0.0 Defaults to enabled now ");
         currentResult.setValue("dynamic", Boolean.TRUE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DiagnosticStoreFileLockingEnabled")) {
         getterName = "isDiagnosticStoreFileLockingEnabled";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setDiagnosticStoreFileLockingEnabled";
         }

         currentResult = new PropertyDescriptor("DiagnosticStoreFileLockingEnabled", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DiagnosticStoreFileLockingEnabled", currentResult);
         currentResult.setValue("description", "<p>Determines whether OS file locking is used. </p> When file locking protection is enabled, a store boot fails if another store instance already has opened the store files. Do not disable this setting unless you have procedures in place to prevent multiple store instances from opening the same file. File locking is not required but helps prevent corruption in the event that two same-named file store instances attempt to operate in the same directories. This setting applies to both primary and cache files. ");
         setPropertyDescriptorDefault(currentResult, new Boolean(false));
         currentResult.setValue("dynamic", Boolean.FALSE);
         currentResult.setValue("owner", "");
      }

      if (!descriptors.containsKey("DynamicallyCreated")) {
         getterName = "isDynamicallyCreated";
         setterName = null;
         currentResult = new PropertyDescriptor("DynamicallyCreated", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("DynamicallyCreated", currentResult);
         currentResult.setValue("description", "<p>Return whether the MBean was created dynamically or is persisted to config.xml</p> ");
         setPropertyDescriptorDefault(currentResult, new Boolean(false));
         currentResult.setValue("transient", Boolean.TRUE);
      }

      if (!descriptors.containsKey("SynchronousEventPersistenceEnabled")) {
         getterName = "isSynchronousEventPersistenceEnabled";
         setterName = null;
         if (!this.readOnly) {
            setterName = "setSynchronousEventPersistenceEnabled";
         }

         currentResult = new PropertyDescriptor("SynchronousEventPersistenceEnabled", WLDFServerDiagnosticMBean.class, getterName, setterName);
         descriptors.put("SynchronousEventPersistenceEnabled", currentResult);
         currentResult.setValue("description", "<p>Specifies the instrumentation events persistence policy. If true, events will be persisted synchronously within the same thread. If false, events will be queued up to be persisted in a separate thread.</p> ");
         setPropertyDescriptorDefault(currentResult, new Boolean(false));
         currentResult.setValue("owner", "");
      }

      super.buildPropertyDescriptors(descriptors);
   }

   private void fillinFactoryMethodInfos(Map descriptors) throws IntrospectionException, NoSuchMethodException {
      MethodDescriptor currentResult;
      Method mth;
      ParameterDescriptor[] parameterDescriptors;
      String methodKey;
      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion)) {
         mth = WLDFServerDiagnosticMBean.class.getMethod("createWLDFDataRetirementByAge", String.class);
         parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("name", (String)null)};
         methodKey = BeanInfoHelper.buildMethodKey(mth);
         if (!descriptors.containsKey(methodKey)) {
            currentResult = new MethodDescriptor(mth, parameterDescriptors);
            currentResult.setValue("since", "10.0.0.0");
            descriptors.put(methodKey, currentResult);
            currentResult.setValue("description", "<p>Factory to create WLDFDataRetirement instance corresponding to a WLDF archive</p> ");
            currentResult.setValue("role", "factory");
            currentResult.setValue("property", "WLDFDataRetirementByAges");
            currentResult.setValue("since", "10.0.0.0");
         }
      }

      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion)) {
         mth = WLDFServerDiagnosticMBean.class.getMethod("destroyWLDFDataRetirementByAge", WLDFDataRetirementByAgeMBean.class);
         parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("wldfDataRetirement", (String)null)};
         methodKey = BeanInfoHelper.buildMethodKey(mth);
         if (!descriptors.containsKey(methodKey)) {
            currentResult = new MethodDescriptor(mth, parameterDescriptors);
            currentResult.setValue("since", "10.0.0.0");
            descriptors.put(methodKey, currentResult);
            currentResult.setValue("description", "<p>Deletes WLDFDataRetirementByAgeMBean object</p> ");
            currentResult.setValue("role", "factory");
            currentResult.setValue("property", "WLDFDataRetirementByAges");
            currentResult.setValue("since", "10.0.0.0");
         }
      }

   }

   private void fillinCollectionMethodInfos(Map descriptors) throws IntrospectionException, NoSuchMethodException {
      MethodDescriptor currentResult;
      Method mth;
      ParameterDescriptor[] parameterDescriptors;
      String methodKey;
      String[] throwsObjectArray;
      if (BeanInfoHelper.isVersionCompliant("12.2.1.0.0", (String)null, this.targetVersion)) {
         mth = WLDFServerDiagnosticMBean.class.getMethod("addTag", String.class);
         parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("tag", "tag to be added to the MBean ")};
         methodKey = BeanInfoHelper.buildMethodKey(mth);
         if (!descriptors.containsKey(methodKey)) {
            currentResult = new MethodDescriptor(mth, parameterDescriptors);
            throwsObjectArray = new String[]{BeanInfoHelper.encodeEntities("IllegalArgumentException if the tag contains illegal punctuation")};
            currentResult.setValue("throws", throwsObjectArray);
            currentResult.setValue("since", "12.2.1.0.0");
            descriptors.put(methodKey, currentResult);
            currentResult.setValue("description", "<p>Add a tag to this Configuration MBean.  Adds a tag to the current set of tags on the Configuration MBean.  Tags may contain white spaces.</p> ");
            currentResult.setValue("role", "collection");
            currentResult.setValue("property", "Tags");
            currentResult.setValue("since", "12.2.1.0.0");
         }
      }

      if (BeanInfoHelper.isVersionCompliant("12.2.1.0.0", (String)null, this.targetVersion)) {
         mth = WLDFServerDiagnosticMBean.class.getMethod("removeTag", String.class);
         parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("tag", "tag to be removed from the MBean ")};
         methodKey = BeanInfoHelper.buildMethodKey(mth);
         if (!descriptors.containsKey(methodKey)) {
            currentResult = new MethodDescriptor(mth, parameterDescriptors);
            throwsObjectArray = new String[]{BeanInfoHelper.encodeEntities("IllegalArgumentException if the tag contains illegal punctuation")};
            currentResult.setValue("throws", throwsObjectArray);
            currentResult.setValue("since", "12.2.1.0.0");
            descriptors.put(methodKey, currentResult);
            currentResult.setValue("description", "<p>Remove a tag from this Configuration MBean</p> ");
            currentResult.setValue("role", "collection");
            currentResult.setValue("property", "Tags");
            currentResult.setValue("since", "12.2.1.0.0");
         }
      }

   }

   private void fillinFinderMethodInfos(Map descriptors) throws IntrospectionException, NoSuchMethodException {
      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion)) {
         Method mth = WLDFServerDiagnosticMBean.class.getMethod("lookupWLDFDataRetirementByAge", String.class);
         ParameterDescriptor[] parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("name", (String)null)};
         String methodKey = BeanInfoHelper.buildMethodKey(mth);
         if (!descriptors.containsKey(methodKey)) {
            MethodDescriptor currentResult = new MethodDescriptor(mth, parameterDescriptors);
            currentResult.setValue("since", "10.0.0.0");
            descriptors.put(methodKey, currentResult);
            currentResult.setValue("description", "<p>Look up WLDFDataRetirementByAgeMBean object with given name</p> ");
            currentResult.setValue("role", "finder");
            currentResult.setValue("property", "WLDFDataRetirementByAges");
            currentResult.setValue("since", "10.0.0.0");
         }
      }

   }

   private void fillinOperationMethodInfos(Map descriptors) throws IntrospectionException, NoSuchMethodException {
      Method mth = WLDFServerDiagnosticMBean.class.getMethod("freezeCurrentValue", String.class);
      ParameterDescriptor[] parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("attributeName", (String)null)};
      String methodKey = BeanInfoHelper.buildMethodKey(mth);
      MethodDescriptor currentResult;
      if (!descriptors.containsKey(methodKey)) {
         currentResult = new MethodDescriptor(mth, parameterDescriptors);
         currentResult.setValue("deprecated", "9.0.0.0 ");
         descriptors.put(methodKey, currentResult);
         currentResult.setValue("description", "<p>If the specified attribute has not been set explicitly, and if the attribute has a default value, this operation forces the MBean to persist the default value.</p>  <p>Unless you use this operation, the default value is not saved and is subject to change if you update to a newer release of WebLogic Server. Invoking this operation isolates this MBean from the effects of such changes.</p>  <p>Note: To insure that you are freezing the default value, invoke the <code>restoreDefaultValue</code> operation before you invoke this.</p>  <p>This operation has no effect if you invoke it on an attribute that does not provide a default value or on an attribute for which some other value has been set.</p> ");
         currentResult.setValue("role", "operation");
      }

      mth = WLDFServerDiagnosticMBean.class.getMethod("restoreDefaultValue", String.class);
      parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("attributeName", (String)null)};
      methodKey = BeanInfoHelper.buildMethodKey(mth);
      if (!descriptors.containsKey(methodKey) && !this.readOnly) {
         currentResult = new MethodDescriptor(mth, parameterDescriptors);
         currentResult.setValue("deprecated", "9.0.0.0 ");
         descriptors.put(methodKey, currentResult);
         currentResult.setValue("description", "<p>If the specified attribute has a default value, this operation removes any value that has been set explicitly and causes the attribute to use the default value.</p>  <p>Default values are subject to change if you update to a newer release of WebLogic Server. To prevent the value from changing if you update to a newer release, invoke the <code>freezeCurrentValue</code> operation.</p>  <p>This operation has no effect if you invoke it on an attribute that does not provide a default value or on an attribute that is already using the default.</p> ");
         currentResult.setValue("role", "operation");
         currentResult.setValue("impact", "action");
      }

      if (BeanInfoHelper.isVersionCompliant("10.0.0.0", (String)null, this.targetVersion)) {
         mth = WLDFServerDiagnosticMBean.class.getMethod("lookupWLDFDataRetirement", String.class);
         parameterDescriptors = new ParameterDescriptor[]{createParameterDescriptor("name", "Name of the data retirement ")};
         methodKey = BeanInfoHelper.buildMethodKey(mth);
         if (!descriptors.containsKey(methodKey)) {
            currentResult = new MethodDescriptor(mth, parameterDescriptors);
            currentResult.setValue("since", "10.0.0.0");
            descriptors.put(methodKey, currentResult);
            currentResult.setValue("description", "<p>Look up WLDFDataRetirement object with given name</p> ");
            currentResult.setValue("role", "operation");
            currentResult.setValue("since", "10.0.0.0");
         }
      }

   }

   protected void buildMethodDescriptors(Map descriptors) throws IntrospectionException, NoSuchMethodException {
      this.fillinFinderMethodInfos(descriptors);
      if (!this.readOnly) {
         this.fillinCollectionMethodInfos(descriptors);
         this.fillinFactoryMethodInfos(descriptors);
      }

      this.fillinOperationMethodInfos(descriptors);
      super.buildMethodDescriptors(descriptors);
   }

   protected void buildEventSetDescriptors(Map descriptors) throws IntrospectionException {
   }
}
