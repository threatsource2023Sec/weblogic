package org.jboss.weld.config;

public enum ConfigurationKey {
   @Description("Indicates whether the concurrent deployment is enabled.")
   CONCURRENT_DEPLOYMENT("org.jboss.weld.bootstrap.concurrentDeployment", true),
   @Description("Weld is capable of resolving observer methods for container lifecycle events in advance while bean deployer threads are blocked waiting for I/O operations. This option specifies the number of threads used for preloading. If set to 0, preloading is disabled.")
   PRELOADER_THREAD_POOL_SIZE("org.jboss.weld.bootstrap.preloaderThreadPoolSize", Math.max(1, Runtime.getRuntime().availableProcessors() - 1)),
   @Description("Non-portable mode is suggested by the specification to overcome problems with legacy applications not using CDI SPI properly. The non-portable mode is disabled by default.")
   NON_PORTABLE_MODE("org.jboss.weld.nonPortableMode", false),
   @Description("The number of threads to be used by the Weld thread pool. Only used by <code>FIXED</code> and <code>FIXED_TIMEOUT</code> thread pool type.")
   EXECUTOR_THREAD_POOL_SIZE("org.jboss.weld.executor.threadPoolSize", Runtime.getRuntime().availableProcessors()),
   @Description("If set to true, some more debug information is logged when the Weld thread pool is used.")
   EXECUTOR_THREAD_POOL_DEBUG("org.jboss.weld.executor.threadPoolDebug", false),
   @Description("The type of the Weld thread pool. Possible values are: <ul><li><code>FIXED</code> - Uses a fixed number of threads. The number of threads remains the same throughout the application.</li><li><code>FIXED_TIMEOUT</code> - Uses a fixed number of threads. A thread will be stopped after a configured period of inactivity.</li><li><code>NONE</code> - No dedicated thread pool used.</li><li><code>SINGLE_THREAD</code> - A single-threaded thread pool.</li><li><code>COMMON</code> - The default ForkJoinPool.commonPool() is used.</li>")
   EXECUTOR_THREAD_POOL_TYPE("org.jboss.weld.executor.threadPoolType", ""),
   @Description("The maximum time the idle threads will wait for new tasks before terminating. Only used by <code>FIXED_TIMEOUT</code> thread pool type.")
   EXECUTOR_THREAD_POOL_KEEP_ALIVE_TIME("org.jboss.weld.executor.threadPoolKeepAliveTime", 60L),
   @Description("Weld caches already resolved injection points in order to resolve them faster in the future. There exists a separate type safe resolver for beans, decorators, disposers, interceptors and observers. Each of them stores resolved injection points in its cache, which maximum size is bounded by a common default value.")
   RESOLUTION_CACHE_SIZE("org.jboss.weld.resolution.cacheSize", 65536L),
   @Description("For debugging purposes, itâ€™s possible to dump the generated bytecode of client proxies and enhanced subclasses to the filesystem. The value represents the file path where the files should be stored.")
   PROXY_DUMP("org.jboss.weld.proxy.dump", ""),
   @Description("Weld supports a non-standard workaround to be able to create client proxies for Java types that cannot be proxied by the container, using non-portable JVM APIs.")
   RELAXED_CONSTRUCTION("org.jboss.weld.construction.relaxed", false),
   PROXY_INSTANTIATOR("org.jboss.weld.proxy.instantiator", ""),
   /** @deprecated */
   @Description("This option is deprecated - <code>org.jboss.weld.construction.relaxed</code> should be used instead.")
   PROXY_UNSAFE("org.jboss.weld.proxy.unsafe", false),
   @Description("XML descriptor validation is enabled by default.")
   DISABLE_XML_VALIDATION("org.jboss.weld.xml.disableValidating", false),
   @Description("For certain combinations of scopes, the container is permitted to optimize an injectable reference lookup. The optimization is disabled by default.")
   INJECTABLE_REFERENCE_OPTIMIZATION("org.jboss.weld.injection.injectableReferenceOptimization", false),
   @Description("<strong>DEVELOPMENT MODE</strong> - a bean whose bean class is matching this regular expression is excluded from monitoring")
   PROBE_INVOCATION_MONITOR_EXCLUDE_TYPE("org.jboss.weld.probe.invocationMonitor.excludeType", ""),
   @Description("<strong>DEVELOPMENT MODE</strong> - if set to <code>true</code> the JavaBean accessor methods are not monitored.")
   PROBE_INVOCATION_MONITOR_SKIP_JAVABEAN_PROPERTIES("org.jboss.weld.probe.invocationMonitor.skipJavaBeanProperties", true),
   @Description("<strong>DEVELOPMENT MODE</strong> - an event class matching this regular expression is excluded from monitoring.")
   PROBE_EVENT_MONITOR_EXCLUDE_TYPE("org.jboss.weld.probe.eventMonitor.excludeType", ""),
   @Description("This optimization is used to reduce the HTTP session replication overhead. However, the inconsistency detection mechanism may cause problems in some development environments.")
   BEAN_IDENTIFIER_INDEX_OPTIMIZATION("org.jboss.weld.serialization.beanIdentifierIndexOptimization", true),
   @Description("<strong>DEVELOPMENT MODE</strong> - if set to <code>true</code> an informative HTML snippet will be added to every response with Content-Type of value <code>text/html</code>.")
   PROBE_EMBED_INFO_SNIPPET("org.jboss.weld.probe.embedInfoSnippet", true),
   @Description("If set to <code>true</code>, the attributes should be fetched lazily from the backing store for some contexts (e.g. attributes of an HTTP session for a session context).")
   CONTEXT_ATTRIBUTES_LAZY_FETCH("org.jboss.weld.context.attributes.lazyFetch", true),
   @Description("<strong>DEVELOPMENT MODE</strong> - if set to <code>true</code> one or more MBean components may be registered so that it is possible to use JMX to access the Probe development tool data.")
   PROBE_JMX_SUPPORT("org.jboss.weld.probe.jmxSupport", false),
   @Description("<strong>DEVELOPMENT MODE</strong> - if set to <code>true</code> all the container lifecycle events are monitored during bootstrap. Note that this feature has negative impact on the <strong>bootstrap performance</strong>.")
   PROBE_EVENT_MONITOR_CONTAINER_LIFECYCLE_EVENTS("org.jboss.weld.probe.eventMonitor.containerLifecycleEvents", false),
   @Description("<strong>DEVELOPMENT MODE</strong> - a regular expression used to limit access to Probe REST API. Matches connections from localhost by default. Might not work properly for an application behind a reverse proxy or a load balancer.")
   PROBE_ALLOW_REMOTE_ADDRESS("org.jboss.weld.probe.allowRemoteAddress", "127.0.0.1|::1|::1%.+|0:0:0:0:0:0:0:1|0:0:0:0:0:0:0:1%.+"),
   @Description("Weld supports a non-standard workaround to be able to create proxies for Java types which declare non-private non-static final methods. A regular expression. If an unproxyable type matches this pattern, the type is considered proxyable and final methods are ignored.")
   PROXY_IGNORE_FINAL_METHODS("org.jboss.weld.proxy.ignoreFinalMethods", ""),
   @Description("The maximum inactivity time of conversation in milliseconds.")
   CONVERSATION_TIMEOUT("org.jboss.weld.conversation.timeout", 600000L),
   @Description("The maximum time to wait on the lock of conversation in milliseconds.")
   CONVERSATION_CONCURRENT_ACCESS_TIMEOUT("org.jboss.weld.conversation.concurrentAccessTimeout", 1000L),
   @Description("The delimiter is used to abbreviate a bean archive identifier before used as a part of an identifier of an internal component (such as bean).")
   ROLLING_UPGRADES_ID_DELIMITER("org.jboss.weld.clustering.rollingUpgradesIdDelimiter", ""),
   @Description("A regular expression. If a non-empty string, then all annotated types whose <code>javax.enterprise.inject.spi.AnnotatedType#getJavaClass().getName()</code> matches this pattern are vetoed if not annotated with a bean defining annotation.")
   VETO_TYPES_WITHOUT_BEAN_DEFINING_ANNOTATION("org.jboss.weld.bootstrap.vetoTypesWithoutBeanDefiningAnnotation", ""),
   @Description("If a non-empty string and development mode is enabled, the Probe data will be automatically exported after deployment validation. The value represents a path of the directory where to export the data file.")
   PROBE_EXPORT_DATA_AFTER_DEPLOYMENT("org.jboss.weld.probe.exportDataAfterDeployment", ""),
   ALLOW_OPTIMIZED_CLEANUP("org.jboss.weld.bootstrap.allowOptimizedCleanup", false, true),
   UNUSED_BEANS_EXCLUDE_TYPE("org.jboss.weld.bootstrap.unusedBeans.excludeType", "ALL"),
   UNUSED_BEANS_EXCLUDE_ANNOTATION("org.jboss.weld.bootstrap.unusedBeans.excludeAnnotation", "javax\\.ws\\.rs.*"),
   @Description("If set to true then when a contextual reference for a @SessionScoped or @ConversationScoped bean is obtained from a context backed by an HTTP session the instance is set again using HttpSession.setAttribute(). This allows to trigger session replication in some application servers.")
   RESET_HTTP_SESSION_ATTR_ON_BEAN_ACCESS("org.jboss.weld.context.resetHttpSessionAttributeOnBeanAccess", false);

   private final String key;
   private final Object defaultValue;
   private final boolean integratorOnly;

   private ConfigurationKey(String key, Object defaultValue) {
      this(key, defaultValue, false);
   }

   private ConfigurationKey(String key, Object defaultValue, boolean integratorOnly) {
      this.key = key;
      if (!isValueTypeSupported(defaultValue.getClass())) {
         throw new IllegalArgumentException("Unsupported value type: " + defaultValue);
      } else {
         this.defaultValue = defaultValue;
         this.integratorOnly = integratorOnly;
      }
   }

   public String get() {
      return this.key;
   }

   public Object getDefaultValue() {
      return this.defaultValue;
   }

   public boolean isIntegratorOnly() {
      return this.integratorOnly;
   }

   public boolean isValidValue(Object value) {
      return this.isValidValueType(value.getClass());
   }

   public boolean isValidValueType(Class valueType) {
      return this.defaultValue.getClass().isAssignableFrom(valueType);
   }

   public Object convertValue(String value) {
      if (this.defaultValue instanceof Boolean) {
         return Boolean.valueOf(value);
      } else if (this.defaultValue instanceof Long) {
         return Long.valueOf(value);
      } else {
         return this.defaultValue instanceof Integer ? Integer.valueOf(value) : value.toString();
      }
   }

   public static boolean isValueTypeSupported(Class valueType) {
      return valueType.equals(String.class) || valueType.equals(Boolean.class) || valueType.equals(Integer.class) || valueType.equals(Long.class);
   }

   public static ConfigurationKey fromString(String from) {
      ConfigurationKey[] var1 = values();
      int var2 = var1.length;

      for(int var3 = 0; var3 < var2; ++var3) {
         ConfigurationKey key = var1[var3];
         if (key.get().equals(from)) {
            return key;
         }
      }

      return null;
   }

   public static final class UnusedBeans {
      public static final String ALL = "ALL";
      public static final String NONE = "NONE";

      public static final boolean isEnabled(WeldConfiguration configuration) {
         return isEnabled(configuration.getStringProperty(ConfigurationKey.UNUSED_BEANS_EXCLUDE_TYPE));
      }

      public static final boolean isEnabled(String value) {
         return !"ALL".equals(value) && !".*".equals(value);
      }

      public static final boolean excludeNone(String value) {
         return "NONE".equals(value);
      }
   }
}
