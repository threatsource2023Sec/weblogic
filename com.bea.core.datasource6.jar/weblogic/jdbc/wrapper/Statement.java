package weblogic.jdbc.wrapper;

import java.sql.SQLException;
import java.util.HashSet;
import java.util.Iterator;
import weblogic.diagnostics.instrumentation.DelegatingMonitor;
import weblogic.diagnostics.instrumentation.DiagnosticMonitor;
import weblogic.diagnostics.instrumentation.InstrumentationSupport;
import weblogic.diagnostics.instrumentation.JoinPoint;
import weblogic.diagnostics.instrumentation.LocalHolder;
import weblogic.diagnostics.instrumentation.PointcutHandlingInfo;
import weblogic.diagnostics.instrumentation.ValueHandlingInfo;
import weblogic.j2ee.descriptor.wl.JDBCDataSourceBean;
import weblogic.jdbc.JDBCLogger;
import weblogic.jdbc.common.internal.ConnectionEnv;
import weblogic.jdbc.common.internal.ConnectionPoolProfiler;
import weblogic.jdbc.common.internal.JdbcDebug;
import weblogic.jdbc.common.internal.ProfileClosedUsage;
import weblogic.jdbc.common.internal.StatementHolder;

public class Statement extends JDBCWrapperImpl {
   public java.sql.Statement stmt = null;
   public Connection conn = null;
   public String sql = null;
   public int resultSetType = -1;
   public int resultSetConcurrency = -1;
   public boolean isCallable = false;
   public int resultSetHoldability = -1;
   public int autoGeneratedKeys = -1;
   public int[] columnIndexes = null;
   public String[] columnNames = null;
   protected volatile boolean isClosed = false;
   protected boolean poolable = false;
   protected HashSet rsets = new HashSet(1);
   private boolean cpStmtProfilingEnabled = false;
   private ConnectionPoolProfiler profiler = null;
   private String currSql = null;
   private long currStartTime = 0L;
   private boolean cancelled = false;
   protected ProfileClosedUsage profileClosedUsage = new ProfileClosedUsage();
   private boolean isInUse = false;
   java.sql.ResultSet current_rs = null;
   static final long serialVersionUID = -6014297453132342738L;
   static final String _WLDF$INST_VERSION = "9.0.0";
   // $FF: synthetic field
   static Class _WLDF$INST_FLD_class = Class.forName("weblogic.jdbc.wrapper.Statement");
   static final DelegatingMonitor _WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low;
   static final JoinPoint _WLDF$INST_JPFLD_0;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_0;
   static final JoinPoint _WLDF$INST_JPFLD_1;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_1;
   static final JoinPoint _WLDF$INST_JPFLD_2;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_2;
   static final JoinPoint _WLDF$INST_JPFLD_3;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_3;
   static final JoinPoint _WLDF$INST_JPFLD_4;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_4;
   static final JoinPoint _WLDF$INST_JPFLD_5;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_5;
   static final JoinPoint _WLDF$INST_JPFLD_6;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_6;
   static final JoinPoint _WLDF$INST_JPFLD_7;
   static final DiagnosticMonitor[] _WLDF$INST_JPFLD_JPMONS_7;

   public Object postInvocationHandler(String methodName, Object[] params, Object ret) throws Exception {
      this.isInUse = false;
      ConnectionEnv cc;
      if (ret == null) {
         super.postInvocationHandler(methodName, params, (Object)null);
         if (this.conn != null) {
            cc = this.conn.getConnectionEnv();
            if (cc != null) {
               cc.setNotInUse();
            }
         }

         if (this.cancelled) {
            this.cancelled = false;
            throw new SQLException("Statement cancelled, probably by transaction timing out");
         } else {
            return null;
         }
      } else {
         try {
            if (ret instanceof java.sql.ResultSet) {
               ret = ResultSet.makeResultSet((java.sql.ResultSet)ret, this.conn, this);
            } else if (ret instanceof java.sql.ParameterMetaData) {
               ret = ParameterMetaData.makeParameterMetaData((java.sql.ParameterMetaData)ret, this.conn);
            } else if (ret instanceof java.sql.ResultSetMetaData) {
               ret = ResultSetMetaData.makeResultSetMetaData((java.sql.ResultSetMetaData)ret, this.conn);
            }
         } catch (Exception var8) {
            JDBCLogger.logStackTrace(var8);
            throw var8;
         } finally {
            super.postInvocationHandler(methodName, params, ret);
         }

         if (this.conn != null) {
            cc = this.conn.getConnectionEnv();
            if (cc != null) {
               cc.setNotInUse();
            }
         }

         if (this.cancelled) {
            this.cancelled = false;
            throw new SQLException("Statement cancelled, probably by transaction timing out");
         } else {
            return ret;
         }
      }
   }

   public Object postInvocationHandlerNoWrap(String methodName, Object[] params, Object ret) throws Exception {
      this.isInUse = false;
      super.postInvocationHandler(methodName, params, ret);
      if (this.cancelled) {
         this.cancelled = false;
         throw new SQLException("Statement cancelled, probably by transaction timing out");
      } else {
         return ret;
      }
   }

   public void preInvocationHandler(String methodName, Object[] params) throws Exception {
      super.preInvocationHandler(methodName, params);
      if (!methodName.equals("isClosed")) {
         this.checkStatement();
      }

      if (this.conn != null) {
         ConnectionEnv cc = this.conn.getConnectionEnv();
         if (cc != null) {
            cc.setInUse();
            cc.setUserCon(this.conn);
         }
      }

      this.isInUse = true;
   }

   public Object invocationExceptionHandler(String methodName, Object[] params, Throwable t) throws SQLException {
      this.isInUse = false;
      return super.invocationExceptionHandler(methodName, params, t);
   }

   protected boolean isInUse() {
      return this.isInUse;
   }

   public ConnectionEnv getConnectionEnv() {
      return this.conn == null ? null : this.conn.getConnectionEnv();
   }

   public void init(java.sql.Statement stmt, Connection conn, String sql, int resultSetType, int resultSetConcurrency, boolean isCallable, int resultSetHoldability, int autoGeneratedKeys, int[] columnIndexes, String[] columnNames) {
      this.stmt = stmt;
      this.conn = conn;
      this.sql = sql;
      this.resultSetType = resultSetType;
      this.resultSetConcurrency = resultSetConcurrency;
      this.isCallable = isCallable;
      this.resultSetHoldability = resultSetHoldability;
      this.autoGeneratedKeys = autoGeneratedKeys;
      this.columnIndexes = columnIndexes;
      this.columnNames = columnNames;
      ConnectionEnv ce = null;
      if (conn != null) {
         ce = conn.getConnectionEnv();
      }

      if (ce != null) {
         JDBCDataSourceBean dsBean = ce.pool.getJDBCDataSource();
         if (dsBean != null) {
            int queryTimeout = dsBean.getJDBCConnectionPoolParams().getStatementTimeout();

            try {
               if (queryTimeout > -1) {
                  stmt.setQueryTimeout(queryTimeout);
               }
            } catch (SQLException var15) {
               JDBCLogger.logSetQueryTOFailed(var15.toString());
            }
         }

         this.profiler = (ConnectionPoolProfiler)conn.getConnectionEnv().getConnectionPool().getProfiler();
         this.profileClosedUsage.setProfiler(this.profiler);
         if (stmt instanceof java.sql.PreparedStatement) {
            if (ConnectionEnv.isJDBC4Runtime() && ce.supportStatementPoolable()) {
               try {
                  this.setPoolable(true);
               } catch (SQLException var16) {
                  if (JdbcDebug.JDBCSQL.isDebugEnabled()) {
                     JdbcDebug.JDBCSQL.debug("Statement.setPoolable(true) failed.", var16);
                  }
               }
            } else {
               this.poolable = true;
            }
         }

      }
   }

   public static java.sql.Statement makeStatement(java.sql.Statement stmt, Connection conn, String sql, int resultSetType, int resultSetConcurrency) {
      return makeStatement(stmt, conn, sql, resultSetType, resultSetConcurrency, -1, -1, (int[])null, (String[])null);
   }

   public static java.sql.Statement makeStatement(java.sql.Statement stmt, Connection conn, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability, int autoGeneratedKeys, int[] columnIndexes, String[] columnNames) {
      if (stmt == null) {
         return null;
      } else {
         if (conn != null && conn instanceof Connection) {
            ConnectionEnv cc = conn.getConnectionEnv();
            if (cc != null && !cc.isWrapJdbc()) {
               return stmt;
            }
         }

         Statement wrapperStatement = (Statement)JDBCWrapperFactory.getWrapper(3, stmt, false);
         wrapperStatement.init(stmt, conn, sql, resultSetType, resultSetConcurrency, false, resultSetHoldability, autoGeneratedKeys, columnIndexes, columnNames);
         if (conn != null) {
            conn.addStatement(wrapperStatement, wrapperStatement);
         }

         return (java.sql.Statement)wrapperStatement;
      }
   }

   public void addResultSet(ResultSet rset) {
      synchronized(this.rsets) {
         this.rsets.add(rset);
      }
   }

   public void removeResultSet(ResultSet rset) {
      synchronized(this.rsets) {
         this.rsets.remove(rset);
      }
   }

   public void closeAllResultSets() {
      HashSet curRsets;
      synchronized(this.rsets) {
         if (this.rsets.size() == 0) {
            return;
         }

         curRsets = (HashSet)this.rsets.clone();
         this.rsets.clear();
      }

      Iterator i = curRsets.iterator();

      while(i.hasNext()) {
         ResultSet rset = (ResultSet)i.next();

         try {
            rset.internalClose(false);
         } catch (Exception var5) {
         }
      }

   }

   protected void beginStatementProfiling() {
      this.beginStatementProfiling(this.sql);
   }

   private void beginStatementProfiling(String aSql) {
      if (this.profiler != null) {
         this.cpStmtProfilingEnabled = this.profiler.isStmtProfilingEnabled();
      }

      if (this.cpStmtProfilingEnabled) {
         this.currSql = aSql;
         this.currStartTime = System.currentTimeMillis();
      }

   }

   protected void finishStatementProfiling() {
      if (this.cpStmtProfilingEnabled) {
         this.profiler.addStmtUsageData(this, this.currSql, this.currStartTime);
      }

   }

   public void checkStatement() throws SQLException {
      if (this.isClosed) {
         SQLException where = this.profileClosedUsage.addClosedUsageProfilingRecord();
         SQLException sqle = new SQLException("Statement has already been closed");
         if (where != null) {
            sqle.initCause(where);
         }

         throw sqle;
      } else {
         if (this.conn != null) {
            this.conn.checkConnection();
         }

         if (this.stmt == null && this.conn != null) {
            this.stmt = this.reCreateStatement();
            this.vendorObj = this.stmt;
         }

         if (this.stmt == null) {
            throw new SQLException("Internal error: No statement available");
         }
      }
   }

   protected java.sql.Statement reCreateStatement() throws SQLException {
      java.sql.Statement currStmt;
      if (this.resultSetType == -1 && this.resultSetConcurrency == -1 && this.resultSetHoldability == -1) {
         currStmt = this.conn.getRealConnection().createStatement();
      } else if (this.resultSetHoldability == -1) {
         currStmt = this.conn.getRealConnection().createStatement(this.resultSetType, this.resultSetConcurrency);
      } else {
         currStmt = this.conn.getRealConnection().createStatement(this.resultSetType, this.resultSetConcurrency, this.resultSetHoldability);
      }

      this.conn.addStatement(this, currStmt);
      this.isClosed = false;
      this.profileClosedUsage.clearWhereClosed();
      return currStmt;
   }

   public void internalClose(boolean explicit) throws SQLException {
      this.internalClose(explicit, false);
   }

   private void internalClose(boolean explicit, boolean forceClose) throws SQLException {
      if (!this.isClosed) {
         synchronized(this) {
            if (this.isClosed) {
               return;
            }

            if (explicit) {
               this.isClosed = true;
            }
         }

         this.profileClosedUsage.saveWhereClosed();
         Object val = null;
         if (this.conn != null) {
            if (explicit) {
               val = this.conn.removeStatement(this);
            } else {
               val = this.conn.getStatement(this);
            }
         }

         try {
            if (this.stmt != null) {
               this.closeAllResultSets();
               if (val instanceof StatementHolder) {
                  if (this.conn.getConnectionEnv() != null) {
                     if (!forceClose && this.poolable) {
                        this.conn.getConnectionEnv().returnCachedStatement((StatementHolder)val);
                     } else if (!this.conn.getConnectionEnv().clearStatement(this, true)) {
                        this.stmt.close();
                     }
                  }
               } else {
                  this.stmt.close();
               }
            }
         } finally {
            this.stmt = null;
            this.vendorObj = null;
            if (explicit) {
               this.rsets = null;
            }

         }

      }
   }

   public void close() throws SQLException {
      this.doClose(false);
   }

   protected void close(boolean forceClose) throws SQLException {
      this.doClose(forceClose);
   }

   private void doClose(boolean forceClose) throws SQLException {
      String methodName = "close";
      Object[] params = new Object[0];

      try {
         super.preInvocationHandler(methodName, params);

         try {
            if (!this.isClosed) {
               this.checkStatement();
            }
         } catch (Exception var5) {
            super.postInvocationHandler(methodName, params, (Object)null);
            return;
         }

         this.internalClose(true, forceClose);
         super.postInvocationHandler(methodName, params, (Object)null);
      } catch (Exception var6) {
         this.invocationExceptionHandler(methodName, params, var6);
      }

   }

   public java.sql.Connection getConnection() throws SQLException {
      String methodName = "getConnection";
      Object[] params = new Object[0];

      try {
         this.preInvocationHandler(methodName, params);
         super.postInvocationHandler(methodName, params, this.conn);
      } catch (Exception var4) {
         this.invocationExceptionHandler(methodName, params, var4);
      }

      return (java.sql.Connection)this.conn;
   }

   public java.sql.ResultSet getResultSet() throws SQLException {
      String methodName = "getResultSet";
      Object[] params = new Object[0];

      try {
         this.preInvocationHandler(methodName, params);
         if (this.current_rs == null) {
            java.sql.ResultSet rs = this.stmt.getResultSet();
            this.current_rs = ResultSet.makeResultSet(rs, this.conn, this);
         }

         super.postInvocationHandler(methodName, params, this.current_rs);
      } catch (Exception var4) {
         this.invocationExceptionHandler(methodName, params, var4);
      }

      return this.current_rs;
   }

   public boolean execute(String sql) throws SQLException {
      boolean result = false;
      String methodName = "execute";
      Object[] params = new Object[]{sql};

      try {
         this.preInvocationHandler(methodName, params);
         if (this.current_rs != null) {
            this.current_rs.close();
            this.current_rs = null;
         }

         this.beginStatementProfiling(sql);
         result = this.stmt.execute(sql);
         if (this.conn.getConnectionEnv() != null) {
            this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
         }

         this.finishStatementProfiling();
         super.postInvocationHandler(methodName, params, result);
      } catch (Exception var6) {
         this.invocationExceptionHandler(methodName, params, var6);
      }

      return result;
   }

   public java.sql.ResultSet executeQuery(String sql) throws SQLException {
      LocalHolder var5;
      if ((var5 = LocalHolder.getInstance(_WLDF$INST_JPFLD_0, _WLDF$INST_JPFLD_JPMONS_0)) != null) {
         if (var5.argsCapture) {
            var5.args = new Object[2];
            Object[] var10000 = var5.args;
            var10000[0] = this;
            var10000[1] = sql;
         }

         InstrumentationSupport.createDynamicJoinPoint(var5);
         InstrumentationSupport.preProcess(var5);
         var5.resetPostBegin();
      }

      java.sql.ResultSet var10;
      try {
         String methodName = "executeQuery";
         Object[] params = new Object[]{sql};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);
            java.sql.ResultSet rs = this.stmt.executeQuery(sql);
            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            this.current_rs = ResultSet.makeResultSet(rs, this.conn, this);
            super.postInvocationHandler(methodName, params, this.current_rs);
         } catch (Exception var8) {
            this.invocationExceptionHandler(methodName, params, var8);
         }

         var10 = this.current_rs;
      } catch (Throwable var9) {
         if (var5 != null) {
            var5.th = var9;
            var5.ret = null;
            InstrumentationSupport.postProcess(var5);
         }

         throw var9;
      }

      if (var5 != null) {
         var5.ret = var10;
         InstrumentationSupport.postProcess(var5);
      }

      return var10;
   }

   public int executeUpdate(String sql) throws SQLException {
      LocalHolder var6;
      if ((var6 = LocalHolder.getInstance(_WLDF$INST_JPFLD_1, _WLDF$INST_JPFLD_JPMONS_1)) != null) {
         if (var6.argsCapture) {
            var6.args = new Object[2];
            Object[] var10000 = var6.args;
            var10000[0] = this;
            var10000[1] = sql;
         }

         InstrumentationSupport.createDynamicJoinPoint(var6);
         InstrumentationSupport.preProcess(var6);
         var6.resetPostBegin();
      }

      int var13;
      try {
         int result = 0;
         String methodName = "executeUpdate";
         Object[] params = new Object[]{sql};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);

            try {
               result = this.stmt.executeUpdate(sql);
            } catch (SQLException var10) {
               throw var10;
            }

            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            super.postInvocationHandler(methodName, params, result);
         } catch (Exception var11) {
            this.invocationExceptionHandler(methodName, params, var11);
         }

         var13 = result;
      } catch (Throwable var12) {
         if (var6 != null) {
            var6.th = var12;
            var6.ret = InstrumentationSupport.convertToObject(0);
            InstrumentationSupport.postProcess(var6);
         }

         throw var12;
      }

      if (var6 != null) {
         var6.ret = InstrumentationSupport.convertToObject(var13);
         InstrumentationSupport.postProcess(var6);
      }

      return var13;
   }

   public void cancel() throws SQLException {
      String methodName = "cancel";
      Object[] params = new Object[0];

      try {
         super.preInvocationHandler(methodName, params);
         if (this.stmt != null) {
            this.stmt.cancel();
            this.cancelled = true;
         }

         super.postInvocationHandler(methodName, params, (Object)null);
      } catch (Exception var4) {
         this.invocationExceptionHandler(methodName, params, var4);
      }

   }

   public boolean getMoreResults() throws SQLException {
      boolean ret = false;
      String methodName = "getMoreResults";
      Object[] params = new Object[0];

      try {
         this.preInvocationHandler(methodName, params);
         this.closeAllResultSets();
         this.current_rs = null;
         ret = this.stmt.getMoreResults();
         super.postInvocationHandler(methodName, params, ret);
      } catch (Exception var5) {
         this.invocationExceptionHandler(methodName, params, var5);
      }

      return ret;
   }

   public boolean isClosed() throws SQLException {
      boolean ret = this.isClosed;
      String methodName = "isClosed";
      Object[] params = new Object[0];

      try {
         this.preInvocationHandler(methodName, params);
         if (!this.isClosed) {
            ret = this.stmt.isClosed();
         }

         this.postInvocationHandler(methodName, params, ret);
      } catch (Exception var5) {
         this.invocationExceptionHandler(methodName, params, var5);
      }

      return ret;
   }

   public boolean isPoolable() throws SQLException {
      boolean ret = false;
      String methodName = "isPoolable";
      Object[] params = new Object[0];

      try {
         this.preInvocationHandler(methodName, params);
         this.postInvocationHandler(methodName, params, ret);
      } catch (Exception var5) {
         this.invocationExceptionHandler(methodName, params, var5);
      }

      return ret;
   }

   public void setPoolable(boolean poolable) throws SQLException {
      String methodName = "setPoolable";
      Object[] params = new Object[]{poolable};

      try {
         this.preInvocationHandler(methodName, params);
         this.postInvocationHandler(methodName, params, (Object)null);
      } catch (Exception var5) {
         this.invocationExceptionHandler(methodName, params, var5);
      }

   }

   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
      LocalHolder var7;
      if ((var7 = LocalHolder.getInstance(_WLDF$INST_JPFLD_2, _WLDF$INST_JPFLD_JPMONS_2)) != null) {
         if (var7.argsCapture) {
            var7.args = new Object[3];
            Object[] var10000 = var7.args;
            var10000[0] = this;
            var10000[1] = sql;
            var10000[2] = InstrumentationSupport.convertToObject(autoGeneratedKeys);
         }

         InstrumentationSupport.createDynamicJoinPoint(var7);
         InstrumentationSupport.preProcess(var7);
         var7.resetPostBegin();
      }

      boolean var12;
      try {
         boolean result = false;
         String methodName = "execute";
         Object[] params = new Object[]{sql, autoGeneratedKeys};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);
            result = this.stmt.execute(sql, autoGeneratedKeys);
            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            super.postInvocationHandler(methodName, params, result);
         } catch (Exception var10) {
            this.invocationExceptionHandler(methodName, params, var10);
         }

         var12 = result;
      } catch (Throwable var11) {
         if (var7 != null) {
            var7.th = var11;
            var7.ret = InstrumentationSupport.convertToObject(false);
            InstrumentationSupport.postProcess(var7);
         }

         throw var11;
      }

      if (var7 != null) {
         var7.ret = InstrumentationSupport.convertToObject(var12);
         InstrumentationSupport.postProcess(var7);
      }

      return var12;
   }

   public boolean execute(String sql, int[] columnIndexes) throws SQLException {
      LocalHolder var7;
      if ((var7 = LocalHolder.getInstance(_WLDF$INST_JPFLD_3, _WLDF$INST_JPFLD_JPMONS_3)) != null) {
         if (var7.argsCapture) {
            var7.args = new Object[3];
            Object[] var10000 = var7.args;
            var10000[0] = this;
            var10000[1] = sql;
            var10000[2] = columnIndexes;
         }

         InstrumentationSupport.createDynamicJoinPoint(var7);
         InstrumentationSupport.preProcess(var7);
         var7.resetPostBegin();
      }

      boolean var12;
      try {
         boolean result = false;
         String methodName = "execute";
         Object[] params = new Object[]{sql, columnIndexes};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);
            result = this.stmt.execute(sql, columnIndexes);
            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            super.postInvocationHandler(methodName, params, result);
         } catch (Exception var10) {
            this.invocationExceptionHandler(methodName, params, var10);
         }

         var12 = result;
      } catch (Throwable var11) {
         if (var7 != null) {
            var7.th = var11;
            var7.ret = InstrumentationSupport.convertToObject(false);
            InstrumentationSupport.postProcess(var7);
         }

         throw var11;
      }

      if (var7 != null) {
         var7.ret = InstrumentationSupport.convertToObject(var12);
         InstrumentationSupport.postProcess(var7);
      }

      return var12;
   }

   public boolean execute(String sql, String[] columnNames) throws SQLException {
      LocalHolder var7;
      if ((var7 = LocalHolder.getInstance(_WLDF$INST_JPFLD_4, _WLDF$INST_JPFLD_JPMONS_4)) != null) {
         if (var7.argsCapture) {
            var7.args = new Object[3];
            Object[] var10000 = var7.args;
            var10000[0] = this;
            var10000[1] = sql;
            var10000[2] = columnNames;
         }

         InstrumentationSupport.createDynamicJoinPoint(var7);
         InstrumentationSupport.preProcess(var7);
         var7.resetPostBegin();
      }

      boolean var12;
      try {
         boolean result = false;
         String methodName = "execute";
         Object[] params = new Object[]{sql, columnNames};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);
            result = this.stmt.execute(sql, columnNames);
            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            super.postInvocationHandler(methodName, params, result);
         } catch (Exception var10) {
            this.invocationExceptionHandler(methodName, params, var10);
         }

         var12 = result;
      } catch (Throwable var11) {
         if (var7 != null) {
            var7.th = var11;
            var7.ret = InstrumentationSupport.convertToObject(false);
            InstrumentationSupport.postProcess(var7);
         }

         throw var11;
      }

      if (var7 != null) {
         var7.ret = InstrumentationSupport.convertToObject(var12);
         InstrumentationSupport.postProcess(var7);
      }

      return var12;
   }

   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
      LocalHolder var7;
      if ((var7 = LocalHolder.getInstance(_WLDF$INST_JPFLD_5, _WLDF$INST_JPFLD_JPMONS_5)) != null) {
         if (var7.argsCapture) {
            var7.args = new Object[3];
            Object[] var10000 = var7.args;
            var10000[0] = this;
            var10000[1] = sql;
            var10000[2] = InstrumentationSupport.convertToObject(autoGeneratedKeys);
         }

         InstrumentationSupport.createDynamicJoinPoint(var7);
         InstrumentationSupport.preProcess(var7);
         var7.resetPostBegin();
      }

      int var14;
      try {
         int result = 0;
         String methodName = "executeUpdate";
         Object[] params = new Object[]{sql, autoGeneratedKeys};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);

            try {
               result = this.stmt.executeUpdate(sql, autoGeneratedKeys);
            } catch (SQLException var11) {
               throw var11;
            }

            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            super.postInvocationHandler(methodName, params, result);
         } catch (Exception var12) {
            this.invocationExceptionHandler(methodName, params, var12);
         }

         var14 = result;
      } catch (Throwable var13) {
         if (var7 != null) {
            var7.th = var13;
            var7.ret = InstrumentationSupport.convertToObject(0);
            InstrumentationSupport.postProcess(var7);
         }

         throw var13;
      }

      if (var7 != null) {
         var7.ret = InstrumentationSupport.convertToObject(var14);
         InstrumentationSupport.postProcess(var7);
      }

      return var14;
   }

   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
      LocalHolder var7;
      if ((var7 = LocalHolder.getInstance(_WLDF$INST_JPFLD_6, _WLDF$INST_JPFLD_JPMONS_6)) != null) {
         if (var7.argsCapture) {
            var7.args = new Object[3];
            Object[] var10000 = var7.args;
            var10000[0] = this;
            var10000[1] = sql;
            var10000[2] = columnIndexes;
         }

         InstrumentationSupport.createDynamicJoinPoint(var7);
         InstrumentationSupport.preProcess(var7);
         var7.resetPostBegin();
      }

      int var14;
      try {
         int result = 0;
         String methodName = "executeUpdate";
         Object[] params = new Object[]{sql, columnIndexes};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);

            try {
               result = this.stmt.executeUpdate(sql, columnIndexes);
            } catch (SQLException var11) {
               throw var11;
            }

            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            super.postInvocationHandler(methodName, params, result);
         } catch (Exception var12) {
            this.invocationExceptionHandler(methodName, params, var12);
         }

         var14 = result;
      } catch (Throwable var13) {
         if (var7 != null) {
            var7.th = var13;
            var7.ret = InstrumentationSupport.convertToObject(0);
            InstrumentationSupport.postProcess(var7);
         }

         throw var13;
      }

      if (var7 != null) {
         var7.ret = InstrumentationSupport.convertToObject(var14);
         InstrumentationSupport.postProcess(var7);
      }

      return var14;
   }

   public int executeUpdate(String sql, String[] columnNames) throws SQLException {
      LocalHolder var7;
      if ((var7 = LocalHolder.getInstance(_WLDF$INST_JPFLD_7, _WLDF$INST_JPFLD_JPMONS_7)) != null) {
         if (var7.argsCapture) {
            var7.args = new Object[3];
            Object[] var10000 = var7.args;
            var10000[0] = this;
            var10000[1] = sql;
            var10000[2] = columnNames;
         }

         InstrumentationSupport.createDynamicJoinPoint(var7);
         InstrumentationSupport.preProcess(var7);
         var7.resetPostBegin();
      }

      int var14;
      try {
         int result = 0;
         String methodName = "executeUpdate";
         Object[] params = new Object[]{sql, columnNames};

         try {
            this.preInvocationHandler(methodName, params);
            if (this.current_rs != null) {
               this.current_rs.close();
               this.current_rs = null;
            }

            this.beginStatementProfiling(sql);

            try {
               result = this.stmt.executeUpdate(sql, columnNames);
            } catch (SQLException var11) {
               throw var11;
            }

            if (this.conn.getConnectionEnv() != null) {
               this.conn.getConnectionEnv().setLastSuccessfulConnectionUse();
            }

            this.finishStatementProfiling();
            super.postInvocationHandler(methodName, params, result);
         } catch (Exception var12) {
            this.invocationExceptionHandler(methodName, params, var12);
         }

         var14 = result;
      } catch (Throwable var13) {
         if (var7 != null) {
            var7.th = var13;
            var7.ret = InstrumentationSupport.convertToObject(0);
            InstrumentationSupport.postProcess(var7);
         }

         throw var13;
      }

      if (var7 != null) {
         var7.ret = InstrumentationSupport.convertToObject(var14);
         InstrumentationSupport.postProcess(var7);
      }

      return var14;
   }

   public boolean getMoreResults(int current) throws SQLException {
      boolean ret = false;
      String methodName = "getMoreResults";
      Object[] params = new Object[]{current};

      try {
         this.preInvocationHandler(methodName, params);
         ret = this.stmt.getMoreResults(current);
         if (current == 3) {
            this.closeAllResultSets();
         } else if (current == 1 && this.current_rs != null) {
            this.current_rs.close();
         }

         this.current_rs = null;
         this.postInvocationHandler(methodName, params, ret);
      } catch (Exception var6) {
         this.invocationExceptionHandler(methodName, params, var6);
      }

      return ret;
   }

   static {
      _WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low = (DelegatingMonitor)InstrumentationSupport.getMonitor(_WLDF$INST_FLD_class, "JDBC_Diagnostic_Statement_Execute_Around_Low");
      _WLDF$INST_JPFLD_0 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "executeQuery", "(Ljava/lang/String;)Ljava/sql/ResultSet;", 490, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true)})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_0 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
      _WLDF$INST_JPFLD_1 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "executeUpdate", "(Ljava/lang/String;)I", 512, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true)})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_1 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
      _WLDF$INST_JPFLD_2 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "execute", "(Ljava/lang/String;I)Z", 621, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true), null})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_2 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
      _WLDF$INST_JPFLD_3 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "execute", "(Ljava/lang/String;[I)Z", 643, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true), null})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_3 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
      _WLDF$INST_JPFLD_4 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "execute", "(Ljava/lang/String;[Ljava/lang/String;)Z", 665, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true), null})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_4 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
      _WLDF$INST_JPFLD_5 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "executeUpdate", "(Ljava/lang/String;I)I", 687, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true), null})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_5 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
      _WLDF$INST_JPFLD_6 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "executeUpdate", "(Ljava/lang/String;[I)I", 713, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true), null})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_6 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
      _WLDF$INST_JPFLD_7 = InstrumentationSupport.createJoinPoint(_WLDF$INST_FLD_class, "Statement.java", "weblogic.jdbc.wrapper.Statement", "executeUpdate", "(Ljava/lang/String;[Ljava/lang/String;)I", 739, "", "", "", InstrumentationSupport.makeMap(new String[]{"JDBC_Diagnostic_Statement_Execute_Around_Low"}, new PointcutHandlingInfo[]{InstrumentationSupport.createPointcutHandlingInfo(InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCStatementRenderer", false, true), (ValueHandlingInfo)null, new ValueHandlingInfo[]{InstrumentationSupport.createValueHandlingInfo("sql", "weblogic.diagnostics.instrumentation.gathering.JDBCSqlStringRenderer", false, true), null})}), (boolean)0);
      _WLDF$INST_JPFLD_JPMONS_7 = new DiagnosticMonitor[]{_WLDF$INST_FLD_JDBC_Diagnostic_Statement_Execute_Around_Low};
   }
}
