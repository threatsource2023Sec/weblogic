package com.bea.util.annogen.generate;

import com.bea.util.annogen.generate.internal.PropfileUtils;
import com.bea.util.annogen.generate.internal.joust.CompilingJavaOutputStream;
import com.bea.util.annogen.generate.internal.joust.Expression;
import com.bea.util.annogen.generate.internal.joust.Variable;
import com.bea.util.annogen.override.internal.AnnoBeanBase;
import com.bea.util.jam.JClass;
import com.bea.util.jam.JMethod;
import com.bea.util.jam.JamService;
import com.bea.util.jam.JamServiceFactory;
import com.bea.util.jam.JamServiceParams;
import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

public class Annogen {
   public static final String ANNOBEAN_FOR_FIELD = "ANNOBEAN_FOR";
   public static final String SETTER_PREFIX = "set_";
   private static final String FIELD_PREFIX = "_";
   private static final String BASE_CLASS = AnnoBeanBase.class.getName();
   private List mClassesLeftTodo = null;
   private Collection mClassesDone = null;
   private CompilingJavaOutputStream mJoust = new CompilingJavaOutputStream();
   private boolean mImplementAnnotationTypes = true;
   private AnnoBeanMapping[] mMappings = null;
   private File mOutputDir = null;

   public Annogen() {
      this.mClassesLeftTodo = new LinkedList();
      this.mClassesDone = new HashSet();
   }

   public void addAnnotationClasses(JClass[] classes) {
      for(int i = 0; i < classes.length; ++i) {
         if (classes[i].isAnnotationType()) {
            this.mClassesLeftTodo.add(classes[i]);
         } else {
            this.warn("Ignoring " + classes[i].getQualifiedName() + " because it is not an annotation type.");
         }
      }

   }

   public void setJavacSource(String target) {
      this.mJoust.setJavacSource(target);
   }

   public void setJavacTarget(String target) {
      this.mJoust.setJavacTarget(target);
   }

   public void setOutputDir(File dir) {
      this.mJoust.setSourceDir(dir);
      this.mJoust.setCompilationDir(dir);
      this.mOutputDir = dir;
   }

   public void setKeepGenerated(boolean b) {
      this.mJoust.setKeepGenerated(b);
   }

   public void setMappings(AnnoBeanMapping[] mappings) {
      this.mMappings = mappings;
   }

   public void setClasspath(File[] cp) {
      this.mJoust.setJavacClasspath(cp);
   }

   public void doCodegen() throws IOException {
      if (this.mOutputDir == null) {
         throw new IllegalStateException("destdir not set");
      } else {
         while(this.mClassesLeftTodo.size() > 0) {
            JClass clazz = (JClass)this.mClassesLeftTodo.get(0);
            this.mClassesLeftTodo.remove(0);
            this.mClassesDone.add(clazz);
            this.doCodegen(clazz);
         }

         this.mJoust.close();
      }
   }

   public void setImplementAnnotationTypes(boolean b) {
      this.mImplementAnnotationTypes = b;
   }

   public void setOutputEncoding(String enc) {
      this.mJoust.setEncoding(enc);
   }

   File getOutputDir() {
      return this.mOutputDir;
   }

   private void doCodegen(JClass jsr175type) throws IOException {
      if (jsr175type == null) {
         throw new IllegalArgumentException();
      } else {
         String annoBeanClassname = this.getAnnobeanClassnameFor(jsr175type);
         if (annoBeanClassname == null) {
            throw new IllegalStateException();
         } else {
            int lastDot = annoBeanClassname.lastIndexOf(46);
            String simpleImplName = lastDot == -1 ? annoBeanClassname : annoBeanClassname.substring(lastDot + 1);
            String packageName = lastDot == -1 ? null : annoBeanClassname.substring(0, lastDot);
            this.mJoust.startFile(packageName, simpleImplName);
            JMethod[] methods = jsr175type.getDeclaredMethods();
            String[] implementInterface = !this.mImplementAnnotationTypes ? null : new String[]{jsr175type.getQualifiedName()};
            this.mJoust.writeComment("THIS IS GENERATED CODE! DO NOT EDIT!\n\n\nGenerated by " + this.getClass().getName() + "\n on " + new Date() + "\n\n");
            this.mJoust.startClass(1, BASE_CLASS, implementInterface);
            this.mJoust.writeField(25, "java.lang.String", "ANNOBEAN_FOR", this.mJoust.getExpressionFactory().createString(jsr175type.getQualifiedName()));

            for(int i = 0; i < methods.length; ++i) {
               this.doOneProperty(methods[i]);
            }

            this.mJoust.endClassOrInterface();
            this.mJoust.endFile();
            PropfileUtils.getInstance().writeAnnobeanTypeFor(jsr175type, annoBeanClassname, this.mOutputDir);
         }
      }
   }

   private void doOneProperty(JMethod getter) throws IOException {
      if (getter == null) {
         throw new IllegalArgumentException();
      } else {
         String fieldName = "_" + getter.getSimpleName();
         JClass type = getter.getReturnType();
         String typeName = !this.mImplementAnnotationTypes ? this.getAnnobeanClassForIfGenerated(type) : type.getQualifiedName();
         Variable fieldVar = this.mJoust.writeField(2, typeName, fieldName, (Expression)null);
         this.mJoust.startMethod(1, typeName, getter.getSimpleName(), (String[])null, (String[])null, (String[])null);
         this.mJoust.writeReturnStatement(fieldVar);
         this.mJoust.endMethodOrConstructor();
         String[] paramTypeNames = new String[]{typeName};
         String[] paramNames = new String[]{"in"};
         Variable[] params = this.mJoust.startMethod(1, "void", "set_" + getter.getSimpleName(), paramTypeNames, paramNames, (String[])null);
         this.mJoust.writeAssignmentStatement(fieldVar, params[0]);
         this.mJoust.endMethodOrConstructor();
         JClass c = getter.getContainingClass().forName(typeName);
         if (c.isAnnotationType() && !this.mClassesLeftTodo.contains(c) && !this.mClassesDone.contains(c)) {
            this.mClassesLeftTodo.add(c);
         }

      }
   }

   private void warn(String msg) {
      System.out.println("[Warning] " + msg);
   }

   private String getAnnobeanClassForIfGenerated(JClass jsr175type) {
      if (jsr175type == null) {
         throw new IllegalArgumentException();
      } else if (!jsr175type.isArrayType()) {
         return !this.mClassesLeftTodo.contains(jsr175type) && !this.mClassesDone.contains(jsr175type) ? jsr175type.getQualifiedName() : this.getAnnobeanClassnameFor(jsr175type);
      } else {
         JClass comp = jsr175type.getArrayComponentType();
         StringWriter out = new StringWriter();
         out.write(this.getAnnobeanClassForIfGenerated(comp));

         for(int i = 0; i < jsr175type.getArrayDimensions(); ++i) {
            out.write("[]");
         }

         return out.toString();
      }
   }

   private String getAnnobeanClassnameFor(JClass jsr175type) {
      if (jsr175type == null) {
         throw new IllegalArgumentException();
      } else {
         String classname = jsr175type.getQualifiedName();
         if (this.mMappings != null) {
            for(int i = 0; i < this.mMappings.length; ++i) {
               String match = this.mMappings[i].getAnnoBeanFor(classname);
               if (match != null) {
                  return match;
               }
            }
         }

         return getDefaultAnnobeanClassnameFor(jsr175type);
      }
   }

   public static String getDefaultAnnobeanClassnameFor(JClass jsr175type) {
      if (jsr175type == null) {
         throw new IllegalArgumentException();
      } else {
         return jsr175type.getContainingPackage().getQualifiedName() + ".annobeans." + jsr175type.getSimpleName() + "Annobean";
      }
   }

   public static void main(String[] args) {
      try {
         JamServiceFactory jsf = JamServiceFactory.getInstance();
         JamServiceParams params = jsf.createServiceParams();
         Annogen ag = new Annogen();

         for(int i = 0; i < args.length; ++i) {
            if (args[i].equals("-d")) {
               ++i;
               ag.setOutputDir(new File(args[i]));
               ++i;
            } else {
               File f = new File(args[i]);
               if (f.isDirectory()) {
                  File[] fs = f.listFiles();

                  for(int j = 0; j < fs.length; ++j) {
                     params.includeSourceFile(fs[j]);
                  }
               } else {
                  params.includeSourceFile(f);
               }
            }
         }

         JamService js = jsf.createService(params);
         ag.addAnnotationClasses(js.getAllClasses());
         ag.doCodegen();
      } catch (IOException var8) {
         var8.printStackTrace();
         System.out.flush();
         System.exit(-1);
      }

   }
}
