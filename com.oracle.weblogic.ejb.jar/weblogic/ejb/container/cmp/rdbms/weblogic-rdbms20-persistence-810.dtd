<!--
This is the DTD for WebLogic 8.1 RDBMS CMP deployment descriptors.

Copyright (c) 2001-2002 by BEA Systems, Inc. All Rights Reserved.
-->


<!--
The root level element of a Weblogic RDBMS CMP deployment descriptor.
The deployment descriptor contains deployment information for one or
more entity beans, and an optional set of relations.
-->
<!ELEMENT weblogic-rdbms-jar (
    weblogic-rdbms-bean+,
    weblogic-rdbms-relation*,
    order-database-operations?,
    enable-batch-operations?,
    create-default-dbms-tables?,
    validate-db-schema-with?,
    database-type?,
    default-dbms-tables-ddl?,
    compatibility?
)>


<!--
This element represents a single entity bean that is managed by the
WebLogic RDBMS CMP persistence type.
-->

<!ELEMENT weblogic-rdbms-bean (
    ejb-name,
    data-source-name,
    table-map+,
    field-group*,
    relationship-caching*,
    weblogic-query*,
    delay-database-insert-until?,
    use-select-for-update?,
    lock-order?,
    instance-lock-order?,
    automatic-key-generation?,
    check-exists-on-method?
)>


<!-- 
A CMP bean can be mapped to one or more DBMS tables.  A <table-map>
element specifies a mapping between the cmp-fields of a bean and the
columns of a table for all of the cmp-fields mapped to that table.  If
a CMP Bean is mapped to n DBMS tables, then there must be n
<table-map> elements specified for the bean, one for each of the n
DBMS Tables.

When a CMP bean is mapped to multiple tables, each table contains a
row that is mapped to a particular bean instance.  Thus, all tables
will contain the same number of rows at any point in time.  In
addition, each table will contain the same set of homogeneous primary
key values. Consequently, each table must have the same number of
primary key columns and corresponding primary key columns in diferent
tables must have the same type, though they may have different names.

Each <table-map> element must specify a mapping from the primary key
column(s) for a particular table to the primary key field(s) of the
bean. Non-primary key fields may only be mapped to a single table.

Example:

A Department bean is mapped to 2 tables: DeptTable1, DeptTable2.
Department bean has two primary key cmp-fields: deptId1, deptId2 and
non-primary key cmp-fields: location, budget, and holidayPolicy.

  <table-map>
    <table-name>DeptTable1</table-name>

    <field-map>
      <cmp-field>deptId1</cmp-field>
      <dbms-column>t1_deptId1_column</dbms-column>
    </field-map>
    <field-map>
      <cmp-field>deptId2</cmp-field>
      <dbms-column>t1_deptId2_column</dbms-column>
    </field-map>
    <field-map>
      <cmp-field>location </cmp-field>
      <dbms-column>t1_location_column</dbms-column>
    </field-map>
    <field-map>
      <cmp-field>budget</cmp-field>
      <dbms-column>t1_budget_column</dbms-column>
    </field-map>
  </table-map>

  <table-map>
    <table-name>DeptTable2</table-name>

    <field-map>
      <cmp-field>deptId1</cmp-field>
      <dbms-column>t2_deptId1_column</dbms-column>
    </field-map>
    <field-map>
      <cmp-field>deptId2</cmp-field>
      <dbms-column>t2_deptId2_column</dbms-column>
    </field-map>
    <field-map>
      <cmp-field>holidayPolicy</cmp-field>
      <dbms-column>t2_holidayPolicy</dbms-column>
    </field-map>
  </table-map>

Note that each table-map element above contains a mapping for the
primary-key fields of the bean.  This is required.

Used in: weblogic-rdbms-bean

Since: WLS 7.0
-->
<!ELEMENT table-map (
    table-name,
    field-map*,
    verify-rows?,
    verify-columns?,
    optimistic-column?
)>

<!-- 
The verify-rows element is used to specify the rows in a table that
should be checked when optimistic concurrency is used.  A value of
'Modified' means that only rows that are updated or deleted by a
transaction are checked.  A value of 'Read' specifies that any row
that is read by the transaction should be checked.  This includes both
rows that are simply read and rows that are read and then updated or
deleted by the transaction.

Specifying a value of 'Read' entails additional overhead since it
generally increases the amount of optimistic checking that must be
performed by the EJB container.  With the 'Read' option, committed
transactions read a set of rows that are guaranteed not to be
modified by another transaction until after the transaction commits.
This results in a high level of consistency which is very close to the
ANSI definition of SERIALIZABLE consistency.

Specifying a value of 'Modified', on the other hand, ensures that two
transactions won't update the same row concurrently resulting in a
lost update, but it allows reads and updates of different transactions
to be interleaved. This results in a level of consistency that falls
between the ANSI READ_COMMITTED and REPEATABLE_READ levels of
consistency.

Restriction: If verify-rows is set to 'Read' then the verify-columns
element may not have a value of 'Modified' since this combination
would result in only checking the modified rows.

Used in: table-map

Default value: Modified
 
Since WLS 8.1
-->
<!ELEMENT verify-rows (#PCDATA)>


<!--
The verify-columns element is used to specify the columns in a table
that should be checked for validity when optimistic concurrency is
used. Legal values are 'Read', 'Modified', 'Version', and 'Timestamp'.
Columns are checked at the end of a transaction, before committing, to
make sure that no other transaction has modified the column's data.
When 'Read' is specified, all of the columns in the table that have
been read during the transaction are checked.  When 'Modified' is
specified, only the columns that have been updated by the current
transaction are checked.

The 'Version' and 'Timestamp' options are used to specify that a
version or timestamp (pseudo)column exists in the table and that this
column is used to implement optimistic concurrency.  The EJB container
will automatically increment the version or timestamp column when a
row in the table is updated.  The name of the version (or timestamp)
column is specified using the optimistic-column element.  It is not
necessary to map this column to a cmp field, unless desired.

If a bean is mapped to multiple tables, checking is only performed on 
the tables that are updated during the transaction.  The verify-columns
elements for each table don't need to have the same value.

Used in: table-map

Default value: none

Since: WLS 7.0
-->
<!ELEMENT verify-columns (#PCDATA)>


<!--
By default, WebLogic RDBMS CMP only checks that an entity actually
exists in the underlying DBMS when it needs to read or write data.
This results in high performance and still provides a sufficient level
of checking for most applications.  Under this policy, for example, when
an application gets the value of a cmp-field for a bean that has been
removed, a NoSuchObjectException or NoSuchObjectLocalException is
thrown immediately, while an attempt to set the value of a cmp-field
without first getting it won't cause an exception to be thrown until
the new value is written to the DBMS; usually when the current transaction 
commits.

Some applications, however, may want to be notified as soon as any
business method is invoked on a CMP entity bean that has been removed.
This is the highest level of checking that is possible.  These
applications should set the check-exists-on-method element to 'True'.

The value of the check-exists-on-method element must be 'True' or 
'False'.

Note that the default value changed from 'False' to 'True' as of
WLS 8.1

Default value: True

Used in: weblogic-rdbms-bean

Example: 
    <check-exists-on-method>True</check-exists-on-method>

Since: WLS 7.0

-->
<!ELEMENT check-exists-on-method (#PCDATA)>


<!--
The name of the bean.  The contents of this element must match the ejb-name
element of a cmp entity  bean contained in the ejb-jar.xml descriptor file.

Used in: weblogic-rdbms-bean

Example:
    <ejb-name>EmployeeEJB</ejb-name>
-->
<!ELEMENT ejb-name (#PCDATA)>


<!--
The JNDI name of the WebLogic TxDataSource which should be used for all
database connectivity for this particular bean. This TxDataSource must
be defined in the standard way for WebLogic JDBC TxDataSources. If you
do not know how to do this please consult the WebLogic Server
Documentation.

Used in: weblogic-rdbms-bean

Example:
    <data-source-name>financeDB</data-source-name>
-->
<!ELEMENT data-source-name (#PCDATA)>


<!--
The fully qualified SQL name of the source table in the database. Note
that this needs to be set in all cases. The user defined for the data
source for this bean must have read and write privileges on this
table, though not necessarily schema modification privileges.

Used in: table-map, weblogic-rdbms-relation

Example:
    <table-name>ACCOUNT</table-name>
    <table-name>ACCOUNTING_SCHEMA.ACCOUNT</table-name>
    <table-name>"SELECT".ACCOUNT</table-name>
    <table-name>"ACCOUNT"</table-name>

-->
<!ELEMENT table-name (#PCDATA)>


<!--
The field-map element represents a mapping between a particular column
in a database and a cmp field in the bean instance.

The group-name element specifies a field group that is to be loaded
when the getXXX method for the cmp-field is called and the EJB
container needs to read the value from the DBMS because it isn't in
memory.  If group-name is omitted, the default group, which contains
all cmp-fields, is used when the cmp-field is not explicitly listed in
any field groups, otherwise a field group that contains the cmp-field
is chosen.  Thus, developers should specify a group-name if the
cmp-field is listed in multiple field groups or the container will
pick one of the groups arbitrarily.

Used in: table-map

Example:
    <field-map>
        <cmp-field>accountID</cmp-field>
        <dbms-column>ACCOUNT_NUMBER</dbms-column>
    </field-map>
-->
<!ELEMENT field-map (
    cmp-field,
    dbms-column,
    dbms-column-type?,
    group-name?
)>


<!--
The field in the bean instance which should be populated from the database.
This field is case sensitive and must precisely match the name of the
field in the bean instance. The field referenced in this element must have
a cmp-field entry in the ejb-jar.xml file.

Used in: field-map, field-group

Example:
    <cmp-field>balance</cmp-field>
-->
<!ELEMENT cmp-field (#PCDATA)>


<!--
The database column to which the given field should be mapped.
This element is case maintaining, though not all databases are
case sensitive.

Used in: field-map

Example:
    <dbms-column>BALANCE</dbms-column>
-->
<!ELEMENT dbms-column (#PCDATA)>


<!--
The optimistic-column element is used to denote a database column that
contains a version or timestamp value used to implement optimistic
concurrency.  This element is case maintaining, though not all
databases are case sensitive.  The value of this element is ignored
unless verify-columns has a value of 'Version' or 'Timestamp.

Used in: table-map

Since: WLS 7.0

Example:
    <optimistic-column>ROW_VERSION</optimistic-column>
-->
<!ELEMENT optimistic-column (#PCDATA)>


<!--
The dbms-column-type can be OracleBlob,OracleClob,NClob,LongString or SybaseBinary.
OracleBlob or OracleClob will map the current field to a Blob or Clob in Oracle database.
NClob will map the current field to a NClob in Oracle database.
LongString tells the container to use setCharacterStream to write String data into
the database. Some JDBC drivers have problems writing more than 4K of data using setString.
SybaseBinary tells the container to use setBytes to write bytes into the binary column as 
setBinaryStream does not work with SybaseXADriver.
Used in: field-map

Since: WLS 6.1

Example:
    <dbms-column-type>OracleBlob</dbms-column-type>
-->
<!ELEMENT dbms-column-type (#PCDATA)>

<!-- 
The column-map element represents a mapping from a foreign key
column in one table in the database to a corresponding primary key
column.  The two columns may or may not be in the same table.  The
tables to which the column belong are implicit from the context in
which the column-map element appears in the deployment descriptor.

Used in: relationship-role-map

Example:
    <column-map>
      <foreign-key-column>manager-id</foreign-key-column>
      <key-column>id</key-column>
    </column-map>
-->
<!ELEMENT column-map (foreign-key-column, key-column)>


<!-- 
The foreign-key-column element represents a column of a foreign key
in the database.

Used in: column-map

Example:
    <foreign-key-column>manager-id</foreign-key-column>
-->
<!ELEMENT foreign-key-column (#PCDATA)>


<!-- 
The key-column element represents a column of a primary key
in the database.

Used in: column-map

Example:
    <key-column>id</key-column>
-->
<!ELEMENT key-column (#PCDATA)>


<!-- 
The weblogic-rdbms-relation element represents a single relationship
that is managed by the WebLogic CMP persistence type.  Three basic
types of relationship mappings are supported; one for one-to-one,
one-to-many, and many-to-many relationships.  Each is described below.

For one-to-one relationships, the mapping is from a foreign key in one
bean to the primary key of the other.  For example, a relationship
mapping between an Employee bean and another Employee bean that is
his/her manager would look something like this:

    <weblogic-rdbms-relation>
        <relation-name>employee-manager</relation-name>
        <weblogic-relationship-role>
            <relationship-role-name>employee</relationship-role-name>
            <relationship-role-map>
              <column-map>
                  <foreign-key-column>manager-id</foreign-key-column>
                  <key-column>id</key-column>
              </column-map>
            </relationship-role-map>
        </weblogic-relationship-role>
    </weblogic-rdbms-relation>

The example above says that there is a foreign key column 'manager-id'
in the table to which the bean on the employee side of the
relationship is mapped.  And also that this foreign key column refers
to the primary key column 'id' in the table to which the bean on the
manager side of the relationship is mapped.  This information would be
the same whether the relationship is bi-directional or not.  If either
of the beans in the relationship is mapped to multiple tables, then
the table for that bean that contains the foreign key or primary key
must also be specified in the relationship-role-map.

For one-to-many relationships, the mapping is also always from a
foreign key in one bean to the primary key of another. In a
one-to-many relation, the foreign key is always associated with the
bean that is on the many side of the relation.  Thus, the
specification of the relationship-role-name below is a bit redundant,
but is included for uniformity.  Here's an example of a mapping for a
relation between employees and departments that is one-to-many:

    <weblogic-rdbms-relation>
        <relation-name>employee-department</relation-name>
        <weblogic-relationship-role>
            <relationship-role-name>employee</relationship-role-name>
            <relationship-role-map>
              <column-map>
                  <foreign-key-column>dept-id</foreign-key-column>
                  <key-column>id</key-column>
              </column-map>
            </relationship-role-map>
        </weblogic-relationship-role>
    </weblogic-rdbms-relation>

For many-to-many relations, the mapping involves a join table.  Each
row in the join table contains two foreign keys that map to the
primary keys of the entities involved in the relation.  A many-to-many
relationship called 'friends' between employees could be represented like
this:

    <weblogic-rdbms-relation>
        <relation-name>friends</relation-name>
        <table-name>FRIENDS</table-name>
        <weblogic-relationship-role>
            <relationship-role-name>first-friend</relationship-role-name>
            <relationship-role-map>
              <column-map>
                  <foreign-key-column>first-friend-id</foreign-key-column>
                  <key-column>id</key-column>
              </column-map>
            </relationship-role-map>
        </weblogic-relationship-role>
        <weblogic-relationship-role>
            <relationship-role-name>second-friend</relationship-role-name>
            <relationship-role-map>
              <column-map>
                  <foreign-key-column>second-friend-id</foreign-key-column>
                  <key-column>id</key-column>
              </column-map>
            <relationship-role-map>
        </weblogic-relationship-role>
    </weblogic-rdbms-relation>

In the example above, the FRIENDS join table has two columns,
'first-friend-id' and 'second-friend-id'.  Each column contains a
foreign key that designates a particular employee who is a friend of
another employee.  The primary key column of the employee table is
'id'.  The example assumes that the employee bean is mapped to a
single table.  If employee bean is mapped to multiple tables, then the
table containing the primary key column must be specified in the
relation-role-map.

Used in: weblogic-rdbms-jar
-->
<!ELEMENT weblogic-rdbms-relation (
    relation-name,
    table-name?,
    weblogic-relationship-role,
    weblogic-relationship-role?  
)>


<!--
The name of a relation.  

When an ejb-relation-name is specified in the ejb-jar.xml descriptor
file, the relation-name must match the ejb-relation-name.

Otherwise, the default relation name should be used.  The default
relation name is formed by concatenating the default role names for a
relationship together, separated by a '-'.  The default role names
must appear in alphabetical order in a default relation name.  For
example, if the role names were 'CustomerEJB.account' and
'AccountEJB.customer', the relation-name would be
'AccountEJB.customer-CustomerEJB.account'.

Used in: weblogic-rdbms-relation

Since: Default relation names added in WLS 6.1, SP2.

Example: 
    <relation-name>employee-manager</relation-name>
-->
<!ELEMENT relation-name (#PCDATA)>


<!--
The <relationship-role-map> element is used to specify
<foreign-key-column> to <key-column> mappings for beans involved in a
relationship.

A CMP bean that is involved in a relationship may be mapped to
multiple DBMS tables (see the <table-map> element for more details).
If the bean on the foreign-key side of a 1-1 or 1-m relationship is
mapped to multiple tables then the name of the table containing the
foreign-key columns must be specified using the <foreign-key-table>
element.  

Conversely, if the bean on the primary-key side of a 1-1 or 1-m
relationship or a bean participating in a m-n relationship is mapped
to multiple tables then the name of the table containing the
primary-key must be specified using the <primary-key-table> element.

If neither of the beans in a relationship is mapped to multiple
tables, then the <foreign-key-table> and <primary-key-table> elements
may be ommitted since the tables being used are implicit.

Example 1:
 
The bean on the foreign-key side of a 1-1 relationship, Fk_Bean, is
mapped to multiple tables.  The table that holds the foreign-key
columns must be specified by the <foreign-key-table> element.

Fk_Bean, is mapped to two tables: Fk_BeanTable_1 and Fk_BeanTable_2.
The foreign-key columns for the relationship are located in table
Fk_BeanTable_2.  The foreign-key columns are named Fk_column_1 and
Fk_column_2.  The bean on the primary-key side, Pk_Bean, is mapped to
a single table with primary-key columns Pk_table_pkColumn_1 and
Pk_table_pkColumn_2.
   
   <relationship-role-map>
     <foreign-key-table>Fk_BeanTable_2</foreign-key-table>
     <column-map>
       <foreign-key-column>Fk_column_1</foreign-key-column>
       <key-column>Pk_table_pkColumn_1</key-column>
     </column-map>
     <column-map>
       <foreign-key-column>Fk_column_2</foreign-key-column>
       <key-column>Pk_table_pkColumn_2</key-column>
     </column-map>
   </table-column-map>

The <foreign-key-table> must be specified above, so that the container
can know which table contains the foreign-key columns.


Example 2:

The bean on the primary-key side of a 1-1 relationship, Pk_bean, is
mapped to multiple tables, but the bean on the foreign-key side of the
relationship, Fk_Bean, is mapped to one table, Fk_BeanTable.  The
foreign-key columns are named Fk_column_1 and Fk_column_2.

Pk_bean, is mapped to tables: Pk_BeanTable_1 with primary-key
columns: Pk_table1_pkColumn_1 and Pk_table1_pkColumn_2 and
Pk_BeanTable_2 with primary-key columns: Pk_table2_pkColumn_1 and
Pk_table2_pkColumn_2.

   <relationship-role-map>
     <primary-key-table>Pk_BeanTable_1</primary-key-table>
     <column-map>
       <foreign-key-column>Fk_column_1</foreign-key-column>
       <key-column>Pk_table1_pkColumn_1</key-column>
     </column-map>
     <column-map>
       <foreign-key-column>Fk_column_2</foreign-key-column>
       <key-column>Pk_table1_pkColumn_2</key-column>
     </column-map>
   </relationship-role-map>


Used-in: weblogic-relationship-role

Since: WLS 7.0
-->
<!ELEMENT relationship-role-map (
    foreign-key-table?,
    primary-key-table?,
    column-map+
)>


<!--
The name of a DBMS table that contains a foreign-key.

Used in: relationship-role-map

Since: WLS 7.0
-->
<!ELEMENT foreign-key-table (#PCDATA)>


<!--
The name of a DBMS table that contains a primary-key.

Used in: relationship-role-map

Since: WLS 7.0
-->
<!ELEMENT primary-key-table (#PCDATA)>


<!--
The weblogic-relationship-role element contains information related to
the mapping of a ejb-relationship-role to a DBMS schema.  The
<relationship-role-name> subelement must match the name of an
ejb-relationship-role in the ejb-jar.xml descriptor.

The relationship-role-map subelement specifies the mapping between a
foreign-key and a primary-key. For a 1-1 or 1-n relationship, only the
role on the foreign-key side of the relationship specifies a mapping.
Both roles specify a mapping for a m-n relationship.

A group-name may be specified to indicate the field-group that should
be loaded when the bean corresponding to the role is loaded as a
result of traversing the relationship, i.e. calling a cmr gettXXX
method.

See the db-cascade-delete element for more details regarding that option.

Used in: weblogic-rdbms-relation

Example: 
    (see weblogic-rdbms-relation)
-->
<!ELEMENT weblogic-relationship-role (
    relationship-role-name,
    group-name?,
    relationship-role-map?,
    db-cascade-delete?
)>


<!-- 
The name of a relationship role.  

If an ejb-relationship-role-name is specified in the ejb-jar.xml
descriptor file for the role, then the relationship-role-name must
match the ejb-relationship-role-name.

Otherwise, the default name for the role should be used.  The default
name for a relationship role is formed by concatenating the ejb-name
of the bean participating in the role together with the
cmr-field-name, if there is one, separated by a '.' character.

For example, if the bean 'CustomerEJB' has cmr-field 'account', then
the default role name would be CustomerEJB.account.  If there is no
cmr-field-name, then just the ejb-name is used.

Used in: weblogic-relationship-role

Since: Default relationship role names added in WLS 6.1, SP2.

Example: 
    <relationship-role-name>employee</relationship-role-name>
-->
<!ELEMENT relationship-role-name (#PCDATA)>


<!--
The db-cascade-delete tag specifies that a cascade delete will use the
builtin cascade delete facilities of the underlying DBMS.
By default, this feature is turned off and the EJB container removes the
beans involved in a cascade delete by issuing an individual SQL DELETE
statement for each bean.

The purpose of the db-cascade-delete option is to allow an application to
take advantage of a database's builtin suppport for cascade delete, and
possibly improve performance.  If db-cascade-delete is not specified, it is
important not to enable any of the database's cascade delete functionality,
as this will produce incorrect results.

If db-cascade-delete tag is specified in the weblogic-cmp-rdbms-jar.xml, the
cascade-delete tag must be specified in the ejb-jar.xml.

When db-cascade-delete is enabled, additional database table setup is required.
For example, the following setup for the Oracle database table will cascade
delete all of the emps if the dept is deleted in the database.
  CREATE TABLE dept
    (deptno   NUMBER(2) CONSTRAINT pk_dept PRIMARY KEY,
     dname    VARCHAR2(9) );
  CREATE TABLE emp
    (empno    NUMBER(4) PRIMARY KEY,
     ename    VARCHAR2(10),
     deptno   NUMBER(2)   CONSTRAINT fk_deptno
              REFERENCES dept(deptno)
              ON DELETE CASCADE );

Used in: weblogic-relationship-role

Since: WLS 6.1  

Example:
    <db-cascade-delete/>
-->
<!ELEMENT db-cascade-delete EMPTY>


<!-- 
A field-group represents a subset of the cmp and cmr-fields of a bean.
Related fields in a bean can be put into groups which are faulted
into memory together as a unit.  A group can be associated with a
query or relationship, so that when a bean is loaded as the
result of executing a query or following a relationship, only the
fields mentioned in the group are loaded.

A special group named 'default' is used for queries and relationships
that have no group specified.  By default, the 'default' group contains
all of a bean's cmp-fields and any cmr-fields that add a foreign key to the
persistent state of the bean.

A field may belong to multiple groups.  In this case, the getXXX() method
for the field will fault in the first group (lexically speaking) that 
contains the field.

Used in: weblogic-rdbms-bean

-->
<!ELEMENT field-group (
    group-name,
    (cmp-field | cmr-field)+
)>

         
<!--
The name of a cmr-field.  The field referenced in this element must have
a matching cmr-field entry in the ejb-jar.xml file.

Used in: field-group, caching-element

Example:
    <cmr-field>employee</cmr-field>
-->
<!ELEMENT cmr-field (#PCDATA)>


<!--
The name of a field group.

Used in: field-group, caching-element, weblogic-query, field-map,
	 weblogic-relationship-role

Examples:
    <group-name>financial-data</group-name>
    <group-name>medical-data</group-name>
-->
<!ELEMENT group-name (#PCDATA)>


<!--
The following tag is used in weblogic-rdbms-bean to specify
eager relationship caching.

Used in: weblogic-rdbms-bean

Since: WLS 7.0
-->
<!ELEMENT relationship-caching (
    caching-name,
    caching-element+
)>


<!--
The name of an eager relationship caching.

Used in: weblogic-query, relationship-caching

Since: WLS 7.0
-->
<!ELEMENT caching-name (#PCDATA)>


<!--
The following tag is used in relationship-caching to specify the cmr-field
for the related bean, and the group-name in the related bean.  If group-name
is not specified, the default group-name (load all fields) will be used.

Used in: relationship-caching

Since: WLS 7.0
-->
<!ELEMENT caching-element (
    cmr-field,
    group-name?,
    caching-element*
)>


<!-- 
The weblogic-query element provides a way to associate weblogic
specific attributes with a query when this is necessary.  For example,
the weblogic-query element can be used to specify a query that
contains a weblogic specific extension to the ejb-ql language.
Queries that do not need to take advantage of weblogic extensions to
ejb-ql should be specified in the standard ejb-jar.xml descriptor.

The weblogic-query element is also used to associate a field-group
with the query if the query is retrieving an entity bean(s) that
should be pre-loaded into the cache by the query.

Used in: weblogic-rdbms-bean

Example:
    <weblogic-query>
      <description>find all acounts balance is greater than 10000</description>
      <query-method>
        <method-name>findBigAccounts</method-name>
        <method-params>
          <method-param>double</method-param>
        </method-params>
      </query-method>
      <weblogic-ql>WHERE BALANCE>10000 ORDERBY NAME</weblogic-ql>
    </weblogic-query>
-->
<!ELEMENT weblogic-query (
    description?,
    query-method,
    weblogic-ql?,
    group-name?,
    caching-name?,
    max-elements?,
    include-updates?,
    sql-select-distinct?
)>


<!--
The description element is used to provide text describing the parent element.

Used in: weblogic-query
-->
<!ELEMENT description (#PCDATA)>


<!--
The weblogic-ql tag is used to specify a query that contains weblogic
specific extensions to the ejb-ql language.  Queries that only use
standard ejb-ql language features should be specified in the
ejb-jar.xml deployment descriptor.

Used in: weblogic-query

Example:
    <weblogic-ql>WHERE BALANCE>10000 ORDERBY NAME</weblogic-ql>
-->
<!ELEMENT weblogic-ql (#PCDATA)>


<!--
The method-name tag is used to specify the name of a finder or
ejbSelect method.  The '*' character may not be used as a wildcard.

Used in: query-method

Example:
    <method-name>findByBalance</method-name>
    <method-name>ejbSelectOverdueAccounts</method-name>
-->
<!ELEMENT method-name (#PCDATA)>


<!--
The method-param element contains the fully-qualified Java type
name of a method parameter.

Used in: method-params

Example:
    <method-param>java.lang.String</method-param>
-->
<!ELEMENT method-param (#PCDATA)>


<!--
The method-params element contains an ordered list of the
fully-qualified Java type names of the method parameters.

Used in: query-method

Example:
    <method-params>
      <method-param>java.lang.String</method-param>
      <method-param>java.lang.Integer</method-param>
    </method-params>
-->
<!ELEMENT method-params (method-param*)>


<!-- 
The query-method element is used to specify the method that is associated
with a weblogic-query.  This tag uses the same format as the ejb-jar.xml
descriptor.

Used in: weblogic-query

Example:
    <query-method>
       <method-name>findBigAccounts</method-name>
       <method-params>
          <method-param>double</method-param>
       </method-params>
    <query-method>
-->
<!ELEMENT query-method (method-name, method-params)>


<!--
The max-elements tag is used to specify the maximum number of
elements that should be returned by a multi-valued query.  This
option is similar to the maxRows feature of JDBC.

Used in: weblogic-query

Since: WLS 6.0 SP1

Example:
    <max-elements>100</max-elements>
-->
<!ELEMENT max-elements (#PCDATA)>


<!--
The value of the include-updates element must be 'True' or 'False'.

The include-updates tag is used to specify that updates made during
the current transaction must be reflected in the result of a query.
If include-updates is set to 'True', the container will flush all
changes made by the current transaction to the database before executing 
the query.

The default value is 'False' for beans that use optimistic concurrency.
The default for beans that use other concurrrency types, such as database,
or exclusive, is 'True'.  

Prior to WLS 8.1 the default was 'False for all beans.

Used in: weblogic-query

Since: WLS 6.1

Example:
    <include-updates>False</include-updates>
-->
<!ELEMENT include-updates (#PCDATA)>


<!--
The value of the sql-select-distinct element must be 'True' or 'False'.

This element is deprecated. The container will automatically filter duplicates
if necessary. If set to false and the weblogic-ql in the finder query contains
the 'DISTINCT' clause, this element will be ignored.

The sql-select-distinct tag is used to control whether the generated
SQL 'SELECT' will contain a 'DISTINCT' qualifier.  Use of the DISTINCT 
qualifier will cause the RDBMS to return unique rows.  

Note:   ORACLE will not allow the use of 'SELECT DISTINCT' in conjuction
        with a 'FOR UPDATE' clause, thus, <sql-select-distinct>True
        CANNOT be used if any Bean in the calling chain has a method with 
        <transaction-isolation> set to 
        <isolation-level>TransactionReadCommittedForUpdate
        or if use-select-for update is set to true

The default value is 'False'.

Used in: weblogic-query

Since: WLS 6.1SP02

Example:
    <sql-select-distinct>True</sql-select-distinct>
-->
<!ELEMENT sql-select-distinct (#PCDATA)>


<!--
This optional tag is used to install the Automatic Sequence/Key 
Generation facility

Used in: weblogic-rdbms-bean

Example:
  <automatic-key-generation>
    <generator-type>Oracle</generator-type>
    <generator-name>test_sequence</generator-name>
    <key-cache-size>10</key-cache-size>
  </automatic-key-generation>

Example:
  <automatic-key-generation>
    <generator-type>SQLServer</generator-type>
  </automatic-key-generation>

Example:
  <automatic-key-generation>
    <generator-type>SQLServer2000</generator-type>
  </automatic-key-generation>

Notes: SQLServer2000 option is same as SQLServer, except that
SQLServer uses @@IDENTITY column to get the generated key value and
SQLServer2000 uses SCOPE_IDENTITY() function instead. 

Example:
  <automatic-key-generation>
    <generator-type>NamedSequenceTable</generator-type>
    <generator-name>MY_SEQUENCE_TABLE_NAME</generator-name>
    <key-cache-size>100</key-cache-size>
  </automatic-key-generation>

Notes: This feature is intended for use with Simple (non-Compound)
       Primary Keys.

       The Primary Key cmp-field must be of type:
          java.lang.Integer
          java.lang.Long

-->
<!ELEMENT automatic-key-generation (
    generator-type,
    generator-name?,
    key-cache-size?,
    select-first-sequence-key-before-update?
)>


<!--
Specifies the Key Generation Method that will be employed
  'Oracle'               - use Oracle's SEQUENCE
  'DB2'                  - use DB2's SEQUENCE
  'Informix              - use Informix's SEQUENCE
  'SQLServer'            - use SQL SERVER's IDENTITY column
  'SQLServer2000'        - use SQL SERVER-2000's SCOPE_IDENTITY() column
  'NamedSequenceTable'   - use USER designated SEQUENCE TABLE
                               User specifies the name of a DBMS Table
                               with the schema (sequence INT)
                               which will be used to hold sequence values

Used in: automatic-key-generation

Since: WLS 6.1    

Support for keys of type java.lang.Long  Since: WLS6.1 SP03   WLS 7.0 SP01

-->
<!ELEMENT generator-type (#PCDATA)>


<!--
If this is DBMS Key Generation, 
Then this may be used to specify the Name of the Generator,
  e.g. for <generator-type>Oracle
           <generator-name> would be the name of the ORACLE SEQUENCE to use.
                            the SEQUENCE is assumed to already exist 
                            in the Database.

If this is <generator-type>NamedSequenceTable Key Generation,
Then this would be used to specify the name of the SEQUENCE TABLE to use.
 the NamedSequenceTable is assumed to already exist in the Database
 with 1 row.

Used in: automatic-key-generation

Since: WLS 6.1
-->
<!ELEMENT generator-name (#PCDATA)>


<!--
Optional size of key cache.
For <generator-type>Oracle , this value MUST match the
  Oracle SEQUENCE  INCREMENT value.  If there is a mismatch
  between this value and the Oracle SEQUENCE INCREMENT value,
  then there will likely be duplicate key problems.

For <generator-type>NamedSequenceTable , this tells how many keys
  the Container will fetch in a single DBMS call

For <generator-type>SQLServer, this value is ignored

Since: WLS 6.1

Used in: automatic-key-generation
-->
<!ELEMENT key-cache-size (#PCDATA)>

<!--
This would be used to specify the behaviour of automatic primary key 
generation.

By default, the select-first-sequence-key-before-update is set to false,
and when the EJB container needs to fetch the sequence value from a 
database, first it updates the value in the sequence table with the 
current value + the key-cache-size, and then fetch the value from the 
sequence table, and generates the primary key with the fetched value.
For example, when the current value in the sequence table is 100 and the
key-cache-size is 100, the EJB container updates the value in the table
with 200 (the current value + the key-cache-size), and then generates the
primary key with 200. It means that the EJB container reserves the 
sequence values from 200 to 299 and will generate primary key from 200 
to 299 before accessing to a database next.

If the select-first-sequence-key-before-update is set to true, and when 
the EJB container needs to fetch the sequence value from a database, 
it generates the primary key from the current value + 1 in the sequence 
table, and updates the value in the table with the current value + the 
key-cache-size. For example, when the current value in the sequence table
is 100 and the key-cache-size is 100, the EJB container generates the
primary key with 101 (the current value + 1 in the table), and updates 
the value in the table with 200 (the current value + the key-cache-size).
It means that the EJB container reserves the sequence values from 101 
to 200 and will generate primary key from 101 to 200 before accessing to
a database next.

This tag is only used when the genarator-type is NamedSequenceTable. 

Default value: false

Since: WLS 8.1 SP4

Used in: automatic-key-generation
-->
<!ELEMENT select-first-sequence-key-before-update (#PCDATA)>

<!-- 
The delay-database-insert-until element is used to specify the
precise time at which a new bean that uses RDBMS CMP is inserted into
the database.  This tag is only used when order-database-operations
is false.  By default, order-database-operations is set to true, and
all of the beans are inserted at the transaction commit time.  When
order-database-operations is set to false, the database insert is done
after ejbPostCreate by default.

Delaying the database insert until after ejbPostCreate is required
when a cmr-field is mapped to a foreign-key column that doesn't allow
null values.  In this case, the cmr-field must be set to a non-null
value in ejbPostCreate before the bean is inserted into the database.
Note that cmr-fields may not be set during ejbCreate, before the
primary key of the bean is known.

It is also generally advisable to delay the database insert until
after ejbPostCreate if the ejbPostCreate method modifies the
persistent fields of the bean.  This can yield better performance by
avoiding an unnecessary store operation.

For maximum flexibility, developers should avoid creating related
beans in their ejbPostCreate method.  This may make delaying the
database insert impossible if database constraints prevent related
beans from referring to a bean that has not yet been created.

Allowed values:
     ejbCreate - perform database insert immediately after ejbCreate
     ejbPostCreate - perform insert immediately after ejbPostCreate
     commit - perform bulk insert at transaction commit,
              The "commit" option is replaced by
              <enable-batch-operations> tag in <weblogic-rdbms-jar>.

Default: ejbPostCreate

Used in: weblogic-rdbms-bean

Since: WLS 6.0 SP1, 'commit' option added in WLS 7.0 and removed in WLS 8.1

Example:
    <delay-database-insert-until>
      ejbPostCreate
    </delay-database-insert-until>
-->
<!ELEMENT delay-database-insert-until (#PCDATA)>


<!--
Specifying "true" for this flag will cause SELECT ... FOR UPDATE
to be used whenever the bean is loaded from the database. This is
is different from the transaction isolation level of 
TransactionReadCommittedForUpdate in that this is set at the bean
level as opposed to at the transaction level. 

For MS SQLServer 2000, the WITH(UPDLOCK) clause is used.

For Sybase, the HOLDLOCK clause is used.

Sybase Limitation: There is no simple way to obtain exclusive locks
      during reads in Sybase. With the HOLDLOCK clause, The lock is
      still a shared lock, but is held till the end of the transaction.
      It prevents other transactions from obtaining exclusive locks,
      but does not prevent them from obtaining shared locks. If two or
      more transactions obtain shared locks and then try to obtain
      exclusive locks concurrently, deadlocks may occur.

Valid values are "true", "True", "false" or "False"

Default: False

Used in: weblogic-rdbms-bean

Since: WLS 7.0 SP1, MS SQLServer since 8.1, Sybase since 8.1 SP2
-->
<!ELEMENT use-select-for-update (#PCDATA)>


<!--
The lock-order element is used to specify the locking order among
different EJBs during a cascade delete operation or when using the 
<use-select-for-update> flag.  Use of lock-order may be necessary to avoid 
deadlocks.  The EJB with the lowest number specified for lock-order will be 
processed first, the EJB with the second lowest will be processed second, etc.

Note that the lock-order element is used to order processing at the
EJB granularity; between AccountEJB and CustomerEJB, for example.
Typically the EJBs are related via a relationship that specifies
cascade delete.  Lock-order can be used to avoid deadlocks when an
application encounters deadlocks that include beans involved in a
cascade delete operation.  The locking order specified should be the
same as that being used by other transactions in the application.

Pre 81sp2, this flag was only used for cascade delete.
Since 81sp2, this flag can also be used along with <use-select-for-update>
feature for relationship-caching with the Oracle database. The lock-order 
would be used to determine the order of the tables in the SELECT ... FOR 
UPDATE OF clause if not all of the beans in the caching-element have 
use-select-for-update turned on.

Valid values are all non-negative integers.

Default: 0

Used in: weblogic-rdbms-bean

Since: WLS 7.0 SP3
-->
<!ELEMENT lock-order (#PCDATA)>


<!--
The instance-lock-order element specifies a locking, or processing,
order for instances of a particular EJB.  Instance-lock-order can be
used to prevent deadlocks in an application that would otherwise
experience deadlocks.  Instance-lock-order is used whenever database
operations (update, for example) that apply to multiple instances of
the same EJB are performed by the container.  It specifies an order for
operations that can cause a database lock to be acquired for a bean
instance.

For example, instance-lock-order could be used to specify the order in
which the EJB container calls ejbStore for instances of a particular EJB
that uses database concurrency; ejbStore may acquire an exclusive
lock when a database update is done.  Instance-lock-order also
controls the order in which beans using optimistic concurrency are
locked when optimistic checking is performed.

Valid values for instance-lock-order are 'AccessOrder' and
'ValueOrder'.
 
When AccessOrder is specified the container will process beans so
that locks are acquired(upgraded) in the order in which the
application originally accessed the beans during the transaction.
This is the recommended value when all transactions in the system
access instances of the bean, and ultimately rows in a database table,
in the same order.

When ValueOrder is specified beans are processed in order based on
the value of their primary key. ValueOrder should be specified to avoid
deadlocks when concurrent transactions access instances of the same
EJB in different orders.

NOTE: The EJB's primary key class is not required to implement the
java.lang.Comparable interface, when ValueOrder is specified,
although this will result in a total ordering.  Beans are ordered
partially using the hashcode value of the primary key when the primary
key does not implement java.lang.Comparable.

Default value: AccessOrder

Used in: weblogic-rdbms-bean

Since: WLS 8.1 SP1
-->
<!ELEMENT instance-lock-order (#PCDATA)>


<!--
This flag is used for EJB container to delay all of the database operations
in a transaction until the commit time, automatically sort the database
dependency between the operations, and send these operations to database in
such a way to avoid any database constrain errors.  (Such as FK constrain).
The container does not maintain ordering of database operations within a
transaction for beans that have no relationships declared in the deployment
descriptor.

To turn off order-database-operations, both order-database-operations and
enable-batch-operations has to set to "false".

Valid values are "true", "True", "false" or "False"

Default: true

Used in: weblogic-rdbms-jar

Since: WLS 8.1
-->
<!ELEMENT order-database-operations (#PCDATA)>


<!--
This flag is used for EJB container to perform batch operations.
If this tag is set to true, the order-database-operations will be set
to true automatically, and EJB container will delay all of the database
operations in a transaction until the commit time.

Valid values are "true", "True", "false" or "False"

Default: true

Used in: weblogic-rdbms-jar

Since: WLS 8.1
-->
<!ELEMENT enable-batch-operations (#PCDATA)>


<!--
The value of create-default-dbms-tables may be "CreateOnly","Disabled",
"DropAndCreate","DropAndCreateAlways" or "AlterOrCreate".

The default value of create-default-dbms-tables is "Disabled"

When this parameter is "CreateOnly", the following will occur:

For each CMP Bean listed in the jar, at Deployment time, if there is
no Table in the Database for the Bean, the Container will attempt to
CREATE the Table based on information found in the deployment files
and in the Bean Class.  If TABLE CREATION fails, a 'Table Not Found'
Error will be thrown, and the TABLE must be created by hand.

For Oracle sequences, if there is no sequence in the Database, the
Container will attempt to CREATE the sequence based on information
found in the deployment descriptor.  If sequence CREATION fails, an Error
will be thrown, and the sequence must be created by hand.
If the sequence is in the database but its INCREMENT value does
not match the value specified by the key-cache-size element of the
automatic-key-generation element, then an Error will be thrown.

When the value is "DropAndCreate" :

For each CMP Bean listed in the jar , at Deployment time , if the 
table schema has changed , the Container will attempt to drop the existing
table and CREATE the table based on the information found in deployment
descriptor.

NOTE: For Oracle sequences, this option behaves the same as the
option 'AlterOrCreate'.

When the value is "DropAndCreateAlways" :

For each CMP Bean listed in the jar , at Deployment time ,
the Container will attempt to drop the existing table and CREATE the 
table based on the information found in deployment descriptor.

NOTE: For Oracle sequences, this option behaves the same as the
option 'AlterOrCreate'.


When the value is "AlterOrCreate" :

For each CMP Bean listed in the jar , at Deployment time ,
the container will attempt to alter the table schema using "ALTER TABLE"
SQL command. 

For Oracle sequences, if the sequence INCREMENT value in the database
is different from the value specified by the key-cache-size element of the
automatic-key-generation element, then the Container will attempt to 
alter the value of the INCREMENT using the Oracle "ALTER SEQUENCE" command.
Use of ALTER SEQUENCE maintains the current value of the sequence.


Notes on Oracle sequence handling.

      create-default-dbms-tables may
      CREATE or ALTER a sequence but will never DROP a 
      sequence.  This is to avoid inadvertent duplicate key
      errors caused by resetting of sequence values without
      a corresponding recreation of a table that is using
      the sequence for automatic-key-generation.

      An Oracle sequence that is created by the container
      on behalf of the create-default-dbms-tables options 
      is named differently than that specified by the 
      <automatic-key-generation> <generator-name> element.  
      The name of the created sequence has '_WL' appended to the 
      end of the <generator-name>.
      This is to distinguish a container created sequence from
      a non-container created sequence.

      In development systems, at deployment time, the container will 
      always check for the existence of a sequence named as specified
      in <generator-name> first.  If this sequence exists, then the 
      container will use this sequence.  If this sequence does not exist, 
      then the container will use the sequence name <generator-name> + '_WL'.


      At deployment time the following conditions are distinguished:
         production_not_exists       : <generator-name> not exists 

         production_exists_OK        : <generator-name> exists 
                                         with INCREMENT to match <key-cache-size>

         production_exists_mismatch  : <generator-name> exists 
                                         INCREMENT doesn't match <key-cache-size>

         development_not_exists      : <generator-name> + '_WL' not exists

         development_exists_OK       : <generator-name> + '_WL' exists with 
                                         INCREMENT to match <key-cache-size>

         development_exists_mismatch : <generator-name> + '_WL' exists 
                                         INCREMENT doesn't match <key-cache-size>


      The following actions are taken  
      in development systems based on the value of create-default-dbms-tables:

      When this parameter is "Disabled" :
        production_not_exists 
          and development_not_exists :  deployment aborts
        production_exists_OK         :  deployment proceeds
        production_exists_mismatch   :  deployment aborts
        development_exists_OK        :  deployment proceeds
        development_exists_mismatch  :  deployment aborts

      When this parameter is "CreateOnly" : 
        production_not_exists 
          and development_not_exists :  create new sequence <generator-name> + '_WL'
        production_exists_OK         :  deployment proceeds
        production_exists_mismatch   :  deployment aborts
        development_exists_OK        :  deployment proceeds
        development_exists_mismatch  :  deployment aborts

      When the value is "DropAndCreate" :
        same behavior as "AlterOrCreate"

      When the value is "DropAndCreateAlways" :
        same behavior as "AlterOrCreate"

      When the value is "AlterOrCreate" :
        production_not_exists 
          and development_not_exists :  create new sequence <generator-name> + '_WL'
        production_exists_OK         :  deployment proceeds
        production_exists_mismatch   :  deployment aborts
        development_exists_OK        :  deployment proceeds
        development_exists_mismatch  :  alter sequence <generator-name> + '_WL'
                                          increment value to match <key-cache-size>

end: Notes on Oracle sequence handling.
 

This feature is a convenience that is in effect only in non-production systems 
as the Table Schema in the DBMS CREATE used will be the Containers best approximation, 
a production enviroment may require a more precise schema definition.

Used in: weblogic-rdbms-jar

Support for Oracle sequences Since: WLS 8.1SP01
-->
<!ELEMENT create-default-dbms-tables (#PCDATA)>


<!--
The CMP subsystem checks that beans have been mapped to a valid
database schema at deployment time.  

The value of validate-db-schema-with may be 'MetaData' or
'TableQuery'.  A value of 'MetaData' means that JDBC metadata is used
to validate the schema.  A value of 'TableQuery' means that tables are
queried directly to ascertain that they have the schema expected by
the CMP runtime.

Example:
    <validate-db-schema-with>MetaData</validate-db-schema-with>

Used in: weblogic-rdbms-jar

Default: TableQuery

Since: WLS 6.1sp2
-->
<!ELEMENT validate-db-schema-with (#PCDATA)>


<!--
The following tag is used to specify the database type of the
underlying DBMS.

The database-type can be one of the following values:

  DB2
  Informix
  Oracle
  SQLServer
  SQLServer2000
  Sybase
  PointBase
  MySQL

Used in: weblogic-rdbms-jar

Since: WLS 7.0

SQLServer2000 Since: WLS 8.1sp1

-->
<!ELEMENT database-type (#PCDATA)>

<!--
The follwing tag is used to specify the ddl file name. 
The container will write the table creation scripts into this file.

Used in: weblogic-rdbms-jar

Since: WLS 8.1

-->
<!ELEMENT default-dbms-tables-ddl (#PCDATA)>


<!--
This element is used to specify the compatibility flags
for all the cmp beans described in this descriptor file

Used in: weblogic-rdbms-jar

Since: WLS 8.1sp2
-->
<!ELEMENT compatibility (
  serialize-byte-array-to-oracle-blob?,
  allow-readonly-create-and-remove?,
  load-related-beans-from-db-in-post-create?
)>


<!--
The following tag is used to specify whether a cmp-field of type byte[] mapped
to a OracleBlob should be serialized. By default, the value of the tag is 
false which means that the container will persist the byte[] directly and not 
serialize it.

Note that, in versions prior to 81sp2, the default behavior was to serialize a 
cmp-field of type byte[] mapped to an OracleBlob. To revert to the old 
behavior, set the value of this tag to true.

Default value: false

Used in: compatibility

Since: WLS 8.1sp2
-->
<!ELEMENT serialize-byte-array-to-oracle-blob (#PCDATA)>

<!--
This element is a backward compatibility flag.  It is used to enable create 
and remove operations for an EJB that uses ReadOnly concurrency.

Prior to version 8.1 SP2, these operations were allowed, although they
had no transactional meaning.  They have been disallowed so that more
efficient code can be generated for ReadOnly beans, and because using
them is a bad practice.

Default value: false

Used in: compatability

Since: WLS 8.1sp2
-->
<!ELEMENT allow-readonly-create-and-remove (#PCDATA)>

<!--
This element is a backward compatibility flag.  This flag is applicable
only for a one to many relation ship. 

This flag forces the container to load the related beans representing 'many' 
side of the relation ship from the data base even if the call to get those beans
is being made from the ejbPostCreate method of the bean representing the 'one' side.

By default, In the above scenario, the container will not load the 'many' 
side of the beans from the data base (since 8.1 SP6). This is based on the 
assumption that there cannot be any related beans representing 'many' side in the 
data base if the bean representing 'one' side is still under creation 
(ejbPostCreate stage)

Set this flag to 'true' to get the pre 8.1 SP6 behavior (to load the beans
from the data base).

Default value: false

Used in: compatability

Since: WLS 8.1sp6
-->
<!ELEMENT load-related-beans-from-db-in-post-create (#PCDATA)>




