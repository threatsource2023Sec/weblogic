import java.util.Arrays;
import org.python.compiler.APIVersion;
import org.python.compiler.Filename;
import org.python.compiler.MTime;
import org.python.core.CodeBootstrap;
import org.python.core.CodeLoader;
import org.python.core.Py;
import org.python.core.PyCode;
import org.python.core.PyDictionary;
import org.python.core.PyException;
import org.python.core.PyFrame;
import org.python.core.PyFunction;
import org.python.core.PyFunctionTable;
import org.python.core.PyList;
import org.python.core.PyObject;
import org.python.core.PyRunnable;
import org.python.core.PyRunnableBootstrap;
import org.python.core.PyString;
import org.python.core.PyTuple;
import org.python.core.ThreadState;
import org.python.core.imp;

@APIVersion(37)
@MTime(1498849383000L)
@Filename("ast.py")
public class ast$py extends PyFunctionTable implements PyRunnable {
   static ast$py self;
   static final PyCode f$0;
   static final PyCode parse$1;
   static final PyCode literal_eval$2;
   static final PyCode _convert$3;
   static final PyCode f$4;
   static final PyCode dump$5;
   static final PyCode _format$6;
   static final PyCode f$7;
   static final PyCode f$8;
   static final PyCode f$9;
   static final PyCode f$10;
   static final PyCode copy_location$11;
   static final PyCode fix_missing_locations$12;
   static final PyCode _fix$13;
   static final PyCode increment_lineno$14;
   static final PyCode iter_fields$15;
   static final PyCode iter_child_nodes$16;
   static final PyCode get_docstring$17;
   static final PyCode walk$18;
   static final PyCode NodeVisitor$19;
   static final PyCode visit$20;
   static final PyCode generic_visit$21;
   static final PyCode NodeTransformer$22;
   static final PyCode generic_visit$23;

   public PyObject f$0(PyFrame var1, ThreadState var2) {
      var1.setglobal("__doc__", PyString.fromInterned("\n    ast\n    ~~~\n\n    The `ast` module helps Python applications to process trees of the Python\n    abstract syntax grammar.  The abstract syntax itself might change with\n    each Python release; this module helps to find out programmatically what\n    the current grammar looks like and allows modifications of it.\n\n    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as\n    a flag to the `compile()` builtin function or by using the `parse()`\n    function from this module.  The result will be a tree of objects whose\n    classes all inherit from `ast.AST`.\n\n    A modified abstract syntax tree can be compiled into a Python code object\n    using the built-in `compile()` function.\n\n    Additionally various helper functions are provided that make working with\n    the trees simpler.  The main intention of the helper functions and this\n    module in general is to provide an easy to use interface for libraries\n    that work tightly with the python syntax (template engines for example).\n\n\n    :copyright: Copyright 2008 by Armin Ronacher.\n    :license: Python License.\n"));
      var1.setline(27);
      PyString.fromInterned("\n    ast\n    ~~~\n\n    The `ast` module helps Python applications to process trees of the Python\n    abstract syntax grammar.  The abstract syntax itself might change with\n    each Python release; this module helps to find out programmatically what\n    the current grammar looks like and allows modifications of it.\n\n    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as\n    a flag to the `compile()` builtin function or by using the `parse()`\n    function from this module.  The result will be a tree of objects whose\n    classes all inherit from `ast.AST`.\n\n    A modified abstract syntax tree can be compiled into a Python code object\n    using the built-in `compile()` function.\n\n    Additionally various helper functions are provided that make working with\n    the trees simpler.  The main intention of the helper functions and this\n    module in general is to provide an easy to use interface for libraries\n    that work tightly with the python syntax (template engines for example).\n\n\n    :copyright: Copyright 2008 by Armin Ronacher.\n    :license: Python License.\n");
      var1.setline(28);
      imp.importAll("_ast", var1, -1);
      var1.setline(29);
      String[] var3 = new String[]{"__version__"};
      PyObject[] var5 = imp.importFrom("_ast", var3, var1, -1);
      PyObject var4 = var5[0];
      var1.setlocal("__version__", var4);
      var4 = null;
      var1.setline(32);
      var5 = new PyObject[]{PyString.fromInterned("<unknown>"), PyString.fromInterned("exec")};
      PyFunction var6 = new PyFunction(var1.f_globals, var5, parse$1, PyString.fromInterned("\n    Parse the source into an AST node.\n    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).\n    "));
      var1.setlocal("parse", var6);
      var3 = null;
      var1.setline(40);
      var5 = Py.EmptyObjects;
      var6 = new PyFunction(var1.f_globals, var5, literal_eval$2, PyString.fromInterned("\n    Safely evaluate an expression node or a string containing a Python\n    expression.  The string or node provided may only consist of the following\n    Python literal structures: strings, numbers, tuples, lists, dicts, booleans,\n    and None.\n    "));
      var1.setlocal("literal_eval", var6);
      var3 = null;
      var1.setline(83);
      var5 = new PyObject[]{var1.getname("True"), var1.getname("False")};
      var6 = new PyFunction(var1.f_globals, var5, dump$5, PyString.fromInterned("\n    Return a formatted dump of the tree in *node*.  This is mainly useful for\n    debugging purposes.  The returned string will show the names and the values\n    for fields.  This makes the code impossible to evaluate, so if evaluation is\n    wanted *annotate_fields* must be set to False.  Attributes such as line\n    numbers and column offsets are not dumped by default.  If this is wanted,\n    *include_attributes* can be set to True.\n    "));
      var1.setlocal("dump", var6);
      var3 = null;
      var1.setline(113);
      var5 = Py.EmptyObjects;
      var6 = new PyFunction(var1.f_globals, var5, copy_location$11, PyString.fromInterned("\n    Copy source location (`lineno` and `col_offset` attributes) from\n    *old_node* to *new_node* if possible, and return *new_node*.\n    "));
      var1.setlocal("copy_location", var6);
      var3 = null;
      var1.setline(125);
      var5 = Py.EmptyObjects;
      var6 = new PyFunction(var1.f_globals, var5, fix_missing_locations$12, PyString.fromInterned("\n    When you compile a node tree with compile(), the compiler expects lineno and\n    col_offset attributes for every node that supports them.  This is rather\n    tedious to fill in for generated nodes, so this helper adds these attributes\n    recursively where not already set, by setting them to the values of the\n    parent node.  It works recursively starting at *node*.\n    "));
      var1.setlocal("fix_missing_locations", var6);
      var3 = null;
      var1.setline(150);
      var5 = new PyObject[]{Py.newInteger(1)};
      var6 = new PyFunction(var1.f_globals, var5, increment_lineno$14, PyString.fromInterned("\n    Increment the line number of each node in the tree starting at *node* by *n*.\n    This is useful to \"move code\" to a different location in a file.\n    "));
      var1.setlocal("increment_lineno", var6);
      var3 = null;
      var1.setline(161);
      var5 = Py.EmptyObjects;
      var6 = new PyFunction(var1.f_globals, var5, iter_fields$15, PyString.fromInterned("\n    Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``\n    that is present on *node*.\n    "));
      var1.setlocal("iter_fields", var6);
      var3 = null;
      var1.setline(173);
      var5 = Py.EmptyObjects;
      var6 = new PyFunction(var1.f_globals, var5, iter_child_nodes$16, PyString.fromInterned("\n    Yield all direct child nodes of *node*, that is, all fields that are nodes\n    and all items of fields that are lists of nodes.\n    "));
      var1.setlocal("iter_child_nodes", var6);
      var3 = null;
      var1.setline(187);
      var5 = new PyObject[]{var1.getname("True")};
      var6 = new PyFunction(var1.f_globals, var5, get_docstring$17, PyString.fromInterned("\n    Return the docstring for the given node or None if no docstring can\n    be found.  If the node provided does not have docstrings a TypeError\n    will be raised.\n    "));
      var1.setlocal("get_docstring", var6);
      var3 = null;
      var1.setline(203);
      var5 = Py.EmptyObjects;
      var6 = new PyFunction(var1.f_globals, var5, walk$18, PyString.fromInterned("\n    Recursively yield all descendant nodes in the tree starting at *node*\n    (including *node* itself), in no specified order.  This is useful if you\n    only want to modify nodes in place and don't care about the context.\n    "));
      var1.setlocal("walk", var6);
      var3 = null;
      var1.setline(217);
      var5 = new PyObject[]{var1.getname("object")};
      var4 = Py.makeClass("NodeVisitor", var5, NodeVisitor$19);
      var1.setlocal("NodeVisitor", var4);
      var4 = null;
      Arrays.fill(var5, (Object)null);
      var1.setline(254);
      var5 = new PyObject[]{var1.getname("NodeVisitor")};
      var4 = Py.makeClass("NodeTransformer", var5, NodeTransformer$22);
      var1.setlocal("NodeTransformer", var4);
      var4 = null;
      Arrays.fill(var5, (Object)null);
      var1.f_lasti = -1;
      return Py.None;
   }

   public PyObject parse$1(PyFrame var1, ThreadState var2) {
      var1.setline(36);
      PyString.fromInterned("\n    Parse the source into an AST node.\n    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).\n    ");
      var1.setline(37);
      PyObject var3 = var1.getglobal("compile").__call__(var2, var1.getlocal(0), var1.getlocal(1), var1.getlocal(2), var1.getglobal("PyCF_ONLY_AST"));
      var1.f_lasti = -1;
      return var3;
   }

   public PyObject literal_eval$2(PyFrame var1, ThreadState var2) {
      var1.setline(46);
      PyString.fromInterned("\n    Safely evaluate an expression node or a string containing a Python\n    expression.  The string or node provided may only consist of the following\n    Python literal structures: strings, numbers, tuples, lists, dicts, booleans,\n    and None.\n    ");
      var1.setline(47);
      PyDictionary var3 = new PyDictionary(new PyObject[]{PyString.fromInterned("None"), var1.getglobal("None"), PyString.fromInterned("True"), var1.getglobal("True"), PyString.fromInterned("False"), var1.getglobal("False")});
      var1.setderef(0, var3);
      var3 = null;
      var1.setline(48);
      PyObject[] var5;
      PyObject var6;
      if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("basestring")).__nonzero__()) {
         var1.setline(49);
         PyObject var10000 = var1.getglobal("parse");
         var5 = new PyObject[]{var1.getlocal(0), PyString.fromInterned("eval")};
         String[] var4 = new String[]{"mode"};
         var10000 = var10000.__call__(var2, var5, var4);
         var3 = null;
         var6 = var10000;
         var1.setlocal(0, var6);
         var3 = null;
      }

      var1.setline(50);
      if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("Expression")).__nonzero__()) {
         var1.setline(51);
         var6 = var1.getlocal(0).__getattr__("body");
         var1.setlocal(0, var6);
         var3 = null;
      }

      var1.setline(52);
      var5 = Py.EmptyObjects;
      PyObject var10002 = var1.f_globals;
      PyObject[] var10003 = var5;
      PyCode var10004 = _convert$3;
      var5 = new PyObject[]{var1.getclosure(1), var1.getclosure(0)};
      PyFunction var7 = new PyFunction(var10002, var10003, var10004, (PyObject)null, var5);
      var1.setderef(1, var7);
      var3 = null;
      var1.setline(80);
      var6 = var1.getderef(1).__call__(var2, var1.getlocal(0));
      var1.f_lasti = -1;
      return var6;
   }

   public PyObject _convert$3(PyFrame var1, ThreadState var2) {
      var1.setline(53);
      PyObject var3;
      if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("Str")).__nonzero__()) {
         var1.setline(54);
         var3 = var1.getlocal(0).__getattr__("s");
         var1.f_lasti = -1;
         return var3;
      } else {
         var1.setline(55);
         if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("Num")).__nonzero__()) {
            var1.setline(56);
            var3 = var1.getlocal(0).__getattr__("n");
            var1.f_lasti = -1;
            return var3;
         } else {
            var1.setline(57);
            if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("Tuple")).__nonzero__()) {
               var1.setline(58);
               var3 = var1.getglobal("tuple").__call__(var2, var1.getglobal("map").__call__(var2, var1.getderef(0), var1.getlocal(0).__getattr__("elts")));
               var1.f_lasti = -1;
               return var3;
            } else {
               var1.setline(59);
               if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("List")).__nonzero__()) {
                  var1.setline(60);
                  var3 = var1.getglobal("list").__call__(var2, var1.getglobal("map").__call__(var2, var1.getderef(0), var1.getlocal(0).__getattr__("elts")));
                  var1.f_lasti = -1;
                  return var3;
               } else {
                  var1.setline(61);
                  PyObject var10000;
                  if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("Dict")).__nonzero__()) {
                     var1.setline(62);
                     var10000 = var1.getglobal("dict");
                     var1.setline(62);
                     PyObject var10004 = var1.f_globals;
                     PyObject[] var7 = Py.EmptyObjects;
                     PyCode var10006 = f$4;
                     PyObject[] var5 = new PyObject[]{var1.getclosure(0)};
                     PyFunction var6 = new PyFunction(var10004, var7, var10006, (PyObject)null, var5);
                     PyObject var10002 = var6.__call__(var2, var1.getglobal("zip").__call__(var2, var1.getlocal(0).__getattr__("keys"), var1.getlocal(0).__getattr__("values")).__iter__());
                     Arrays.fill(var7, (Object)null);
                     var3 = var10000.__call__(var2, var10002);
                     var1.f_lasti = -1;
                     return var3;
                  } else {
                     var1.setline(64);
                     PyObject var4;
                     if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("Name")).__nonzero__()) {
                        var1.setline(65);
                        var4 = var1.getlocal(0).__getattr__("id");
                        var10000 = var4._in(var1.getderef(1));
                        var4 = null;
                        if (var10000.__nonzero__()) {
                           var1.setline(66);
                           var3 = var1.getderef(1).__getitem__(var1.getlocal(0).__getattr__("id"));
                           var1.f_lasti = -1;
                           return var3;
                        }
                     } else {
                        var1.setline(67);
                        var10000 = var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("BinOp"));
                        if (var10000.__nonzero__()) {
                           var10000 = var1.getglobal("isinstance").__call__((ThreadState)var2, (PyObject)var1.getlocal(0).__getattr__("op"), (PyObject)(new PyTuple(new PyObject[]{var1.getglobal("Add"), var1.getglobal("Sub")})));
                           if (var10000.__nonzero__()) {
                              var10000 = var1.getglobal("isinstance").__call__(var2, var1.getlocal(0).__getattr__("right"), var1.getglobal("Num"));
                              if (var10000.__nonzero__()) {
                                 var10000 = var1.getglobal("isinstance").__call__(var2, var1.getlocal(0).__getattr__("right").__getattr__("n"), var1.getglobal("complex"));
                                 if (var10000.__nonzero__()) {
                                    var10000 = var1.getglobal("isinstance").__call__(var2, var1.getlocal(0).__getattr__("left"), var1.getglobal("Num"));
                                    if (var10000.__nonzero__()) {
                                       var10000 = var1.getglobal("isinstance").__call__((ThreadState)var2, (PyObject)var1.getlocal(0).__getattr__("left").__getattr__("n"), (PyObject)(new PyTuple(new PyObject[]{var1.getglobal("int"), var1.getglobal("long"), var1.getglobal("float")})));
                                    }
                                 }
                              }
                           }
                        }

                        if (var10000.__nonzero__()) {
                           var1.setline(73);
                           var4 = var1.getlocal(0).__getattr__("left").__getattr__("n");
                           var1.setlocal(2, var4);
                           var4 = null;
                           var1.setline(74);
                           var4 = var1.getlocal(0).__getattr__("right").__getattr__("n");
                           var1.setlocal(3, var4);
                           var4 = null;
                           var1.setline(75);
                           if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0).__getattr__("op"), var1.getglobal("Add")).__nonzero__()) {
                              var1.setline(76);
                              var3 = var1.getlocal(2)._add(var1.getlocal(3));
                              var1.f_lasti = -1;
                              return var3;
                           }

                           var1.setline(78);
                           var3 = var1.getlocal(2)._sub(var1.getlocal(3));
                           var1.f_lasti = -1;
                           return var3;
                        }
                     }

                     var1.setline(79);
                     throw Py.makeException(var1.getglobal("ValueError").__call__((ThreadState)var2, (PyObject)PyString.fromInterned("malformed string")));
                  }
               }
            }
         }
      }
   }

   public PyObject f$4(PyFrame var1, ThreadState var2) {
      PyObject var3;
      PyObject var4;
      Object[] var5;
      switch (var1.f_lasti) {
         case 0:
         default:
            var1.setline(62);
            var3 = var1.getlocal(0).__iter__();
            break;
         case 1:
            var5 = var1.f_savedlocals;
            var3 = (PyObject)var5[3];
            var4 = (PyObject)var5[4];
            Object var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            PyObject var8 = (PyObject)var10000;
      }

      var1.setline(62);
      var4 = var3.__iternext__();
      if (var4 == null) {
         var1.f_lasti = -1;
         return Py.None;
      } else {
         PyObject[] var7 = Py.unpackSequence(var4, 2);
         PyObject var6 = var7[0];
         var1.setlocal(1, var6);
         var6 = null;
         var6 = var7[1];
         var1.setlocal(2, var6);
         var6 = null;
         var1.setline(62);
         var1.setline(62);
         var7 = new PyObject[]{var1.getderef(0).__call__(var2, var1.getlocal(1)), var1.getderef(0).__call__(var2, var1.getlocal(2))};
         PyTuple var9 = new PyTuple(var7);
         Arrays.fill(var7, (Object)null);
         var1.f_lasti = 1;
         var5 = new Object[7];
         var5[3] = var3;
         var5[4] = var4;
         var1.f_savedlocals = var5;
         return var9;
      }
   }

   public PyObject dump$5(PyFrame var1, ThreadState var2) {
      var1.to_cell(1, 1);
      var1.to_cell(2, 2);
      var1.setline(91);
      PyString.fromInterned("\n    Return a formatted dump of the tree in *node*.  This is mainly useful for\n    debugging purposes.  The returned string will show the names and the values\n    for fields.  This makes the code impossible to evaluate, so if evaluation is\n    wanted *annotate_fields* must be set to False.  Attributes such as line\n    numbers and column offsets are not dumped by default.  If this is wanted,\n    *include_attributes* can be set to True.\n    ");
      var1.setline(92);
      PyObject[] var3 = Py.EmptyObjects;
      PyObject var10002 = var1.f_globals;
      PyObject[] var10003 = var3;
      PyCode var10004 = _format$6;
      var3 = new PyObject[]{var1.getclosure(0), var1.getclosure(1), var1.getclosure(2)};
      PyFunction var4 = new PyFunction(var10002, var10003, var10004, (PyObject)null, var3);
      var1.setderef(0, var4);
      var3 = null;
      var1.setline(108);
      if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(0), var1.getglobal("AST")).__not__().__nonzero__()) {
         var1.setline(109);
         throw Py.makeException(var1.getglobal("TypeError").__call__(var2, PyString.fromInterned("expected AST, got %r")._mod(var1.getlocal(0).__getattr__("__class__").__getattr__("__name__"))));
      } else {
         var1.setline(110);
         PyObject var5 = var1.getderef(0).__call__(var2, var1.getlocal(0));
         var1.f_lasti = -1;
         return var5;
      }
   }

   public PyObject _format$6(PyFrame var1, ThreadState var2) {
      var1.to_cell(0, 0);
      var1.setline(93);
      PyObject var3;
      PyObject[] var5;
      PyObject[] var10;
      PyFunction var11;
      PyString var12;
      if (!var1.getglobal("isinstance").__call__(var2, var1.getderef(0), var1.getglobal("AST")).__nonzero__()) {
         var1.setline(105);
         if (var1.getglobal("isinstance").__call__(var2, var1.getderef(0), var1.getglobal("list")).__nonzero__()) {
            var1.setline(106);
            var12 = PyString.fromInterned("[%s]");
            PyObject var14 = PyString.fromInterned(", ").__getattr__("join");
            var1.setline(106);
            PyObject var10005 = var1.f_globals;
            var10 = Py.EmptyObjects;
            PyCode var10007 = f$10;
            var5 = new PyObject[]{var1.getclosure(1)};
            var11 = new PyFunction(var10005, var10, var10007, (PyObject)null, var5);
            PyObject var16 = var11.__call__(var2, var1.getderef(0).__iter__());
            Arrays.fill(var10, (Object)null);
            var3 = var12._mod(var14.__call__(var2, var16));
            var1.f_lasti = -1;
            return var3;
         } else {
            var1.setline(107);
            var3 = var1.getglobal("repr").__call__(var2, var1.getderef(0));
            var1.f_lasti = -1;
            return var3;
         }
      } else {
         var1.setline(94);
         PyList var10000 = new PyList();
         var3 = var10000.__getattr__("append");
         var1.setlocal(2, var3);
         var3 = null;
         var1.setline(94);
         var3 = var1.getglobal("iter_fields").__call__(var2, var1.getderef(0)).__iter__();

         while(true) {
            var1.setline(94);
            PyObject var4 = var3.__iternext__();
            if (var4 == null) {
               var1.setline(94);
               var1.dellocal(2);
               PyList var7 = var10000;
               var1.setlocal(1, var7);
               var3 = null;
               var1.setline(95);
               var12 = PyString.fromInterned("%s(%s");
               PyTuple var10001 = new PyTuple;
               PyObject[] var10003 = new PyObject[]{var1.getderef(0).__getattr__("__class__").__getattr__("__name__"), null};
               PyObject var10006 = PyString.fromInterned(", ").__getattr__("join");
               var1.setline(97);
               PyFunction var8;
               PyObject[] var9;
               PyObject var10008;
               if (var1.getderef(2).__nonzero__()) {
                  var1.setline(96);
                  var9 = Py.EmptyObjects;
                  var8 = new PyFunction(var1.f_globals, var9, f$7, (PyObject)null);
                  var10008 = var8.__call__(var2, var1.getlocal(1).__iter__());
                  Arrays.fill(var9, (Object)null);
               } else {
                  var1.setline(98);
                  var9 = Py.EmptyObjects;
                  var8 = new PyFunction(var1.f_globals, var9, f$8, (PyObject)null);
                  var10008 = var8.__call__(var2, var1.getlocal(1).__iter__());
                  Arrays.fill(var9, (Object)null);
               }

               var10003[1] = var10006.__call__(var2, var10008);
               var10001.<init>(var10003);
               var3 = var12._mod(var10001);
               var1.setlocal(5, var3);
               var3 = null;
               var1.setline(100);
               PyObject var13 = var1.getderef(3);
               if (var13.__nonzero__()) {
                  var13 = var1.getderef(0).__getattr__("_attributes");
               }

               if (var13.__nonzero__()) {
                  var1.setline(101);
                  var3 = var1.getlocal(5);
                  Object var15 = var1.getlocal(1);
                  if (((PyObject)var15).__nonzero__()) {
                     var15 = PyString.fromInterned(", ");
                  }

                  if (!((PyObject)var15).__nonzero__()) {
                     var15 = PyString.fromInterned(" ");
                  }

                  var3 = var3._iadd((PyObject)var15);
                  var1.setlocal(5, var3);
                  var1.setline(102);
                  var3 = var1.getlocal(5);
                  var13 = PyString.fromInterned(", ").__getattr__("join");
                  var1.setline(102);
                  PyObject var10004 = var1.f_globals;
                  var10 = Py.EmptyObjects;
                  PyCode var17 = f$9;
                  var5 = new PyObject[]{var1.getclosure(1), var1.getclosure(0)};
                  var11 = new PyFunction(var10004, var10, var17, (PyObject)null, var5);
                  PyObject var10002 = var11.__call__(var2, var1.getderef(0).__getattr__("_attributes").__iter__());
                  Arrays.fill(var10, (Object)null);
                  var3 = var3._iadd(var13.__call__(var2, var10002));
                  var1.setlocal(5, var3);
               }

               var1.setline(104);
               var3 = var1.getlocal(5)._add(PyString.fromInterned(")"));
               var1.f_lasti = -1;
               return var3;
            }

            var5 = Py.unpackSequence(var4, 2);
            PyObject var6 = var5[0];
            var1.setlocal(3, var6);
            var6 = null;
            var6 = var5[1];
            var1.setlocal(4, var6);
            var6 = null;
            var1.setline(94);
            var1.getlocal(2).__call__((ThreadState)var2, (PyObject)(new PyTuple(new PyObject[]{var1.getlocal(3), var1.getderef(1).__call__(var2, var1.getlocal(4))})));
         }
      }
   }

   public PyObject f$7(PyFrame var1, ThreadState var2) {
      PyObject var3;
      PyObject var4;
      Object[] var5;
      PyObject var6;
      switch (var1.f_lasti) {
         case 0:
         default:
            var1.setline(96);
            var3 = var1.getlocal(0).__iter__();
            break;
         case 1:
            var5 = var1.f_savedlocals;
            var3 = (PyObject)var5[3];
            var4 = (PyObject)var5[4];
            Object var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            var6 = (PyObject)var10000;
      }

      var1.setline(96);
      var4 = var3.__iternext__();
      if (var4 == null) {
         var1.f_lasti = -1;
         return Py.None;
      } else {
         var1.setlocal(1, var4);
         var1.setline(96);
         var1.setline(96);
         var6 = PyString.fromInterned("%s=%s")._mod(var1.getlocal(1));
         var1.f_lasti = 1;
         var5 = new Object[]{null, null, null, var3, var4};
         var1.f_savedlocals = var5;
         return var6;
      }
   }

   public PyObject f$8(PyFrame var1, ThreadState var2) {
      PyObject var3;
      PyObject var4;
      Object[] var5;
      PyObject var8;
      switch (var1.f_lasti) {
         case 0:
         default:
            var1.setline(98);
            var3 = var1.getlocal(0).__iter__();
            break;
         case 1:
            var5 = var1.f_savedlocals;
            var3 = (PyObject)var5[3];
            var4 = (PyObject)var5[4];
            Object var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            var8 = (PyObject)var10000;
      }

      var1.setline(98);
      var4 = var3.__iternext__();
      if (var4 == null) {
         var1.f_lasti = -1;
         return Py.None;
      } else {
         PyObject[] var7 = Py.unpackSequence(var4, 2);
         PyObject var6 = var7[0];
         var1.setlocal(2, var6);
         var6 = null;
         var6 = var7[1];
         var1.setlocal(1, var6);
         var6 = null;
         var1.setline(98);
         var1.setline(98);
         var8 = var1.getlocal(1);
         var1.f_lasti = 1;
         var5 = new Object[7];
         var5[3] = var3;
         var5[4] = var4;
         var1.f_savedlocals = var5;
         return var8;
      }
   }

   public PyObject f$9(PyFrame var1, ThreadState var2) {
      PyObject var3;
      PyObject var4;
      Object[] var5;
      PyObject var7;
      switch (var1.f_lasti) {
         case 0:
         default:
            var1.setline(103);
            var3 = var1.getlocal(0).__iter__();
            break;
         case 1:
            var5 = var1.f_savedlocals;
            var3 = (PyObject)var5[3];
            var4 = (PyObject)var5[4];
            Object var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            var7 = (PyObject)var10000;
      }

      var1.setline(103);
      var4 = var3.__iternext__();
      if (var4 == null) {
         var1.f_lasti = -1;
         return Py.None;
      } else {
         var1.setlocal(1, var4);
         var1.setline(102);
         var1.setline(102);
         PyString var8 = PyString.fromInterned("%s=%s");
         PyObject[] var6 = new PyObject[]{var1.getlocal(1), var1.getderef(0).__call__(var2, var1.getglobal("getattr").__call__(var2, var1.getderef(1), var1.getlocal(1)))};
         PyTuple var10001 = new PyTuple(var6);
         Arrays.fill(var6, (Object)null);
         var7 = var8._mod(var10001);
         var1.f_lasti = 1;
         var5 = new Object[]{null, null, null, var3, var4, null};
         var1.f_savedlocals = var5;
         return var7;
      }
   }

   public PyObject f$10(PyFrame var1, ThreadState var2) {
      PyObject var3;
      PyObject var4;
      Object[] var5;
      PyObject var6;
      switch (var1.f_lasti) {
         case 0:
         default:
            var1.setline(106);
            var3 = var1.getlocal(0).__iter__();
            break;
         case 1:
            var5 = var1.f_savedlocals;
            var3 = (PyObject)var5[3];
            var4 = (PyObject)var5[4];
            Object var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            var6 = (PyObject)var10000;
      }

      var1.setline(106);
      var4 = var3.__iternext__();
      if (var4 == null) {
         var1.f_lasti = -1;
         return Py.None;
      } else {
         var1.setlocal(1, var4);
         var1.setline(106);
         var1.setline(106);
         var6 = var1.getderef(0).__call__(var2, var1.getlocal(1));
         var1.f_lasti = 1;
         var5 = new Object[]{null, null, null, var3, var4};
         var1.f_savedlocals = var5;
         return var6;
      }
   }

   public PyObject copy_location$11(PyFrame var1, ThreadState var2) {
      var1.setline(117);
      PyString.fromInterned("\n    Copy source location (`lineno` and `col_offset` attributes) from\n    *old_node* to *new_node* if possible, and return *new_node*.\n    ");
      var1.setline(118);
      PyObject var3 = (new PyTuple(new PyObject[]{PyString.fromInterned("lineno"), PyString.fromInterned("col_offset")})).__iter__();

      while(true) {
         var1.setline(118);
         PyObject var4 = var3.__iternext__();
         if (var4 == null) {
            var1.setline(122);
            var3 = var1.getlocal(0);
            var1.f_lasti = -1;
            return var3;
         }

         var1.setlocal(2, var4);
         var1.setline(119);
         PyObject var5 = var1.getlocal(2);
         PyObject var10000 = var5._in(var1.getlocal(1).__getattr__("_attributes"));
         var5 = null;
         if (var10000.__nonzero__()) {
            var5 = var1.getlocal(2);
            var10000 = var5._in(var1.getlocal(0).__getattr__("_attributes"));
            var5 = null;
            if (var10000.__nonzero__()) {
               var10000 = var1.getglobal("hasattr").__call__(var2, var1.getlocal(1), var1.getlocal(2));
            }
         }

         if (var10000.__nonzero__()) {
            var1.setline(121);
            var1.getglobal("setattr").__call__(var2, var1.getlocal(0), var1.getlocal(2), var1.getglobal("getattr").__call__(var2, var1.getlocal(1), var1.getlocal(2)));
         }
      }
   }

   public PyObject fix_missing_locations$12(PyFrame var1, ThreadState var2) {
      var1.setline(132);
      PyString.fromInterned("\n    When you compile a node tree with compile(), the compiler expects lineno and\n    col_offset attributes for every node that supports them.  This is rather\n    tedious to fill in for generated nodes, so this helper adds these attributes\n    recursively where not already set, by setting them to the values of the\n    parent node.  It works recursively starting at *node*.\n    ");
      var1.setline(133);
      PyObject[] var3 = Py.EmptyObjects;
      PyObject var10002 = var1.f_globals;
      PyObject[] var10003 = var3;
      PyCode var10004 = _fix$13;
      var3 = new PyObject[]{var1.getclosure(0)};
      PyFunction var4 = new PyFunction(var10002, var10003, var10004, (PyObject)null, var3);
      var1.setderef(0, var4);
      var3 = null;
      var1.setline(146);
      var1.getderef(0).__call__((ThreadState)var2, var1.getlocal(0), (PyObject)Py.newInteger(1), (PyObject)Py.newInteger(0));
      var1.setline(147);
      PyObject var5 = var1.getlocal(0);
      var1.f_lasti = -1;
      return var5;
   }

   public PyObject _fix$13(PyFrame var1, ThreadState var2) {
      var1.setline(134);
      PyString var3 = PyString.fromInterned("lineno");
      PyObject var10000 = var3._in(var1.getlocal(0).__getattr__("_attributes"));
      var3 = null;
      PyObject var5;
      if (var10000.__nonzero__()) {
         var1.setline(135);
         if (var1.getglobal("hasattr").__call__((ThreadState)var2, (PyObject)var1.getlocal(0), (PyObject)PyString.fromInterned("lineno")).__not__().__nonzero__()) {
            var1.setline(136);
            var5 = var1.getlocal(1);
            var1.getlocal(0).__setattr__("lineno", var5);
            var3 = null;
         } else {
            var1.setline(138);
            var5 = var1.getlocal(0).__getattr__("lineno");
            var1.setlocal(1, var5);
            var3 = null;
         }
      }

      var1.setline(139);
      var3 = PyString.fromInterned("col_offset");
      var10000 = var3._in(var1.getlocal(0).__getattr__("_attributes"));
      var3 = null;
      if (var10000.__nonzero__()) {
         var1.setline(140);
         if (var1.getglobal("hasattr").__call__((ThreadState)var2, (PyObject)var1.getlocal(0), (PyObject)PyString.fromInterned("col_offset")).__not__().__nonzero__()) {
            var1.setline(141);
            var5 = var1.getlocal(2);
            var1.getlocal(0).__setattr__("col_offset", var5);
            var3 = null;
         } else {
            var1.setline(143);
            var5 = var1.getlocal(0).__getattr__("col_offset");
            var1.setlocal(2, var5);
            var3 = null;
         }
      }

      var1.setline(144);
      var5 = var1.getglobal("iter_child_nodes").__call__(var2, var1.getlocal(0)).__iter__();

      while(true) {
         var1.setline(144);
         PyObject var4 = var5.__iternext__();
         if (var4 == null) {
            var1.f_lasti = -1;
            return Py.None;
         }

         var1.setlocal(3, var4);
         var1.setline(145);
         var1.getderef(0).__call__(var2, var1.getlocal(3), var1.getlocal(1), var1.getlocal(2));
      }
   }

   public PyObject increment_lineno$14(PyFrame var1, ThreadState var2) {
      var1.setline(154);
      PyString.fromInterned("\n    Increment the line number of each node in the tree starting at *node* by *n*.\n    This is useful to \"move code\" to a different location in a file.\n    ");
      var1.setline(155);
      PyObject var3 = var1.getglobal("walk").__call__(var2, var1.getlocal(0)).__iter__();

      while(true) {
         var1.setline(155);
         PyObject var4 = var3.__iternext__();
         if (var4 == null) {
            var1.setline(158);
            var3 = var1.getlocal(0);
            var1.f_lasti = -1;
            return var3;
         }

         var1.setlocal(2, var4);
         var1.setline(156);
         PyString var5 = PyString.fromInterned("lineno");
         PyObject var10000 = var5._in(var1.getlocal(2).__getattr__("_attributes"));
         var5 = null;
         if (var10000.__nonzero__()) {
            var1.setline(157);
            PyObject var6 = var1.getglobal("getattr").__call__((ThreadState)var2, var1.getlocal(2), (PyObject)PyString.fromInterned("lineno"), (PyObject)Py.newInteger(0))._add(var1.getlocal(1));
            var1.getlocal(2).__setattr__("lineno", var6);
            var5 = null;
         }
      }
   }

   public PyObject iter_fields$15(PyFrame param1, ThreadState param2) {
      // $FF: Couldn't be decompiled
   }

   public PyObject iter_child_nodes$16(PyFrame var1, ThreadState var2) {
      Object var10000;
      PyObject var3;
      PyObject var4;
      PyObject var5;
      PyObject var6;
      Object[] var7;
      Object[] var8;
      PyObject var10;
      switch (var1.f_lasti) {
         case 0:
         default:
            var1.setline(177);
            PyString.fromInterned("\n    Yield all direct child nodes of *node*, that is, all fields that are nodes\n    and all items of fields that are lists of nodes.\n    ");
            var1.setline(178);
            var3 = var1.getglobal("iter_fields").__call__(var2, var1.getlocal(0)).__iter__();
            break;
         case 1:
            var8 = var1.f_savedlocals;
            var3 = (PyObject)var8[3];
            var4 = (PyObject)var8[4];
            var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            var10 = (PyObject)var10000;
            break;
         case 2:
            var7 = var1.f_savedlocals;
            var3 = (PyObject)var7[3];
            var4 = (PyObject)var7[4];
            var5 = (PyObject)var7[5];
            var6 = (PyObject)var7[6];
            var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            var10 = (PyObject)var10000;

            while(true) {
               var1.setline(182);
               var6 = var5.__iternext__();
               if (var6 == null) {
                  break;
               }

               var1.setlocal(3, var6);
               var1.setline(183);
               if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(3), var1.getglobal("AST")).__nonzero__()) {
                  var1.setline(184);
                  var1.setline(184);
                  var10 = var1.getlocal(3);
                  var1.f_lasti = 2;
                  var7 = new Object[]{null, null, null, var3, var4, var5, var6};
                  var1.f_savedlocals = var7;
                  return var10;
               }
            }
      }

      label52:
      while(true) {
         do {
            var1.setline(178);
            var4 = var3.__iternext__();
            if (var4 == null) {
               var1.f_lasti = -1;
               return Py.None;
            }

            PyObject[] var9 = Py.unpackSequence(var4, 2);
            var6 = var9[0];
            var1.setlocal(1, var6);
            var6 = null;
            var6 = var9[1];
            var1.setlocal(2, var6);
            var6 = null;
            var1.setline(179);
            if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(2), var1.getglobal("AST")).__nonzero__()) {
               var1.setline(180);
               var1.setline(180);
               var10 = var1.getlocal(2);
               var1.f_lasti = 1;
               var8 = new Object[7];
               var8[3] = var3;
               var8[4] = var4;
               var1.f_savedlocals = var8;
               return var10;
            }

            var1.setline(181);
         } while(!var1.getglobal("isinstance").__call__(var2, var1.getlocal(2), var1.getglobal("list")).__nonzero__());

         var1.setline(182);
         var5 = var1.getlocal(2).__iter__();

         do {
            var1.setline(182);
            var6 = var5.__iternext__();
            if (var6 == null) {
               continue label52;
            }

            var1.setlocal(3, var6);
            var1.setline(183);
         } while(!var1.getglobal("isinstance").__call__(var2, var1.getlocal(3), var1.getglobal("AST")).__nonzero__());

         var1.setline(184);
         var1.setline(184);
         var10 = var1.getlocal(3);
         var1.f_lasti = 2;
         var7 = new Object[]{null, null, null, var3, var4, var5, var6};
         var1.f_savedlocals = var7;
         return var10;
      }
   }

   public PyObject get_docstring$17(PyFrame var1, ThreadState var2) {
      var1.setline(192);
      PyString.fromInterned("\n    Return the docstring for the given node or None if no docstring can\n    be found.  If the node provided does not have docstrings a TypeError\n    will be raised.\n    ");
      var1.setline(193);
      if (var1.getglobal("isinstance").__call__((ThreadState)var2, (PyObject)var1.getlocal(0), (PyObject)(new PyTuple(new PyObject[]{var1.getglobal("FunctionDef"), var1.getglobal("ClassDef"), var1.getglobal("Module")}))).__not__().__nonzero__()) {
         var1.setline(194);
         throw Py.makeException(var1.getglobal("TypeError").__call__(var2, PyString.fromInterned("%r can't have docstrings")._mod(var1.getlocal(0).__getattr__("__class__").__getattr__("__name__"))));
      } else {
         var1.setline(195);
         PyObject var10000 = var1.getlocal(0).__getattr__("body");
         if (var10000.__nonzero__()) {
            var10000 = var1.getglobal("isinstance").__call__(var2, var1.getlocal(0).__getattr__("body").__getitem__(Py.newInteger(0)), var1.getglobal("Expr"));
            if (var10000.__nonzero__()) {
               var10000 = var1.getglobal("isinstance").__call__(var2, var1.getlocal(0).__getattr__("body").__getitem__(Py.newInteger(0)).__getattr__("value"), var1.getglobal("Str"));
            }
         }

         if (var10000.__nonzero__()) {
            var1.setline(197);
            PyObject var3;
            if (var1.getlocal(1).__nonzero__()) {
               var1.setline(198);
               var3 = imp.importOne("inspect", var1, -1);
               var1.setlocal(2, var3);
               var3 = null;
               var1.setline(199);
               var3 = var1.getlocal(2).__getattr__("cleandoc").__call__(var2, var1.getlocal(0).__getattr__("body").__getitem__(Py.newInteger(0)).__getattr__("value").__getattr__("s"));
               var1.f_lasti = -1;
               return var3;
            } else {
               var1.setline(200);
               var3 = var1.getlocal(0).__getattr__("body").__getitem__(Py.newInteger(0)).__getattr__("value").__getattr__("s");
               var1.f_lasti = -1;
               return var3;
            }
         } else {
            var1.f_lasti = -1;
            return Py.None;
         }
      }
   }

   public PyObject walk$18(PyFrame var1, ThreadState var2) {
      Object[] var3;
      PyObject var7;
      PyObject var8;
      switch (var1.f_lasti) {
         case 0:
         default:
            var1.setline(208);
            PyString.fromInterned("\n    Recursively yield all descendant nodes in the tree starting at *node*\n    (including *node* itself), in no specified order.  This is useful if you\n    only want to modify nodes in place and don't care about the context.\n    ");
            var1.setline(209);
            String[] var5 = new String[]{"deque"};
            PyObject[] var6 = imp.importFrom("collections", var5, var1, -1);
            PyObject var4 = var6[0];
            var1.setlocal(1, var4);
            var4 = null;
            var1.setline(210);
            var8 = var1.getlocal(1);
            var6 = new PyObject[]{var1.getlocal(0)};
            PyList var10002 = new PyList(var6);
            Arrays.fill(var6, (Object)null);
            var7 = var8.__call__((ThreadState)var2, (PyObject)var10002);
            var1.setlocal(2, var7);
            var3 = null;
            break;
         case 1:
            var3 = var1.f_savedlocals;
            Object var10000 = var1.getGeneratorInput();
            if (var10000 instanceof PyException) {
               throw (Throwable)var10000;
            }

            var8 = (PyObject)var10000;
      }

      var1.setline(211);
      if (!var1.getlocal(2).__nonzero__()) {
         var1.f_lasti = -1;
         return Py.None;
      } else {
         var1.setline(212);
         var7 = var1.getlocal(2).__getattr__("popleft").__call__(var2);
         var1.setlocal(0, var7);
         var3 = null;
         var1.setline(213);
         var1.getlocal(2).__getattr__("extend").__call__(var2, var1.getglobal("iter_child_nodes").__call__(var2, var1.getlocal(0)));
         var1.setline(214);
         var1.setline(214);
         var8 = var1.getlocal(0);
         var1.f_lasti = 1;
         var3 = new Object[5];
         var1.f_savedlocals = var3;
         return var8;
      }
   }

   public PyObject NodeVisitor$19(PyFrame var1, ThreadState var2) {
      var1.setlocal("__module__", var1.getname("__name__"));
      var1.setlocal("__doc__", PyString.fromInterned("\n    A node visitor base class that walks the abstract syntax tree and calls a\n    visitor function for every node found.  This function may return a value\n    which is forwarded by the `visit` method.\n\n    This class is meant to be subclassed, with the subclass adding visitor\n    methods.\n\n    Per default the visitor functions for the nodes are ``'visit_'`` +\n    class name of the node.  So a `TryFinally` node visit function would\n    be `visit_TryFinally`.  This behavior can be changed by overriding\n    the `visit` method.  If no visitor function exists for a node\n    (return value `None`) the `generic_visit` visitor is used instead.\n\n    Don't use the `NodeVisitor` if you want to apply changes to nodes during\n    traversing.  For this a special visitor exists (`NodeTransformer`) that\n    allows modifications.\n    "));
      var1.setline(235);
      PyString.fromInterned("\n    A node visitor base class that walks the abstract syntax tree and calls a\n    visitor function for every node found.  This function may return a value\n    which is forwarded by the `visit` method.\n\n    This class is meant to be subclassed, with the subclass adding visitor\n    methods.\n\n    Per default the visitor functions for the nodes are ``'visit_'`` +\n    class name of the node.  So a `TryFinally` node visit function would\n    be `visit_TryFinally`.  This behavior can be changed by overriding\n    the `visit` method.  If no visitor function exists for a node\n    (return value `None`) the `generic_visit` visitor is used instead.\n\n    Don't use the `NodeVisitor` if you want to apply changes to nodes during\n    traversing.  For this a special visitor exists (`NodeTransformer`) that\n    allows modifications.\n    ");
      var1.setline(237);
      PyObject[] var3 = Py.EmptyObjects;
      PyFunction var4 = new PyFunction(var1.f_globals, var3, visit$20, PyString.fromInterned("Visit a node."));
      var1.setlocal("visit", var4);
      var3 = null;
      var1.setline(243);
      var3 = Py.EmptyObjects;
      var4 = new PyFunction(var1.f_globals, var3, generic_visit$21, PyString.fromInterned("Called if no explicit visitor function exists for a node."));
      var1.setlocal("generic_visit", var4);
      var3 = null;
      return var1.getf_locals();
   }

   public PyObject visit$20(PyFrame var1, ThreadState var2) {
      var1.setline(238);
      PyString.fromInterned("Visit a node.");
      var1.setline(239);
      PyObject var3 = PyString.fromInterned("visit_")._add(var1.getlocal(1).__getattr__("__class__").__getattr__("__name__"));
      var1.setlocal(2, var3);
      var3 = null;
      var1.setline(240);
      var3 = var1.getglobal("getattr").__call__(var2, var1.getlocal(0), var1.getlocal(2), var1.getlocal(0).__getattr__("generic_visit"));
      var1.setlocal(3, var3);
      var3 = null;
      var1.setline(241);
      var3 = var1.getlocal(3).__call__(var2, var1.getlocal(1));
      var1.f_lasti = -1;
      return var3;
   }

   public PyObject generic_visit$21(PyFrame var1, ThreadState var2) {
      var1.setline(244);
      PyString.fromInterned("Called if no explicit visitor function exists for a node.");
      var1.setline(245);
      PyObject var3 = var1.getglobal("iter_fields").__call__(var2, var1.getlocal(1)).__iter__();

      while(true) {
         while(true) {
            var1.setline(245);
            PyObject var4 = var3.__iternext__();
            if (var4 == null) {
               var1.f_lasti = -1;
               return Py.None;
            }

            PyObject[] var5 = Py.unpackSequence(var4, 2);
            PyObject var6 = var5[0];
            var1.setlocal(2, var6);
            var6 = null;
            var6 = var5[1];
            var1.setlocal(3, var6);
            var6 = null;
            var1.setline(246);
            if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(3), var1.getglobal("list")).__nonzero__()) {
               var1.setline(247);
               PyObject var7 = var1.getlocal(3).__iter__();

               while(true) {
                  var1.setline(247);
                  var6 = var7.__iternext__();
                  if (var6 == null) {
                     break;
                  }

                  var1.setlocal(4, var6);
                  var1.setline(248);
                  if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(4), var1.getglobal("AST")).__nonzero__()) {
                     var1.setline(249);
                     var1.getlocal(0).__getattr__("visit").__call__(var2, var1.getlocal(4));
                  }
               }
            } else {
               var1.setline(250);
               if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(3), var1.getglobal("AST")).__nonzero__()) {
                  var1.setline(251);
                  var1.getlocal(0).__getattr__("visit").__call__(var2, var1.getlocal(3));
               }
            }
         }
      }
   }

   public PyObject NodeTransformer$22(PyFrame var1, ThreadState var2) {
      var1.setlocal("__module__", var1.getname("__name__"));
      var1.setlocal("__doc__", PyString.fromInterned("\n    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and\n    allows modification of nodes.\n\n    The `NodeTransformer` will walk the AST and use the return value of the\n    visitor methods to replace or remove the old node.  If the return value of\n    the visitor method is ``None``, the node will be removed from its location,\n    otherwise it is replaced with the return value.  The return value may be the\n    original node in which case no replacement takes place.\n\n    Here is an example transformer that rewrites all occurrences of name lookups\n    (``foo``) to ``data['foo']``::\n\n       class RewriteName(NodeTransformer):\n\n           def visit_Name(self, node):\n               return copy_location(Subscript(\n                   value=Name(id='data', ctx=Load()),\n                   slice=Index(value=Str(s=node.id)),\n                   ctx=node.ctx\n               ), node)\n\n    Keep in mind that if the node you're operating on has child nodes you must\n    either transform the child nodes yourself or call the :meth:`generic_visit`\n    method for the node first.\n\n    For nodes that were part of a collection of statements (that applies to all\n    statement nodes), the visitor may also return a list of nodes rather than\n    just a single node.\n\n    Usually you use the transformer like this::\n\n       node = YourTransformer().visit(node)\n    "));
      var1.setline(288);
      PyString.fromInterned("\n    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and\n    allows modification of nodes.\n\n    The `NodeTransformer` will walk the AST and use the return value of the\n    visitor methods to replace or remove the old node.  If the return value of\n    the visitor method is ``None``, the node will be removed from its location,\n    otherwise it is replaced with the return value.  The return value may be the\n    original node in which case no replacement takes place.\n\n    Here is an example transformer that rewrites all occurrences of name lookups\n    (``foo``) to ``data['foo']``::\n\n       class RewriteName(NodeTransformer):\n\n           def visit_Name(self, node):\n               return copy_location(Subscript(\n                   value=Name(id='data', ctx=Load()),\n                   slice=Index(value=Str(s=node.id)),\n                   ctx=node.ctx\n               ), node)\n\n    Keep in mind that if the node you're operating on has child nodes you must\n    either transform the child nodes yourself or call the :meth:`generic_visit`\n    method for the node first.\n\n    For nodes that were part of a collection of statements (that applies to all\n    statement nodes), the visitor may also return a list of nodes rather than\n    just a single node.\n\n    Usually you use the transformer like this::\n\n       node = YourTransformer().visit(node)\n    ");
      var1.setline(290);
      PyObject[] var3 = Py.EmptyObjects;
      PyFunction var4 = new PyFunction(var1.f_globals, var3, generic_visit$23, (PyObject)null);
      var1.setlocal("generic_visit", var4);
      var3 = null;
      return var1.getf_locals();
   }

   public PyObject generic_visit$23(PyFrame var1, ThreadState var2) {
      var1.setline(291);
      PyObject var3 = var1.getglobal("iter_fields").__call__(var2, var1.getlocal(1)).__iter__();

      while(true) {
         label30:
         while(true) {
            var1.setline(291);
            PyObject var4 = var3.__iternext__();
            if (var4 == null) {
               var1.setline(311);
               var3 = var1.getlocal(1);
               var1.f_lasti = -1;
               return var3;
            }

            PyObject[] var5 = Py.unpackSequence(var4, 2);
            PyObject var6 = var5[0];
            var1.setlocal(2, var6);
            var6 = null;
            var6 = var5[1];
            var1.setlocal(3, var6);
            var6 = null;
            var1.setline(292);
            PyObject var8 = var1.getglobal("getattr").__call__(var2, var1.getlocal(1), var1.getlocal(2), var1.getglobal("None"));
            var1.setlocal(3, var8);
            var5 = null;
            var1.setline(293);
            PyObject var10000;
            if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(3), var1.getglobal("list")).__nonzero__()) {
               var1.setline(294);
               PyList var9 = new PyList(Py.EmptyObjects);
               var1.setlocal(4, var9);
               var5 = null;
               var1.setline(295);
               var8 = var1.getlocal(3).__iter__();

               while(true) {
                  while(true) {
                     var1.setline(295);
                     var6 = var8.__iternext__();
                     if (var6 == null) {
                        var1.setline(304);
                        var8 = var1.getlocal(4);
                        var1.getlocal(3).__setslice__((PyObject)null, (PyObject)null, (PyObject)null, var8);
                        var5 = null;
                        continue label30;
                     }

                     var1.setlocal(5, var6);
                     var1.setline(296);
                     if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(5), var1.getglobal("AST")).__nonzero__()) {
                        var1.setline(297);
                        PyObject var7 = var1.getlocal(0).__getattr__("visit").__call__(var2, var1.getlocal(5));
                        var1.setlocal(5, var7);
                        var7 = null;
                        var1.setline(298);
                        var7 = var1.getlocal(5);
                        var10000 = var7._is(var1.getglobal("None"));
                        var7 = null;
                        if (var10000.__nonzero__()) {
                           continue;
                        }

                        var1.setline(300);
                        if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(5), var1.getglobal("AST")).__not__().__nonzero__()) {
                           var1.setline(301);
                           var1.getlocal(4).__getattr__("extend").__call__(var2, var1.getlocal(5));
                           continue;
                        }
                     }

                     var1.setline(303);
                     var1.getlocal(4).__getattr__("append").__call__(var2, var1.getlocal(5));
                  }
               }
            } else {
               var1.setline(305);
               if (var1.getglobal("isinstance").__call__(var2, var1.getlocal(3), var1.getglobal("AST")).__nonzero__()) {
                  var1.setline(306);
                  var8 = var1.getlocal(0).__getattr__("visit").__call__(var2, var1.getlocal(3));
                  var1.setlocal(6, var8);
                  var5 = null;
                  var1.setline(307);
                  var8 = var1.getlocal(6);
                  var10000 = var8._is(var1.getglobal("None"));
                  var5 = null;
                  if (var10000.__nonzero__()) {
                     var1.setline(308);
                     var1.getglobal("delattr").__call__(var2, var1.getlocal(1), var1.getlocal(2));
                  } else {
                     var1.setline(310);
                     var1.getglobal("setattr").__call__(var2, var1.getlocal(1), var1.getlocal(2), var1.getlocal(6));
                  }
               }
            }
         }
      }
   }

   public ast$py(String var1) {
      self = this;
      String[] var2 = new String[0];
      f$0 = Py.newCode(0, var2, var1, "<module>", 0, false, false, self, 0, (String[])null, (String[])null, 0, 4096);
      var2 = new String[]{"source", "filename", "mode"};
      parse$1 = Py.newCode(3, var2, var1, "parse", 32, false, false, self, 1, (String[])null, (String[])null, 0, 4097);
      var2 = new String[]{"node_or_string", "_safe_names", "_convert"};
      String[] var10001 = var2;
      ast$py var10007 = self;
      var2 = new String[]{"_safe_names", "_convert"};
      literal_eval$2 = Py.newCode(1, var10001, var1, "literal_eval", 40, false, false, var10007, 2, var2, (String[])null, 2, 4097);
      var2 = new String[]{"node", "_(62_24)", "left", "right"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"_convert", "_safe_names"};
      _convert$3 = Py.newCode(1, var10001, var1, "_convert", 52, false, false, var10007, 3, (String[])null, var2, 0, 4097);
      var2 = new String[]{"_(x)", "k", "v"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"_convert"};
      f$4 = Py.newCode(1, var10001, var1, "<genexpr>", 62, false, false, var10007, 4, (String[])null, var2, 0, 4129);
      var2 = new String[]{"node", "annotate_fields", "include_attributes", "_format"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"_format", "annotate_fields", "include_attributes"};
      dump$5 = Py.newCode(3, var10001, var1, "dump", 83, false, false, var10007, 5, var2, (String[])null, 1, 4097);
      var2 = new String[]{"node", "fields", "_[94_22]", "a", "b", "rv", "_(96_17)", "_(98_17)", "_(102_32)", "_(106_38)"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"node"};
      String[] var10009 = var2;
      var2 = new String[]{"_format", "annotate_fields", "include_attributes"};
      _format$6 = Py.newCode(1, var10001, var1, "_format", 92, false, false, var10007, 6, var10009, var2, 0, 4097);
      var2 = new String[]{"_(x)", "field"};
      f$7 = Py.newCode(1, var2, var1, "<genexpr>", 96, false, false, self, 7, (String[])null, (String[])null, 0, 4129);
      var2 = new String[]{"_(x)", "b", "a"};
      f$8 = Py.newCode(1, var2, var1, "<genexpr>", 98, false, false, self, 8, (String[])null, (String[])null, 0, 4129);
      var2 = new String[]{"_(x)", "a"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"_format", "node"};
      f$9 = Py.newCode(1, var10001, var1, "<genexpr>", 102, false, false, var10007, 9, (String[])null, var2, 0, 4129);
      var2 = new String[]{"_(x)", "x"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"_format"};
      f$10 = Py.newCode(1, var10001, var1, "<genexpr>", 106, false, false, var10007, 10, (String[])null, var2, 0, 4129);
      var2 = new String[]{"new_node", "old_node", "attr"};
      copy_location$11 = Py.newCode(2, var2, var1, "copy_location", 113, false, false, self, 11, (String[])null, (String[])null, 0, 4097);
      var2 = new String[]{"node", "_fix"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"_fix"};
      fix_missing_locations$12 = Py.newCode(1, var10001, var1, "fix_missing_locations", 125, false, false, var10007, 12, var2, (String[])null, 1, 4097);
      var2 = new String[]{"node", "lineno", "col_offset", "child"};
      var10001 = var2;
      var10007 = self;
      var2 = new String[]{"_fix"};
      _fix$13 = Py.newCode(3, var10001, var1, "_fix", 133, false, false, var10007, 13, (String[])null, var2, 0, 4097);
      var2 = new String[]{"node", "n", "child"};
      increment_lineno$14 = Py.newCode(2, var2, var1, "increment_lineno", 150, false, false, self, 14, (String[])null, (String[])null, 0, 4097);
      var2 = new String[]{"node", "field"};
      iter_fields$15 = Py.newCode(1, var2, var1, "iter_fields", 161, false, false, self, 15, (String[])null, (String[])null, 0, 4129);
      var2 = new String[]{"node", "name", "field", "item"};
      iter_child_nodes$16 = Py.newCode(1, var2, var1, "iter_child_nodes", 173, false, false, self, 16, (String[])null, (String[])null, 0, 4129);
      var2 = new String[]{"node", "clean", "inspect"};
      get_docstring$17 = Py.newCode(2, var2, var1, "get_docstring", 187, false, false, self, 17, (String[])null, (String[])null, 0, 4097);
      var2 = new String[]{"node", "deque", "todo"};
      walk$18 = Py.newCode(1, var2, var1, "walk", 203, false, false, self, 18, (String[])null, (String[])null, 0, 4129);
      var2 = new String[0];
      NodeVisitor$19 = Py.newCode(0, var2, var1, "NodeVisitor", 217, false, false, self, 19, (String[])null, (String[])null, 0, 4096);
      var2 = new String[]{"self", "node", "method", "visitor"};
      visit$20 = Py.newCode(2, var2, var1, "visit", 237, false, false, self, 20, (String[])null, (String[])null, 0, 4097);
      var2 = new String[]{"self", "node", "field", "value", "item"};
      generic_visit$21 = Py.newCode(2, var2, var1, "generic_visit", 243, false, false, self, 21, (String[])null, (String[])null, 0, 4097);
      var2 = new String[0];
      NodeTransformer$22 = Py.newCode(0, var2, var1, "NodeTransformer", 254, false, false, self, 22, (String[])null, (String[])null, 0, 4096);
      var2 = new String[]{"self", "node", "field", "old_value", "new_values", "value", "new_node"};
      generic_visit$23 = Py.newCode(2, var2, var1, "generic_visit", 290, false, false, self, 23, (String[])null, (String[])null, 0, 4097);
   }

   public PyCode getMain() {
      return f$0;
   }

   public static void main(String[] var0) {
      Py.runMain(CodeLoader.createSimpleBootstrap((new ast$py("ast$py")).getMain()), var0);
   }

   public static CodeBootstrap getCodeBootstrap() {
      return PyRunnableBootstrap.getFilenameConstructorReflectionBootstrap(ast$py.class);
   }

   public PyObject call_function(int var1, PyFrame var2, ThreadState var3) {
      switch (var1) {
         case 0:
            return this.f$0(var2, var3);
         case 1:
            return this.parse$1(var2, var3);
         case 2:
            return this.literal_eval$2(var2, var3);
         case 3:
            return this._convert$3(var2, var3);
         case 4:
            return this.f$4(var2, var3);
         case 5:
            return this.dump$5(var2, var3);
         case 6:
            return this._format$6(var2, var3);
         case 7:
            return this.f$7(var2, var3);
         case 8:
            return this.f$8(var2, var3);
         case 9:
            return this.f$9(var2, var3);
         case 10:
            return this.f$10(var2, var3);
         case 11:
            return this.copy_location$11(var2, var3);
         case 12:
            return this.fix_missing_locations$12(var2, var3);
         case 13:
            return this._fix$13(var2, var3);
         case 14:
            return this.increment_lineno$14(var2, var3);
         case 15:
            return this.iter_fields$15(var2, var3);
         case 16:
            return this.iter_child_nodes$16(var2, var3);
         case 17:
            return this.get_docstring$17(var2, var3);
         case 18:
            return this.walk$18(var2, var3);
         case 19:
            return this.NodeVisitor$19(var2, var3);
         case 20:
            return this.visit$20(var2, var3);
         case 21:
            return this.generic_visit$21(var2, var3);
         case 22:
            return this.NodeTransformer$22(var2, var3);
         case 23:
            return this.generic_visit$23(var2, var3);
         default:
            return null;
      }
   }
}
