package org.python.core;

public class BuiltinDocs {
   public static final String object___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String object___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String object_doc = "The most base type";
   public static final String object___format___doc = "default object formatter";
   public static final String object___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String object___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String object___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String object___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String object___reduce___doc = "helper for pickle";
   public static final String object___reduce_ex___doc = "helper for pickle";
   public static final String object___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String object___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String object___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String object___str___doc = "x.__str__() <==> str(x)";
   public static final String object___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String type___abstractmethods___doc = "";
   public static final String type___base___doc = "The most base type";
   public static final String type___bases___doc = "tuple() -> empty tuple\ntuple(iterable) -> tuple initialized from iterable's items\n\nIf the argument is a tuple, the return value is the same object.";
   public static final String type___basicsize___doc = "int(x[, base]) -> integer\n\nConvert a string or number to an integer, if possible.  A floating point\nargument will be truncated towards zero (this does not include a string\nrepresentation of a floating point number!)  When converting a string, use\nthe optional base.  It is an error to supply a base when converting a\nnon-string.  If base is zero, the proper base is guessed based on the\nstring content.  If the argument is outside the integer range a\nlong object will be returned instead.";
   public static final String type___call___doc = "x.__call__(...) <==> x(...)";
   public static final String type___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String type___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String type___dict___doc = "";
   public static final String type___dictoffset___doc = "int(x[, base]) -> integer\n\nConvert a string or number to an integer, if possible.  A floating point\nargument will be truncated towards zero (this does not include a string\nrepresentation of a floating point number!)  When converting a string, use\nthe optional base.  It is an error to supply a base when converting a\nnon-string.  If base is zero, the proper base is guessed based on the\nstring content.  If the argument is outside the integer range a\nlong object will be returned instead.";
   public static final String type_doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String type___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String type___flags___doc = "int(x[, base]) -> integer\n\nConvert a string or number to an integer, if possible.  A floating point\nargument will be truncated towards zero (this does not include a string\nrepresentation of a floating point number!)  When converting a string, use\nthe optional base.  It is an error to supply a base when converting a\nnon-string.  If base is zero, the proper base is guessed based on the\nstring content.  If the argument is outside the integer range a\nlong object will be returned instead.";
   public static final String type___format___doc = "default object formatter";
   public static final String type___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String type___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String type___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String type___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String type___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String type___instancecheck___doc = "__instancecheck__() -> bool\ncheck if an object is an instance";
   public static final String type___itemsize___doc = "int(x[, base]) -> integer\n\nConvert a string or number to an integer, if possible.  A floating point\nargument will be truncated towards zero (this does not include a string\nrepresentation of a floating point number!)  When converting a string, use\nthe optional base.  It is an error to supply a base when converting a\nnon-string.  If base is zero, the proper base is guessed based on the\nstring content.  If the argument is outside the integer range a\nlong object will be returned instead.";
   public static final String type___le___doc = "x.__le__(y) <==> x<=y";
   public static final String type___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String type___module___doc = "str(object) -> string\n\nReturn a nice string representation of the object.\nIf the argument is a string, the return value is the same object.";
   public static final String type___mro___doc = "tuple() -> empty tuple\ntuple(iterable) -> tuple initialized from iterable's items\n\nIf the argument is a tuple, the return value is the same object.";
   public static final String type___name___doc = "str(object) -> string\n\nReturn a nice string representation of the object.\nIf the argument is a string, the return value is the same object.";
   public static final String type___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String type___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String type___reduce___doc = "helper for pickle";
   public static final String type___reduce_ex___doc = "helper for pickle";
   public static final String type___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String type___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String type___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String type___str___doc = "x.__str__() <==> str(x)";
   public static final String type___subclasscheck___doc = "__subclasscheck__() -> bool\ncheck if a class is a subclass";
   public static final String type___subclasses___doc = "__subclasses__() -> list of immediate subclasses";
   public static final String type___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String type___weakrefoffset___doc = "int(x[, base]) -> integer\n\nConvert a string or number to an integer, if possible.  A floating point\nargument will be truncated towards zero (this does not include a string\nrepresentation of a floating point number!)  When converting a string, use\nthe optional base.  It is an error to supply a base when converting a\nnon-string.  If base is zero, the proper base is guessed based on the\nstring content.  If the argument is outside the integer range a\nlong object will be returned instead.";
   public static final String type_mro_doc = "mro() -> list\nreturn a type's method resolution order";
   public static final String unicode___add___doc = "x.__add__(y) <==> x+y";
   public static final String unicode___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String unicode___contains___doc = "x.__contains__(y) <==> y in x";
   public static final String unicode___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String unicode_doc = "unicode(object='') -> unicode object\nunicode(string[, encoding[, errors]]) -> unicode object\n\nCreate a new Unicode object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.";
   public static final String unicode___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String unicode___format___doc = "S.__format__(format_spec) -> unicode\n\nReturn a formatted version of S as described by format_spec.";
   public static final String unicode___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String unicode___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String unicode___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String unicode___getnewargs___doc = "";
   public static final String unicode___getslice___doc = "x.__getslice__(i, j) <==> x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String unicode___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String unicode___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String unicode___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String unicode___le___doc = "x.__le__(y) <==> x<=y";
   public static final String unicode___len___doc = "x.__len__() <==> len(x)";
   public static final String unicode___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String unicode___mod___doc = "x.__mod__(y) <==> x%y";
   public static final String unicode___mul___doc = "x.__mul__(n) <==> x*n";
   public static final String unicode___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String unicode___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String unicode___reduce___doc = "helper for pickle";
   public static final String unicode___reduce_ex___doc = "helper for pickle";
   public static final String unicode___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String unicode___rmod___doc = "x.__rmod__(y) <==> y%x";
   public static final String unicode___rmul___doc = "x.__rmul__(n) <==> n*x";
   public static final String unicode___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String unicode___sizeof___doc = "S.__sizeof__() -> size of S in memory, in bytes\n\n";
   public static final String unicode___str___doc = "x.__str__() <==> str(x)";
   public static final String unicode___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String unicode__formatter_field_name_split_doc = "";
   public static final String unicode__formatter_parser_doc = "";
   public static final String unicode_capitalize_doc = "S.capitalize() -> unicode\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.";
   public static final String unicode_center_doc = "S.center(width[, fillchar]) -> unicode\n\nReturn S centered in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space)";
   public static final String unicode_count_doc = "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nUnicode string S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.";
   public static final String unicode_decode_doc = "S.decode([encoding[,errors]]) -> string or unicode\n\nDecodes S using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\nas well as any other name registerd with codecs.register_error that is\nable to handle UnicodeDecodeErrors.";
   public static final String unicode_encode_doc = "S.encode([encoding[,errors]]) -> string or unicode\n\nEncodes S using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.";
   public static final String unicode_endswith_doc = "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.";
   public static final String unicode_expandtabs_doc = "S.expandtabs([tabsize]) -> unicode\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.";
   public static final String unicode_find_doc = "S.find(sub [,start [,end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within s[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
   public static final String unicode_format_doc = "S.format(*args, **kwargs) -> unicode\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').";
   public static final String unicode_index_doc = "S.index(sub [,start [,end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.";
   public static final String unicode_isalnum_doc = "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.";
   public static final String unicode_isalpha_doc = "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.";
   public static final String unicode_isdecimal_doc = "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.";
   public static final String unicode_isdigit_doc = "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.";
   public static final String unicode_islower_doc = "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.";
   public static final String unicode_isnumeric_doc = "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.";
   public static final String unicode_isspace_doc = "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.";
   public static final String unicode_istitle_doc = "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.";
   public static final String unicode_isupper_doc = "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.";
   public static final String unicode_join_doc = "S.join(iterable) -> unicode\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.";
   public static final String unicode_ljust_doc = "S.ljust(width[, fillchar]) -> int\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).";
   public static final String unicode_lower_doc = "S.lower() -> unicode\n\nReturn a copy of the string S converted to lowercase.";
   public static final String unicode_lstrip_doc = "S.lstrip([chars]) -> unicode\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is a str, it will be converted to unicode before stripping";
   public static final String unicode_partition_doc = "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.";
   public static final String unicode_replace_doc = "S.replace(old, new[, count]) -> unicode\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.";
   public static final String unicode_rfind_doc = "S.rfind(sub [,start [,end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within s[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
   public static final String unicode_rindex_doc = "S.rindex(sub [,start [,end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.";
   public static final String unicode_rjust_doc = "S.rjust(width[, fillchar]) -> unicode\n\nReturn S right-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).";
   public static final String unicode_rpartition_doc = "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.";
   public static final String unicode_rsplit_doc = "S.rsplit([sep [,maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.";
   public static final String unicode_rstrip_doc = "S.rstrip([chars]) -> unicode\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is a str, it will be converted to unicode before stripping";
   public static final String unicode_split_doc = "S.split([sep [,maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.";
   public static final String unicode_splitlines_doc = "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.";
   public static final String unicode_startswith_doc = "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.";
   public static final String unicode_strip_doc = "S.strip([chars]) -> unicode\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is a str, it will be converted to unicode before stripping";
   public static final String unicode_swapcase_doc = "S.swapcase() -> unicode\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.";
   public static final String unicode_title_doc = "S.title() -> unicode\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.";
   public static final String unicode_translate_doc = "S.translate(table) -> unicode\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, Unicode strings or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.";
   public static final String unicode_upper_doc = "S.upper() -> unicode\n\nReturn a copy of S converted to uppercase.";
   public static final String unicode_zfill_doc = "S.zfill(width) -> unicode\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.";
   public static final String dict___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String dict___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String dict___contains___doc = "D.__contains__(k) -> True if D has a key k, else False";
   public static final String dict___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String dict___delitem___doc = "x.__delitem__(y) <==> del x[y]";
   public static final String dict_doc = "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)";
   public static final String dict___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String dict___format___doc = "default object formatter";
   public static final String dict___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String dict___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String dict___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String dict___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String dict___hash___doc = "";
   public static final String dict___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String dict___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String dict___le___doc = "x.__le__(y) <==> x<=y";
   public static final String dict___len___doc = "x.__len__() <==> len(x)";
   public static final String dict___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String dict___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String dict___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String dict___reduce___doc = "helper for pickle";
   public static final String dict___reduce_ex___doc = "helper for pickle";
   public static final String dict___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String dict___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String dict___setitem___doc = "x.__setitem__(i, y) <==> x[i]=y";
   public static final String dict___sizeof___doc = "D.__sizeof__() -> size of D in memory, in bytes";
   public static final String dict___str___doc = "x.__str__() <==> str(x)";
   public static final String dict___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String dict_clear_doc = "D.clear() -> None.  Remove all items from D.";
   public static final String dict_copy_doc = "D.copy() -> a shallow copy of D";
   public static final String dict_fromkeys_doc = "dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v.\nv defaults to None.";
   public static final String dict_get_doc = "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.";
   public static final String dict_has_key_doc = "D.has_key(k) -> True if D has a key k, else False";
   public static final String dict_items_doc = "D.items() -> list of D's (key, value) pairs, as 2-tuples";
   public static final String dict_iteritems_doc = "D.iteritems() -> an iterator over the (key, value) items of D";
   public static final String dict_iterkeys_doc = "D.iterkeys() -> an iterator over the keys of D";
   public static final String dict_itervalues_doc = "D.itervalues() -> an iterator over the values of D";
   public static final String dict_keys_doc = "D.keys() -> list of D's keys";
   public static final String dict_pop_doc = "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised";
   public static final String dict_popitem_doc = "D.popitem() -> (k, v), remove and return some (key, value) pair as a\n2-tuple; but raise KeyError if D is empty.";
   public static final String dict_setdefault_doc = "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D";
   public static final String dict_update_doc = "D.update(E, **F) -> None.  Update D from dict/iterable E and F.\nIf E has a .keys() method, does:     for k in E: D[k] = E[k]\nIf E lacks .keys() method, does:     for (k, v) in E: D[k] = v\nIn either case, this is followed by: for k in F: D[k] = F[k]";
   public static final String dict_values_doc = "D.values() -> list of D's values";
   public static final String dict_viewitems_doc = "D.viewitems() -> a set-like object providing a view on D's items";
   public static final String dict_viewkeys_doc = "D.viewkeys() -> a set-like object providing a view on D's keys";
   public static final String dict_viewvalues_doc = "D.viewvalues() -> an object providing a view on D's values";
   public static final String list___add___doc = "x.__add__(y) <==> x+y";
   public static final String list___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String list___contains___doc = "x.__contains__(y) <==> y in x";
   public static final String list___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String list___delitem___doc = "x.__delitem__(y) <==> del x[y]";
   public static final String list___delslice___doc = "x.__delslice__(i, j) <==> del x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String list_doc = "list() -> new empty list\nlist(iterable) -> new list initialized from iterable's items";
   public static final String list___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String list___format___doc = "default object formatter";
   public static final String list___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String list___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String list___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String list___getslice___doc = "x.__getslice__(i, j) <==> x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String list___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String list___hash___doc = "";
   public static final String list___iadd___doc = "x.__iadd__(y) <==> x+=y";
   public static final String list___imul___doc = "x.__imul__(y) <==> x*=y";
   public static final String list___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String list___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String list___le___doc = "x.__le__(y) <==> x<=y";
   public static final String list___len___doc = "x.__len__() <==> len(x)";
   public static final String list___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String list___mul___doc = "x.__mul__(n) <==> x*n";
   public static final String list___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String list___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String list___reduce___doc = "helper for pickle";
   public static final String list___reduce_ex___doc = "helper for pickle";
   public static final String list___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String list___reversed___doc = "L.__reversed__() -- return a reverse iterator over the list";
   public static final String list___rmul___doc = "x.__rmul__(n) <==> n*x";
   public static final String list___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String list___setitem___doc = "x.__setitem__(i, y) <==> x[i]=y";
   public static final String list___setslice___doc = "x.__setslice__(i, j, y) <==> x[i:j]=y\n           \n           Use  of negative indices is not supported.";
   public static final String list___sizeof___doc = "L.__sizeof__() -- size of L in memory, in bytes";
   public static final String list___str___doc = "x.__str__() <==> str(x)";
   public static final String list___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String list_append_doc = "L.append(object) -- append object to end";
   public static final String list_count_doc = "L.count(value) -> integer -- return number of occurrences of value";
   public static final String list_extend_doc = "L.extend(iterable) -- extend list by appending elements from the iterable";
   public static final String list_index_doc = "L.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.";
   public static final String list_insert_doc = "L.insert(index, object) -- insert object before index";
   public static final String list_pop_doc = "L.pop([index]) -> item -- remove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range.";
   public static final String list_remove_doc = "L.remove(value) -- remove first occurrence of value.\nRaises ValueError if the value is not present.";
   public static final String list_reverse_doc = "L.reverse() -- reverse *IN PLACE*";
   public static final String list_sort_doc = "L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;\ncmp(x, y) -> -1, 0, 1";
   public static final String slice___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String slice___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String slice___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String slice_doc = "slice([start,] stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).";
   public static final String slice___format___doc = "default object formatter";
   public static final String slice___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String slice___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String slice___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String slice___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String slice___reduce___doc = "Return state information for pickling.";
   public static final String slice___reduce_ex___doc = "helper for pickle";
   public static final String slice___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String slice___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String slice___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String slice___str___doc = "x.__str__() <==> str(x)";
   public static final String slice___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String slice_indices_doc = "S.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop\nindices, and the stride length of the extended slice described by\nS. Out of bounds indices are clipped in a manner consistent with the\nhandling of normal slices.";
   public static final String slice_start_doc = "";
   public static final String slice_step_doc = "";
   public static final String slice_stop_doc = "";
   public static final String super___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String super___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String super_doc = "super(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super(C, self).meth(arg)";
   public static final String super___format___doc = "default object formatter";
   public static final String super___get___doc = "descr.__get__(obj[, type]) -> value";
   public static final String super___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String super___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String super___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String super___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String super___reduce___doc = "helper for pickle";
   public static final String super___reduce_ex___doc = "helper for pickle";
   public static final String super___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String super___self___doc = "the instance invoking super(); may be None";
   public static final String super___self_class___doc = "the type of the instance invoking super(); may be None";
   public static final String super___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String super___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String super___str___doc = "x.__str__() <==> str(x)";
   public static final String super___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String super___thisclass___doc = "the class invoking super()";
   public static final String staticmethod___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String staticmethod___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String staticmethod_doc = "staticmethod(function) -> method\n\nConvert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n     def f(arg1, arg2, ...): ...\n     f = staticmethod(f)\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.";
   public static final String staticmethod___format___doc = "default object formatter";
   public static final String staticmethod___func___doc = "";
   public static final String staticmethod___get___doc = "descr.__get__(obj[, type]) -> value";
   public static final String staticmethod___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String staticmethod___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String staticmethod___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String staticmethod___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String staticmethod___reduce___doc = "helper for pickle";
   public static final String staticmethod___reduce_ex___doc = "helper for pickle";
   public static final String staticmethod___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String staticmethod___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String staticmethod___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String staticmethod___str___doc = "x.__str__() <==> str(x)";
   public static final String staticmethod___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String float___abs___doc = "x.__abs__() <==> abs(x)";
   public static final String float___add___doc = "x.__add__(y) <==> x+y";
   public static final String float___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String float___coerce___doc = "x.__coerce__(y) <==> coerce(x, y)";
   public static final String float___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String float___div___doc = "x.__div__(y) <==> x/y";
   public static final String float___divmod___doc = "x.__divmod__(y) <==> divmod(x, y)";
   public static final String float_doc = "float(x) -> floating point number\n\nConvert a string or number to a floating point number, if possible.";
   public static final String float___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String float___float___doc = "x.__float__() <==> float(x)";
   public static final String float___floordiv___doc = "x.__floordiv__(y) <==> x//y";
   public static final String float___format___doc = "float.__format__(format_spec) -> string\n\nFormats the float according to format_spec.";
   public static final String float___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String float___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String float___getformat___doc = "float.__getformat__(typestr) -> string\n\nYou probably don't want to use this function.  It exists mainly to be\nused in Python's test suite.\n\ntypestr must be 'double' or 'float'.  This function returns whichever of\n'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the\nformat of floating point numbers used by the C type named by typestr.";
   public static final String float___getnewargs___doc = "";
   public static final String float___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String float___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String float___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String float___int___doc = "x.__int__() <==> int(x)";
   public static final String float___le___doc = "x.__le__(y) <==> x<=y";
   public static final String float___long___doc = "x.__long__() <==> long(x)";
   public static final String float___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String float___mod___doc = "x.__mod__(y) <==> x%y";
   public static final String float___mul___doc = "x.__mul__(y) <==> x*y";
   public static final String float___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String float___neg___doc = "x.__neg__() <==> -x";
   public static final String float___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String float___nonzero___doc = "x.__nonzero__() <==> x != 0";
   public static final String float___pos___doc = "x.__pos__() <==> +x";
   public static final String float___pow___doc = "x.__pow__(y[, z]) <==> pow(x, y[, z])";
   public static final String float___radd___doc = "x.__radd__(y) <==> y+x";
   public static final String float___rdiv___doc = "x.__rdiv__(y) <==> y/x";
   public static final String float___rdivmod___doc = "x.__rdivmod__(y) <==> divmod(y, x)";
   public static final String float___reduce___doc = "helper for pickle";
   public static final String float___reduce_ex___doc = "helper for pickle";
   public static final String float___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String float___rfloordiv___doc = "x.__rfloordiv__(y) <==> y//x";
   public static final String float___rmod___doc = "x.__rmod__(y) <==> y%x";
   public static final String float___rmul___doc = "x.__rmul__(y) <==> y*x";
   public static final String float___rpow___doc = "y.__rpow__(x[, z]) <==> pow(x, y[, z])";
   public static final String float___rsub___doc = "x.__rsub__(y) <==> y-x";
   public static final String float___rtruediv___doc = "x.__rtruediv__(y) <==> y/x";
   public static final String float___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String float___setformat___doc = "float.__setformat__(typestr, fmt) -> None\n\nYou probably don't want to use this function.  It exists mainly to be\nused in Python's test suite.\n\ntypestr must be 'double' or 'float'.  fmt must be one of 'unknown',\n'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be\none of the latter two if it appears to match the underlying C reality.\n\nOverrides the automatic determination of C-level floating point type.\nThis affects how floats are converted to and from binary strings.";
   public static final String float___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String float___str___doc = "x.__str__() <==> str(x)";
   public static final String float___sub___doc = "x.__sub__(y) <==> x-y";
   public static final String float___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String float___truediv___doc = "x.__truediv__(y) <==> x/y";
   public static final String float___trunc___doc = "Returns the Integral closest to x between 0 and x.";
   public static final String float_as_integer_ratio_doc = "float.as_integer_ratio() -> (int, int)\n\nReturns a pair of integers, whose ratio is exactly equal to the original\nfloat and with a positive denominator.\nRaises OverflowError on infinities and a ValueError on NaNs.\n\n>>> (10.0).as_integer_ratio()\n(10, 1)\n>>> (0.0).as_integer_ratio()\n(0, 1)\n>>> (-.25).as_integer_ratio()\n(-1, 4)";
   public static final String float_conjugate_doc = "Returns self, the complex conjugate of any float.";
   public static final String float_fromhex_doc = "float.fromhex(string) -> float\n\nCreate a floating-point number from a hexadecimal string.\n>>> float.fromhex('0x1.ffffp10')\n2047.984375\n>>> float.fromhex('-0x1p-1074')\n-4.9406564584124654e-324";
   public static final String float_hex_doc = "float.hex() -> string\n\nReturn a hexadecimal representation of a floating-point number.\n>>> (-0.1).hex()\n'-0x1.999999999999ap-4'\n>>> 3.14159.hex()\n'0x1.921f9f01b866ep+1'";
   public static final String float_imag_doc = "the imaginary part of a complex number";
   public static final String float_is_integer_doc = "Returns True if the float is an integer.";
   public static final String float_real_doc = "the real part of a complex number";
   public static final String enumerate___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String enumerate___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String enumerate_doc = "enumerate(iterable[, start]) -> iterator for index, value of iterable\n\nReturn an enumerate object.  iterable must be another object that supports\niteration.  The enumerate object yields pairs containing a count (from\nstart, which defaults to zero) and a value yielded by the iterable argument.\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...";
   public static final String enumerate___format___doc = "default object formatter";
   public static final String enumerate___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String enumerate___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String enumerate___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String enumerate___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String enumerate___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String enumerate___reduce___doc = "helper for pickle";
   public static final String enumerate___reduce_ex___doc = "helper for pickle";
   public static final String enumerate___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String enumerate___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String enumerate___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String enumerate___str___doc = "x.__str__() <==> str(x)";
   public static final String enumerate___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String enumerate_next_doc = "x.next() -> the next value, or raise StopIteration";
   public static final String basestring___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String basestring___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String basestring_doc = "Type basestring cannot be instantiated; it is the base for str and unicode.";
   public static final String basestring___format___doc = "default object formatter";
   public static final String basestring___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String basestring___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String basestring___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String basestring___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String basestring___reduce___doc = "helper for pickle";
   public static final String basestring___reduce_ex___doc = "helper for pickle";
   public static final String basestring___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String basestring___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String basestring___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String basestring___str___doc = "x.__str__() <==> str(x)";
   public static final String basestring___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String long___abs___doc = "x.__abs__() <==> abs(x)";
   public static final String long___add___doc = "x.__add__(y) <==> x+y";
   public static final String long___and___doc = "x.__and__(y) <==> x&y";
   public static final String long___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String long___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String long___coerce___doc = "x.__coerce__(y) <==> coerce(x, y)";
   public static final String long___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String long___div___doc = "x.__div__(y) <==> x/y";
   public static final String long___divmod___doc = "x.__divmod__(y) <==> divmod(x, y)";
   public static final String long_doc = "long(x[, base]) -> integer\n\nConvert a string or number to a long integer, if possible.  A floating\npoint argument will be truncated towards zero (this does not include a\nstring representation of a floating point number!)  When converting a\nstring, use the optional base.  It is an error to supply a base when\nconverting a non-string.";
   public static final String long___float___doc = "x.__float__() <==> float(x)";
   public static final String long___floordiv___doc = "x.__floordiv__(y) <==> x//y";
   public static final String long___format___doc = "";
   public static final String long___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String long___getnewargs___doc = "";
   public static final String long___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String long___hex___doc = "x.__hex__() <==> hex(x)";
   public static final String long___index___doc = "x[y:z] <==> x[y.__index__():z.__index__()]";
   public static final String long___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String long___int___doc = "x.__int__() <==> int(x)";
   public static final String long___invert___doc = "x.__invert__() <==> ~x";
   public static final String long___long___doc = "x.__long__() <==> long(x)";
   public static final String long___lshift___doc = "x.__lshift__(y) <==> x<<y";
   public static final String long___mod___doc = "x.__mod__(y) <==> x%y";
   public static final String long___mul___doc = "x.__mul__(y) <==> x*y";
   public static final String long___neg___doc = "x.__neg__() <==> -x";
   public static final String long___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String long___nonzero___doc = "x.__nonzero__() <==> x != 0";
   public static final String long___oct___doc = "x.__oct__() <==> oct(x)";
   public static final String long___or___doc = "x.__or__(y) <==> x|y";
   public static final String long___pos___doc = "x.__pos__() <==> +x";
   public static final String long___pow___doc = "x.__pow__(y[, z]) <==> pow(x, y[, z])";
   public static final String long___radd___doc = "x.__radd__(y) <==> y+x";
   public static final String long___rand___doc = "x.__rand__(y) <==> y&x";
   public static final String long___rdiv___doc = "x.__rdiv__(y) <==> y/x";
   public static final String long___rdivmod___doc = "x.__rdivmod__(y) <==> divmod(y, x)";
   public static final String long___reduce___doc = "helper for pickle";
   public static final String long___reduce_ex___doc = "helper for pickle";
   public static final String long___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String long___rfloordiv___doc = "x.__rfloordiv__(y) <==> y//x";
   public static final String long___rlshift___doc = "x.__rlshift__(y) <==> y<<x";
   public static final String long___rmod___doc = "x.__rmod__(y) <==> y%x";
   public static final String long___rmul___doc = "x.__rmul__(y) <==> y*x";
   public static final String long___ror___doc = "x.__ror__(y) <==> y|x";
   public static final String long___rpow___doc = "y.__rpow__(x[, z]) <==> pow(x, y[, z])";
   public static final String long___rrshift___doc = "x.__rrshift__(y) <==> y>>x";
   public static final String long___rshift___doc = "x.__rshift__(y) <==> x>>y";
   public static final String long___rsub___doc = "x.__rsub__(y) <==> y-x";
   public static final String long___rtruediv___doc = "x.__rtruediv__(y) <==> y/x";
   public static final String long___rxor___doc = "x.__rxor__(y) <==> y^x";
   public static final String long___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String long___sizeof___doc = "Returns size in memory, in bytes";
   public static final String long___str___doc = "x.__str__() <==> str(x)";
   public static final String long___sub___doc = "x.__sub__(y) <==> x-y";
   public static final String long___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String long___truediv___doc = "x.__truediv__(y) <==> x/y";
   public static final String long___trunc___doc = "Truncating an Integral returns itself.";
   public static final String long___xor___doc = "x.__xor__(y) <==> x^y";
   public static final String long_bit_length_doc = "long.bit_length() -> int or long\n\nNumber of bits necessary to represent self in binary.\n>>> bin(37L)\n'0b100101'\n>>> (37L).bit_length()\n6";
   public static final String long_conjugate_doc = "Returns self, the complex conjugate of any long.";
   public static final String long_denominator_doc = "the denominator of a rational number in lowest terms";
   public static final String long_imag_doc = "the imaginary part of a complex number";
   public static final String long_numerator_doc = "the numerator of a rational number in lowest terms";
   public static final String long_real_doc = "the real part of a complex number";
   public static final String tuple___add___doc = "x.__add__(y) <==> x+y";
   public static final String tuple___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String tuple___contains___doc = "x.__contains__(y) <==> y in x";
   public static final String tuple___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String tuple_doc = "tuple() -> empty tuple\ntuple(iterable) -> tuple initialized from iterable's items\n\nIf the argument is a tuple, the return value is the same object.";
   public static final String tuple___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String tuple___format___doc = "default object formatter";
   public static final String tuple___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String tuple___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String tuple___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String tuple___getnewargs___doc = "";
   public static final String tuple___getslice___doc = "x.__getslice__(i, j) <==> x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String tuple___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String tuple___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String tuple___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String tuple___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String tuple___le___doc = "x.__le__(y) <==> x<=y";
   public static final String tuple___len___doc = "x.__len__() <==> len(x)";
   public static final String tuple___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String tuple___mul___doc = "x.__mul__(n) <==> x*n";
   public static final String tuple___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String tuple___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String tuple___reduce___doc = "helper for pickle";
   public static final String tuple___reduce_ex___doc = "helper for pickle";
   public static final String tuple___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String tuple___rmul___doc = "x.__rmul__(n) <==> n*x";
   public static final String tuple___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String tuple___sizeof___doc = "T.__sizeof__() -- size of T in memory, in bytes";
   public static final String tuple___str___doc = "x.__str__() <==> str(x)";
   public static final String tuple___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String tuple_count_doc = "T.count(value) -> integer -- return number of occurrences of value";
   public static final String tuple_index_doc = "T.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present.";
   public static final String str___add___doc = "x.__add__(y) <==> x+y";
   public static final String str___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String str___contains___doc = "x.__contains__(y) <==> y in x";
   public static final String str___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String str_doc = "str(object) -> string\n\nReturn a nice string representation of the object.\nIf the argument is a string, the return value is the same object.";
   public static final String str___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String str___format___doc = "S.__format__(format_spec) -> string\n\nReturn a formatted version of S as described by format_spec.";
   public static final String str___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String str___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String str___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String str___getnewargs___doc = "";
   public static final String str___getslice___doc = "x.__getslice__(i, j) <==> x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String str___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String str___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String str___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String str___le___doc = "x.__le__(y) <==> x<=y";
   public static final String str___len___doc = "x.__len__() <==> len(x)";
   public static final String str___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String str___mod___doc = "x.__mod__(y) <==> x%y";
   public static final String str___mul___doc = "x.__mul__(n) <==> x*n";
   public static final String str___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String str___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String str___reduce___doc = "helper for pickle";
   public static final String str___reduce_ex___doc = "helper for pickle";
   public static final String str___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String str___rmod___doc = "x.__rmod__(y) <==> y%x";
   public static final String str___rmul___doc = "x.__rmul__(n) <==> n*x";
   public static final String str___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String str___sizeof___doc = "S.__sizeof__() -> size of S in memory, in bytes";
   public static final String str___str___doc = "x.__str__() <==> str(x)";
   public static final String str___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String str__formatter_field_name_split_doc = "";
   public static final String str__formatter_parser_doc = "";
   public static final String str_capitalize_doc = "S.capitalize() -> string\n\nReturn a copy of the string S with only its first character\ncapitalized.";
   public static final String str_center_doc = "S.center(width[, fillchar]) -> string\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)";
   public static final String str_count_doc = "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are interpreted\nas in slice notation.";
   public static final String str_decode_doc = "S.decode([encoding[,errors]]) -> object\n\nDecodes S using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\nas well as any other name registered with codecs.register_error that is\nable to handle UnicodeDecodeErrors.";
   public static final String str_encode_doc = "S.encode([encoding[,errors]]) -> object\n\nEncodes S using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that is able to handle UnicodeEncodeErrors.";
   public static final String str_endswith_doc = "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.";
   public static final String str_expandtabs_doc = "S.expandtabs([tabsize]) -> string\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.";
   public static final String str_find_doc = "S.find(sub [,start [,end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within s[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
   public static final String str_format_doc = "S.format(*args, **kwargs) -> string\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').";
   public static final String str_index_doc = "S.index(sub [,start [,end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.";
   public static final String str_isalnum_doc = "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.";
   public static final String str_isalpha_doc = "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.";
   public static final String str_isdigit_doc = "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.";
   public static final String str_islower_doc = "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.";
   public static final String str_isspace_doc = "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.";
   public static final String str_istitle_doc = "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise.";
   public static final String str_isupper_doc = "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.";
   public static final String str_join_doc = "S.join(iterable) -> string\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.";
   public static final String str_ljust_doc = "S.ljust(width[, fillchar]) -> string\n\nReturn S left-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).";
   public static final String str_lower_doc = "S.lower() -> string\n\nReturn a copy of the string S converted to lowercase.";
   public static final String str_lstrip_doc = "S.lstrip([chars]) -> string or unicode\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is unicode, S will be converted to unicode before stripping";
   public static final String str_partition_doc = "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.";
   public static final String str_replace_doc = "S.replace(old, new[, count]) -> string\n\nReturn a copy of string S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.";
   public static final String str_rfind_doc = "S.rfind(sub [,start [,end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within s[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
   public static final String str_rindex_doc = "S.rindex(sub [,start [,end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.";
   public static final String str_rjust_doc = "S.rjust(width[, fillchar]) -> string\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)";
   public static final String str_rpartition_doc = "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.";
   public static final String str_rsplit_doc = "S.rsplit([sep [,maxsplit]]) -> list of strings\n\nReturn a list of the words in the string S, using sep as the\ndelimiter string, starting at the end of the string and working\nto the front.  If maxsplit is given, at most maxsplit splits are\ndone. If sep is not specified or is None, any whitespace string\nis a separator.";
   public static final String str_rstrip_doc = "S.rstrip([chars]) -> string or unicode\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is unicode, S will be converted to unicode before stripping";
   public static final String str_split_doc = "S.split([sep [,maxsplit]]) -> list of strings\n\nReturn a list of the words in the string S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are removed\nfrom the result.";
   public static final String str_splitlines_doc = "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.";
   public static final String str_startswith_doc = "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.";
   public static final String str_strip_doc = "S.strip([chars]) -> string or unicode\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is unicode, S will be converted to unicode before stripping";
   public static final String str_swapcase_doc = "S.swapcase() -> string\n\nReturn a copy of the string S with uppercase characters\nconverted to lowercase and vice versa.";
   public static final String str_title_doc = "S.title() -> string\n\nReturn a titlecased version of S, i.e. words start with uppercase\ncharacters, all remaining cased characters have lowercase.";
   public static final String str_translate_doc = "S.translate(table [,deletechars]) -> string\n\nReturn a copy of the string S, where all characters occurring\nin the optional argument deletechars are removed, and the\nremaining characters have been mapped through the given\ntranslation table, which must be a string of length 256.";
   public static final String str_upper_doc = "S.upper() -> string\n\nReturn a copy of the string S converted to uppercase.";
   public static final String str_zfill_doc = "S.zfill(width) -> string\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width.  The string S is never truncated.";
   public static final String property___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String property___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String property___delete___doc = "descr.__delete__(obj)";
   public static final String property_doc = "property(fget=None, fset=None, fdel=None, doc=None) -> property attribute\n\nfget is a function to be used for getting an attribute value, and likewise\nfset is a function for setting, and fdel a function for del'ing, an\nattribute.  Typical use is to define a managed attribute x:\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n\nDecorators make defining new properties or modifying existing ones easy:\nclass C(object):\n    @property\n    def x(self): return self._x\n    @x.setter\n    def x(self, value): self._x = value\n    @x.deleter\n    def x(self): del self._x\n";
   public static final String property___format___doc = "default object formatter";
   public static final String property___get___doc = "descr.__get__(obj[, type]) -> value";
   public static final String property___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String property___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String property___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String property___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String property___reduce___doc = "helper for pickle";
   public static final String property___reduce_ex___doc = "helper for pickle";
   public static final String property___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String property___set___doc = "descr.__set__(obj, value)";
   public static final String property___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String property___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String property___str___doc = "x.__str__() <==> str(x)";
   public static final String property___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String property_deleter_doc = "Descriptor to change the deleter on a property.";
   public static final String property_fdel_doc = "";
   public static final String property_fget_doc = "";
   public static final String property_fset_doc = "";
   public static final String property_getter_doc = "Descriptor to change the getter on a property.";
   public static final String property_setter_doc = "Descriptor to change the setter on a property.";
   public static final String int___abs___doc = "x.__abs__() <==> abs(x)";
   public static final String int___add___doc = "x.__add__(y) <==> x+y";
   public static final String int___and___doc = "x.__and__(y) <==> x&y";
   public static final String int___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String int___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String int___coerce___doc = "x.__coerce__(y) <==> coerce(x, y)";
   public static final String int___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String int___div___doc = "x.__div__(y) <==> x/y";
   public static final String int___divmod___doc = "x.__divmod__(y) <==> divmod(x, y)";
   public static final String int_doc = "int(x[, base]) -> integer\n\nConvert a string or number to an integer, if possible.  A floating point\nargument will be truncated towards zero (this does not include a string\nrepresentation of a floating point number!)  When converting a string, use\nthe optional base.  It is an error to supply a base when converting a\nnon-string.  If base is zero, the proper base is guessed based on the\nstring content.  If the argument is outside the integer range a\nlong object will be returned instead.";
   public static final String int___float___doc = "x.__float__() <==> float(x)";
   public static final String int___floordiv___doc = "x.__floordiv__(y) <==> x//y";
   public static final String int___format___doc = "";
   public static final String int___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String int___getnewargs___doc = "";
   public static final String int___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String int___hex___doc = "x.__hex__() <==> hex(x)";
   public static final String int___index___doc = "x[y:z] <==> x[y.__index__():z.__index__()]";
   public static final String int___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String int___int___doc = "x.__int__() <==> int(x)";
   public static final String int___invert___doc = "x.__invert__() <==> ~x";
   public static final String int___long___doc = "x.__long__() <==> long(x)";
   public static final String int___lshift___doc = "x.__lshift__(y) <==> x<<y";
   public static final String int___mod___doc = "x.__mod__(y) <==> x%y";
   public static final String int___mul___doc = "x.__mul__(y) <==> x*y";
   public static final String int___neg___doc = "x.__neg__() <==> -x";
   public static final String int___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String int___nonzero___doc = "x.__nonzero__() <==> x != 0";
   public static final String int___oct___doc = "x.__oct__() <==> oct(x)";
   public static final String int___or___doc = "x.__or__(y) <==> x|y";
   public static final String int___pos___doc = "x.__pos__() <==> +x";
   public static final String int___pow___doc = "x.__pow__(y[, z]) <==> pow(x, y[, z])";
   public static final String int___radd___doc = "x.__radd__(y) <==> y+x";
   public static final String int___rand___doc = "x.__rand__(y) <==> y&x";
   public static final String int___rdiv___doc = "x.__rdiv__(y) <==> y/x";
   public static final String int___rdivmod___doc = "x.__rdivmod__(y) <==> divmod(y, x)";
   public static final String int___reduce___doc = "helper for pickle";
   public static final String int___reduce_ex___doc = "helper for pickle";
   public static final String int___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String int___rfloordiv___doc = "x.__rfloordiv__(y) <==> y//x";
   public static final String int___rlshift___doc = "x.__rlshift__(y) <==> y<<x";
   public static final String int___rmod___doc = "x.__rmod__(y) <==> y%x";
   public static final String int___rmul___doc = "x.__rmul__(y) <==> y*x";
   public static final String int___ror___doc = "x.__ror__(y) <==> y|x";
   public static final String int___rpow___doc = "y.__rpow__(x[, z]) <==> pow(x, y[, z])";
   public static final String int___rrshift___doc = "x.__rrshift__(y) <==> y>>x";
   public static final String int___rshift___doc = "x.__rshift__(y) <==> x>>y";
   public static final String int___rsub___doc = "x.__rsub__(y) <==> y-x";
   public static final String int___rtruediv___doc = "x.__rtruediv__(y) <==> y/x";
   public static final String int___rxor___doc = "x.__rxor__(y) <==> y^x";
   public static final String int___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String int___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String int___str___doc = "x.__str__() <==> str(x)";
   public static final String int___sub___doc = "x.__sub__(y) <==> x-y";
   public static final String int___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String int___truediv___doc = "x.__truediv__(y) <==> x/y";
   public static final String int___trunc___doc = "Truncating an Integral returns itself.";
   public static final String int___xor___doc = "x.__xor__(y) <==> x^y";
   public static final String int_bit_length_doc = "int.bit_length() -> int\n\nNumber of bits necessary to represent self in binary.\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6";
   public static final String int_conjugate_doc = "Returns self, the complex conjugate of any int.";
   public static final String int_denominator_doc = "the denominator of a rational number in lowest terms";
   public static final String int_imag_doc = "the imaginary part of a complex number";
   public static final String int_numerator_doc = "the numerator of a rational number in lowest terms";
   public static final String int_real_doc = "the real part of a complex number";
   public static final String xrange___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String xrange___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String xrange_doc = "xrange([start,] stop[, step]) -> xrange object\n\nLike range(), but instead of returning a list, returns an object that\ngenerates the numbers in the range on demand.  For looping, this is \nslightly faster than range() and more memory efficient.";
   public static final String xrange___format___doc = "default object formatter";
   public static final String xrange___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String xrange___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String xrange___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String xrange___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String xrange___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String xrange___len___doc = "x.__len__() <==> len(x)";
   public static final String xrange___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String xrange___reduce___doc = "";
   public static final String xrange___reduce_ex___doc = "helper for pickle";
   public static final String xrange___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String xrange___reversed___doc = "Returns a reverse iterator.";
   public static final String xrange___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String xrange___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String xrange___str___doc = "x.__str__() <==> str(x)";
   public static final String xrange___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String file___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String file___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String file_doc = "file(name[, mode[, buffering]]) -> file object\n\nOpen a file.  The mode can be 'r', 'w' or 'a' for reading (default),\nwriting or appending.  The file will be created if it doesn't exist\nwhen opened for writing or appending; it will be truncated when\nopened for writing.  Add a 'b' to the mode for binary files.\nAdd a '+' to the mode to allow simultaneous reading and writing.\nIf the buffering argument is given, 0 means unbuffered, 1 means line\nbuffered, and larger numbers specify the buffer size.  The preferred way\nto open a file is with the builtin open() function.\nAdd a 'U' to mode to open the file for input with universal newline\nsupport.  Any line ending in the input file will be seen as a '\\n'\nin Python.  Also, a file so opened gains the attribute 'newlines';\nthe value for this attribute is one of None (no newline read yet),\n'\\r', '\\n', '\\r\\n' or a tuple containing all the newline types seen.\n\n'U' cannot be combined with 'w' or '+' mode.\n";
   public static final String file___enter___doc = "__enter__() -> self.";
   public static final String file___exit___doc = "__exit__(*excinfo) -> None.  Closes the file.";
   public static final String file___format___doc = "default object formatter";
   public static final String file___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String file___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String file___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String file___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String file___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String file___reduce___doc = "helper for pickle";
   public static final String file___reduce_ex___doc = "helper for pickle";
   public static final String file___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String file___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String file___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String file___str___doc = "x.__str__() <==> str(x)";
   public static final String file___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String file_close_doc = "close() -> None or (perhaps) an integer.  Close the file.\n\nSets data attribute .closed to True.  A closed file cannot be used for\nfurther I/O operations.  close() may be called more than once without\nerror.  Some kinds of file objects (for example, opened by popen())\nmay return an exit status upon closing.";
   public static final String file_closed_doc = "True if the file is closed";
   public static final String file_encoding_doc = "file encoding";
   public static final String file_errors_doc = "Unicode error handler";
   public static final String file_fileno_doc = "fileno() -> integer \"file descriptor\".\n\nThis is needed for lower-level file interfaces, such os.read().";
   public static final String file_flush_doc = "flush() -> None.  Flush the internal I/O buffer.";
   public static final String file_isatty_doc = "isatty() -> true or false.  True if the file is connected to a tty device.";
   public static final String file_mode_doc = "file mode ('r', 'U', 'w', 'a', possibly with 'b' or '+' added)";
   public static final String file_name_doc = "file name";
   public static final String file_newlines_doc = "end-of-line convention used in this file";
   public static final String file_next_doc = "x.next() -> the next value, or raise StopIteration";
   public static final String file_read_doc = "read([size]) -> read at most size bytes, returned as a string.\n\nIf the size argument is negative or omitted, read until EOF is reached.\nNotice that when in non-blocking mode, less data than what was requested\nmay be returned, even if no size parameter was given.";
   public static final String file_readinto_doc = "readinto() -> Undocumented.  Don't use this; it may go away.";
   public static final String file_readline_doc = "readline([size]) -> next line from the file, as a string.\n\nRetain newline.  A non-negative size argument limits the maximum\nnumber of bytes to return (an incomplete line may be returned then).\nReturn an empty string at EOF.";
   public static final String file_readlines_doc = "readlines([size]) -> list of strings, each a line from the file.\n\nCall readline() repeatedly and return a list of the lines so read.\nThe optional size argument, if given, is an approximate bound on the\ntotal number of bytes in the lines returned.";
   public static final String file_seek_doc = "seek(offset[, whence]) -> None.  Move to new file position.\n\nArgument offset is a byte count.  Optional argument whence defaults to\n0 (offset from start of file, offset should be >= 0); other values are 1\n(move relative to current position, positive or negative), and 2 (move\nrelative to end of file, usually negative, although many platforms allow\nseeking beyond the end of a file).  If the file is opened in text mode,\nonly offsets returned by tell() are legal.  Use of other offsets causes\nundefined behavior.\nNote that not all file objects are seekable.";
   public static final String file_softspace_doc = "flag indicating that a space needs to be printed; used by print";
   public static final String file_tell_doc = "tell() -> current file position, an integer (may be a long integer).";
   public static final String file_truncate_doc = "truncate([size]) -> None.  Truncate the file to at most size bytes.\n\nSize defaults to the current file position, as returned by tell().";
   public static final String file_write_doc = "write(str) -> None.  Write string str to file.\n\nNote that due to buffering, flush() or close() may be needed before\nthe file on disk reflects the data written.";
   public static final String file_writelines_doc = "writelines(sequence_of_strings) -> None.  Write the strings to the file.\n\nNote that newlines are not added.  The sequence can be any iterable object\nproducing strings. This is equivalent to calling write() for each string.";
   public static final String file_xreadlines_doc = "xreadlines() -> returns self.\n\nFor backward compatibility. File objects now include the performance\noptimizations previously implemented in the xreadlines module.";
   public static final String complex___abs___doc = "x.__abs__() <==> abs(x)";
   public static final String complex___add___doc = "x.__add__(y) <==> x+y";
   public static final String complex___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String complex___coerce___doc = "x.__coerce__(y) <==> coerce(x, y)";
   public static final String complex___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String complex___div___doc = "x.__div__(y) <==> x/y";
   public static final String complex___divmod___doc = "x.__divmod__(y) <==> divmod(x, y)";
   public static final String complex_doc = "complex(real[, imag]) -> complex number\n\nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.";
   public static final String complex___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String complex___float___doc = "x.__float__() <==> float(x)";
   public static final String complex___floordiv___doc = "x.__floordiv__(y) <==> x//y";
   public static final String complex___format___doc = "complex.__format__() -> str\n\nConverts to a string according to format_spec.";
   public static final String complex___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String complex___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String complex___getnewargs___doc = "";
   public static final String complex___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String complex___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String complex___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String complex___int___doc = "x.__int__() <==> int(x)";
   public static final String complex___le___doc = "x.__le__(y) <==> x<=y";
   public static final String complex___long___doc = "x.__long__() <==> long(x)";
   public static final String complex___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String complex___mod___doc = "x.__mod__(y) <==> x%y";
   public static final String complex___mul___doc = "x.__mul__(y) <==> x*y";
   public static final String complex___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String complex___neg___doc = "x.__neg__() <==> -x";
   public static final String complex___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String complex___nonzero___doc = "x.__nonzero__() <==> x != 0";
   public static final String complex___pos___doc = "x.__pos__() <==> +x";
   public static final String complex___pow___doc = "x.__pow__(y[, z]) <==> pow(x, y[, z])";
   public static final String complex___radd___doc = "x.__radd__(y) <==> y+x";
   public static final String complex___rdiv___doc = "x.__rdiv__(y) <==> y/x";
   public static final String complex___rdivmod___doc = "x.__rdivmod__(y) <==> divmod(y, x)";
   public static final String complex___reduce___doc = "helper for pickle";
   public static final String complex___reduce_ex___doc = "helper for pickle";
   public static final String complex___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String complex___rfloordiv___doc = "x.__rfloordiv__(y) <==> y//x";
   public static final String complex___rmod___doc = "x.__rmod__(y) <==> y%x";
   public static final String complex___rmul___doc = "x.__rmul__(y) <==> y*x";
   public static final String complex___rpow___doc = "y.__rpow__(x[, z]) <==> pow(x, y[, z])";
   public static final String complex___rsub___doc = "x.__rsub__(y) <==> y-x";
   public static final String complex___rtruediv___doc = "x.__rtruediv__(y) <==> y/x";
   public static final String complex___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String complex___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String complex___str___doc = "x.__str__() <==> str(x)";
   public static final String complex___sub___doc = "x.__sub__(y) <==> x-y";
   public static final String complex___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String complex___truediv___doc = "x.__truediv__(y) <==> x/y";
   public static final String complex_conjugate_doc = "complex.conjugate() -> complex\n\nReturns the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.";
   public static final String complex_imag_doc = "the imaginary part of a complex number";
   public static final String complex_real_doc = "the real part of a complex number";
   public static final String bool___abs___doc = "x.__abs__() <==> abs(x)";
   public static final String bool___add___doc = "x.__add__(y) <==> x+y";
   public static final String bool___and___doc = "x.__and__(y) <==> x&y";
   public static final String bool___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String bool___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String bool___coerce___doc = "x.__coerce__(y) <==> coerce(x, y)";
   public static final String bool___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String bool___div___doc = "x.__div__(y) <==> x/y";
   public static final String bool___divmod___doc = "x.__divmod__(y) <==> divmod(x, y)";
   public static final String bool_doc = "bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.";
   public static final String bool___float___doc = "x.__float__() <==> float(x)";
   public static final String bool___floordiv___doc = "x.__floordiv__(y) <==> x//y";
   public static final String bool___format___doc = "";
   public static final String bool___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String bool___getnewargs___doc = "";
   public static final String bool___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String bool___hex___doc = "x.__hex__() <==> hex(x)";
   public static final String bool___index___doc = "x[y:z] <==> x[y.__index__():z.__index__()]";
   public static final String bool___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String bool___int___doc = "x.__int__() <==> int(x)";
   public static final String bool___invert___doc = "x.__invert__() <==> ~x";
   public static final String bool___long___doc = "x.__long__() <==> long(x)";
   public static final String bool___lshift___doc = "x.__lshift__(y) <==> x<<y";
   public static final String bool___mod___doc = "x.__mod__(y) <==> x%y";
   public static final String bool___mul___doc = "x.__mul__(y) <==> x*y";
   public static final String bool___neg___doc = "x.__neg__() <==> -x";
   public static final String bool___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String bool___nonzero___doc = "x.__nonzero__() <==> x != 0";
   public static final String bool___oct___doc = "x.__oct__() <==> oct(x)";
   public static final String bool___or___doc = "x.__or__(y) <==> x|y";
   public static final String bool___pos___doc = "x.__pos__() <==> +x";
   public static final String bool___pow___doc = "x.__pow__(y[, z]) <==> pow(x, y[, z])";
   public static final String bool___radd___doc = "x.__radd__(y) <==> y+x";
   public static final String bool___rand___doc = "x.__rand__(y) <==> y&x";
   public static final String bool___rdiv___doc = "x.__rdiv__(y) <==> y/x";
   public static final String bool___rdivmod___doc = "x.__rdivmod__(y) <==> divmod(y, x)";
   public static final String bool___reduce___doc = "helper for pickle";
   public static final String bool___reduce_ex___doc = "helper for pickle";
   public static final String bool___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String bool___rfloordiv___doc = "x.__rfloordiv__(y) <==> y//x";
   public static final String bool___rlshift___doc = "x.__rlshift__(y) <==> y<<x";
   public static final String bool___rmod___doc = "x.__rmod__(y) <==> y%x";
   public static final String bool___rmul___doc = "x.__rmul__(y) <==> y*x";
   public static final String bool___ror___doc = "x.__ror__(y) <==> y|x";
   public static final String bool___rpow___doc = "y.__rpow__(x[, z]) <==> pow(x, y[, z])";
   public static final String bool___rrshift___doc = "x.__rrshift__(y) <==> y>>x";
   public static final String bool___rshift___doc = "x.__rshift__(y) <==> x>>y";
   public static final String bool___rsub___doc = "x.__rsub__(y) <==> y-x";
   public static final String bool___rtruediv___doc = "x.__rtruediv__(y) <==> y/x";
   public static final String bool___rxor___doc = "x.__rxor__(y) <==> y^x";
   public static final String bool___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String bool___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String bool___str___doc = "x.__str__() <==> str(x)";
   public static final String bool___sub___doc = "x.__sub__(y) <==> x-y";
   public static final String bool___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String bool___truediv___doc = "x.__truediv__(y) <==> x/y";
   public static final String bool___trunc___doc = "Truncating an Integral returns itself.";
   public static final String bool___xor___doc = "x.__xor__(y) <==> x^y";
   public static final String bool_bit_length_doc = "int.bit_length() -> int\n\nNumber of bits necessary to represent self in binary.\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6";
   public static final String bool_conjugate_doc = "Returns self, the complex conjugate of any int.";
   public static final String bool_denominator_doc = "the denominator of a rational number in lowest terms";
   public static final String bool_imag_doc = "the imaginary part of a complex number";
   public static final String bool_numerator_doc = "the numerator of a rational number in lowest terms";
   public static final String bool_real_doc = "the real part of a complex number";
   public static final String classmethod___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String classmethod___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String classmethod_doc = "classmethod(function) -> method\n\nConvert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      def f(cls, arg1, arg2, ...): ...\n      f = classmethod(f)\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.";
   public static final String classmethod___format___doc = "default object formatter";
   public static final String classmethod___func___doc = "";
   public static final String classmethod___get___doc = "descr.__get__(obj[, type]) -> value";
   public static final String classmethod___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String classmethod___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String classmethod___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String classmethod___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String classmethod___reduce___doc = "helper for pickle";
   public static final String classmethod___reduce_ex___doc = "helper for pickle";
   public static final String classmethod___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String classmethod___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String classmethod___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String classmethod___str___doc = "x.__str__() <==> str(x)";
   public static final String classmethod___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String set___and___doc = "x.__and__(y) <==> x&y";
   public static final String set___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String set___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String set___contains___doc = "x.__contains__(y) <==> y in x.";
   public static final String set___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String set_doc = "set() -> new empty set object\nset(iterable) -> new set object\n\nBuild an unordered collection of unique elements.";
   public static final String set___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String set___format___doc = "default object formatter";
   public static final String set___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String set___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String set___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String set___hash___doc = "";
   public static final String set___iand___doc = "x.__iand__(y) <==> x&y";
   public static final String set___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String set___ior___doc = "x.__ior__(y) <==> x|y";
   public static final String set___isub___doc = "x.__isub__(y) <==> x-y";
   public static final String set___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String set___ixor___doc = "x.__ixor__(y) <==> x^y";
   public static final String set___le___doc = "x.__le__(y) <==> x<=y";
   public static final String set___len___doc = "x.__len__() <==> len(x)";
   public static final String set___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String set___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String set___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String set___or___doc = "x.__or__(y) <==> x|y";
   public static final String set___rand___doc = "x.__rand__(y) <==> y&x";
   public static final String set___reduce___doc = "Return state information for pickling.";
   public static final String set___reduce_ex___doc = "helper for pickle";
   public static final String set___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String set___ror___doc = "x.__ror__(y) <==> y|x";
   public static final String set___rsub___doc = "x.__rsub__(y) <==> y-x";
   public static final String set___rxor___doc = "x.__rxor__(y) <==> y^x";
   public static final String set___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String set___sizeof___doc = "S.__sizeof__() -> size of S in memory, in bytes";
   public static final String set___str___doc = "x.__str__() <==> str(x)";
   public static final String set___sub___doc = "x.__sub__(y) <==> x-y";
   public static final String set___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String set___xor___doc = "x.__xor__(y) <==> x^y";
   public static final String set_add_doc = "Add an element to a set.\n\nThis has no effect if the element is already present.";
   public static final String set_clear_doc = "Remove all elements from this set.";
   public static final String set_copy_doc = "Return a shallow copy of a set.";
   public static final String set_difference_doc = "Return the difference of two or more sets as a new set.\n\n(i.e. all elements that are in this set but not the others.)";
   public static final String set_difference_update_doc = "Remove all elements of another set from this set.";
   public static final String set_discard_doc = "Remove an element from a set if it is a member.\n\nIf the element is not a member, do nothing.";
   public static final String set_intersection_doc = "Return the intersection of two or more sets as a new set.\n\n(i.e. elements that are common to all of the sets.)";
   public static final String set_intersection_update_doc = "Update a set with the intersection of itself and another.";
   public static final String set_isdisjoint_doc = "Return True if two sets have a null intersection.";
   public static final String set_issubset_doc = "Report whether another set contains this set.";
   public static final String set_issuperset_doc = "Report whether this set contains another set.";
   public static final String set_pop_doc = "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty.";
   public static final String set_remove_doc = "Remove an element from a set; it must be a member.\n\nIf the element is not a member, raise a KeyError.";
   public static final String set_symmetric_difference_doc = "Return the symmetric difference of two sets as a new set.\n\n(i.e. all elements that are in exactly one of the sets.)";
   public static final String set_symmetric_difference_update_doc = "Update a set with the symmetric difference of itself and another.";
   public static final String set_union_doc = "Return the union of sets as a new set.\n\n(i.e. all elements that are in either set.)";
   public static final String set_update_doc = "Update a set with the union of itself and others.";
   public static final String frozenset___and___doc = "x.__and__(y) <==> x&y";
   public static final String frozenset___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String frozenset___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String frozenset___contains___doc = "x.__contains__(y) <==> y in x.";
   public static final String frozenset___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String frozenset_doc = "frozenset() -> empty frozenset object\nfrozenset(iterable) -> frozenset object\n\nBuild an immutable unordered collection of unique elements.";
   public static final String frozenset___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String frozenset___format___doc = "default object formatter";
   public static final String frozenset___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String frozenset___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String frozenset___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String frozenset___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String frozenset___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String frozenset___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String frozenset___le___doc = "x.__le__(y) <==> x<=y";
   public static final String frozenset___len___doc = "x.__len__() <==> len(x)";
   public static final String frozenset___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String frozenset___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String frozenset___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String frozenset___or___doc = "x.__or__(y) <==> x|y";
   public static final String frozenset___rand___doc = "x.__rand__(y) <==> y&x";
   public static final String frozenset___reduce___doc = "Return state information for pickling.";
   public static final String frozenset___reduce_ex___doc = "helper for pickle";
   public static final String frozenset___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String frozenset___ror___doc = "x.__ror__(y) <==> y|x";
   public static final String frozenset___rsub___doc = "x.__rsub__(y) <==> y-x";
   public static final String frozenset___rxor___doc = "x.__rxor__(y) <==> y^x";
   public static final String frozenset___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String frozenset___sizeof___doc = "S.__sizeof__() -> size of S in memory, in bytes";
   public static final String frozenset___str___doc = "x.__str__() <==> str(x)";
   public static final String frozenset___sub___doc = "x.__sub__(y) <==> x-y";
   public static final String frozenset___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String frozenset___xor___doc = "x.__xor__(y) <==> x^y";
   public static final String frozenset_copy_doc = "Return a shallow copy of a set.";
   public static final String frozenset_difference_doc = "Return the difference of two or more sets as a new set.\n\n(i.e. all elements that are in this set but not the others.)";
   public static final String frozenset_intersection_doc = "Return the intersection of two or more sets as a new set.\n\n(i.e. elements that are common to all of the sets.)";
   public static final String frozenset_isdisjoint_doc = "Return True if two sets have a null intersection.";
   public static final String frozenset_issubset_doc = "Report whether another set contains this set.";
   public static final String frozenset_issuperset_doc = "Report whether this set contains another set.";
   public static final String frozenset_symmetric_difference_doc = "Return the symmetric difference of two sets as a new set.\n\n(i.e. all elements that are in exactly one of the sets.)";
   public static final String frozenset_union_doc = "Return the union of sets as a new set.\n\n(i.e. all elements that are in either set.)";
   public static final String BaseException___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String BaseException___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String BaseException___dict___doc = "";
   public static final String BaseException_doc = "Common base class for all exceptions";
   public static final String BaseException___format___doc = "default object formatter";
   public static final String BaseException___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String BaseException___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String BaseException___getslice___doc = "x.__getslice__(i, j) <==> x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String BaseException___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String BaseException___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String BaseException___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String BaseException___reduce___doc = "";
   public static final String BaseException___reduce_ex___doc = "helper for pickle";
   public static final String BaseException___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String BaseException___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String BaseException___setstate___doc = "";
   public static final String BaseException___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String BaseException___str___doc = "x.__str__() <==> str(x)";
   public static final String BaseException___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String BaseException___unicode___doc = "";
   public static final String BaseException_args_doc = "";
   public static final String BaseException_message_doc = "";
   public static final String bytearray___add___doc = "x.__add__(y) <==> x+y";
   public static final String bytearray___alloc___doc = "B.__alloc__() -> int\n\nReturns the number of bytes actually allocated.";
   public static final String bytearray___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String bytearray___contains___doc = "x.__contains__(y) <==> y in x";
   public static final String bytearray___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String bytearray___delitem___doc = "x.__delitem__(y) <==> del x[y]";
   public static final String bytearray_doc = "bytearray(iterable_of_ints) -> bytearray.\nbytearray(string, encoding[, errors]) -> bytearray.\nbytearray(bytes_or_bytearray) -> mutable copy of bytes_or_bytearray.\nbytearray(memory_view) -> bytearray.\n\nConstruct an mutable bytearray object from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - a bytes or a bytearray object\n  - any object implementing the buffer API.\n\nbytearray(int) -> bytearray.\n\nConstruct a zero-initialized bytearray of the given length.";
   public static final String bytearray___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String bytearray___format___doc = "default object formatter";
   public static final String bytearray___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String bytearray___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String bytearray___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String bytearray___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String bytearray___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String bytearray___iadd___doc = "x.__iadd__(y) <==> x+=y";
   public static final String bytearray___imul___doc = "x.__imul__(y) <==> x*=y";
   public static final String bytearray___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String bytearray___iter___doc = "x.__iter__() <==> iter(x)";
   public static final String bytearray___le___doc = "x.__le__(y) <==> x<=y";
   public static final String bytearray___len___doc = "x.__len__() <==> len(x)";
   public static final String bytearray___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String bytearray___mul___doc = "x.__mul__(n) <==> x*n";
   public static final String bytearray___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String bytearray___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String bytearray___reduce___doc = "Return state information for pickling.";
   public static final String bytearray___reduce_ex___doc = "helper for pickle";
   public static final String bytearray___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String bytearray___rmul___doc = "x.__rmul__(n) <==> n*x";
   public static final String bytearray___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String bytearray___setitem___doc = "x.__setitem__(i, y) <==> x[i]=y";
   public static final String bytearray___sizeof___doc = "B.__sizeof__() -> int\n \nReturns the size of B in memory, in bytes";
   public static final String bytearray___str___doc = "x.__str__() <==> str(x)";
   public static final String bytearray___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String bytearray_append_doc = "B.append(int) -> None\n\nAppend a single item to the end of B.";
   public static final String bytearray_capitalize_doc = "B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased.";
   public static final String bytearray_center_doc = "B.center(width[, fillchar]) -> copy of B\n\nReturn B centered in a string of length width.  Padding is\ndone using the specified fill character (default is a space).";
   public static final String bytearray_count_doc = "B.count(sub [,start [,end]]) -> int\n\nReturn the number of non-overlapping occurrences of subsection sub in\nbytes B[start:end].  Optional arguments start and end are interpreted\nas in slice notation.";
   public static final String bytearray_decode_doc = "B.decode([encoding[, errors]]) -> unicode object.\n\nDecodes B using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme.  Default is 'strict' meaning that encoding errors raise\na UnicodeDecodeError.  Other possible values are 'ignore' and 'replace'\nas well as any other name registered with codecs.register_error that is\nable to handle UnicodeDecodeErrors.";
   public static final String bytearray_endswith_doc = "B.endswith(suffix [,start [,end]]) -> bool\n\nReturn True if B ends with the specified suffix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nsuffix can also be a tuple of strings to try.";
   public static final String bytearray_expandtabs_doc = "B.expandtabs([tabsize]) -> copy of B\n\nReturn a copy of B where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.";
   public static final String bytearray_extend_doc = "B.extend(iterable int) -> None\n\nAppend all the elements from the iterator or sequence to the\nend of B.";
   public static final String bytearray_find_doc = "B.find(sub [,start [,end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within s[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
   public static final String bytearray_fromhex_doc = "bytearray.fromhex(string) -> bytearray\n\nCreate a bytearray object from a string of hexadecimal numbers.\nSpaces between two numbers are accepted.\nExample: bytearray.fromhex('B9 01EF') -> bytearray(b'\\xb9\\x01\\xef').";
   public static final String bytearray_index_doc = "B.index(sub [,start [,end]]) -> int\n\nLike B.find() but raise ValueError when the subsection is not found.";
   public static final String bytearray_insert_doc = "B.insert(index, int) -> None\n\nInsert a single item into the bytearray before the given index.";
   public static final String bytearray_isalnum_doc = "B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise.";
   public static final String bytearray_isalpha_doc = "B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise.";
   public static final String bytearray_isdigit_doc = "B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise.";
   public static final String bytearray_islower_doc = "B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise.";
   public static final String bytearray_isspace_doc = "B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise.";
   public static final String bytearray_istitle_doc = "B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise.";
   public static final String bytearray_isupper_doc = "B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise.";
   public static final String bytearray_join_doc = "B.join(iterable_of_bytes) -> bytes\n\nConcatenates any number of bytearray objects, with B in between each pair.";
   public static final String bytearray_ljust_doc = "B.ljust(width[, fillchar]) -> copy of B\n\nReturn B left justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).";
   public static final String bytearray_lower_doc = "B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase.";
   public static final String bytearray_lstrip_doc = "B.lstrip([bytes]) -> bytearray\n\nStrip leading bytes contained in the argument.\nIf the argument is omitted, strip leading ASCII whitespace.";
   public static final String bytearray_partition_doc = "B.partition(sep) -> (head, sep, tail)\n\nSearches for the separator sep in B, and returns the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, returns B and two empty bytearray objects.";
   public static final String bytearray_pop_doc = "B.pop([index]) -> int\n\nRemove and return a single item from B. If no index\nargument is given, will pop the last value.";
   public static final String bytearray_remove_doc = "B.remove(int) -> None\n\nRemove the first occurance of a value in B.";
   public static final String bytearray_replace_doc = "B.replace(old, new[, count]) -> bytes\n\nReturn a copy of B with all occurrences of subsection\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.";
   public static final String bytearray_reverse_doc = "B.reverse() -> None\n\nReverse the order of the values in B in place.";
   public static final String bytearray_rfind_doc = "B.rfind(sub [,start [,end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within s[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
   public static final String bytearray_rindex_doc = "B.rindex(sub [,start [,end]]) -> int\n\nLike B.rfind() but raise ValueError when the subsection is not found.";
   public static final String bytearray_rjust_doc = "B.rjust(width[, fillchar]) -> copy of B\n\nReturn B right justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)";
   public static final String bytearray_rpartition_doc = "B.rpartition(sep) -> (head, sep, tail)\n\nSearches for the separator sep in B, starting at the end of B,\nand returns the part before it, the separator itself, and the\npart after it.  If the separator is not found, returns two empty\nbytearray objects and B.";
   public static final String bytearray_rsplit_doc = "B.rsplit(sep[, maxsplit]) -> list of bytearray\n\nReturn a list of the sections in B, using sep as the delimiter,\nstarting at the end of B and working to the front.\nIf sep is not given, B is split on ASCII whitespace characters\n(space, tab, return, newline, formfeed, vertical tab).\nIf maxsplit is given, at most maxsplit splits are done.";
   public static final String bytearray_rstrip_doc = "B.rstrip([bytes]) -> bytearray\n\nStrip trailing bytes contained in the argument.\nIf the argument is omitted, strip trailing ASCII whitespace.";
   public static final String bytearray_split_doc = "B.split([sep[, maxsplit]]) -> list of bytearray\n\nReturn a list of the sections in B, using sep as the delimiter.\nIf sep is not given, B is split on ASCII whitespace characters\n(space, tab, return, newline, formfeed, vertical tab).\nIf maxsplit is given, at most maxsplit splits are done.";
   public static final String bytearray_splitlines_doc = "B.splitlines([keepends]) -> list of lines\n\nReturn a list of the lines in B, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.";
   public static final String bytearray_startswith_doc = "B.startswith(prefix [,start [,end]]) -> bool\n\nReturn True if B starts with the specified prefix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nprefix can also be a tuple of strings to try.";
   public static final String bytearray_strip_doc = "B.strip([bytes]) -> bytearray\n\nStrip leading and trailing bytes contained in the argument.\nIf the argument is omitted, strip ASCII whitespace.";
   public static final String bytearray_swapcase_doc = "B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa.";
   public static final String bytearray_title_doc = "B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase.";
   public static final String bytearray_translate_doc = "B.translate(table[, deletechars]) -> bytearray\n\nReturn a copy of B, where all characters occurring in the\noptional argument deletechars are removed, and the remaining\ncharacters have been mapped through the given translation\ntable, which must be a bytes object of length 256.";
   public static final String bytearray_upper_doc = "B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase.";
   public static final String bytearray_zfill_doc = "B.zfill(width) -> copy of B\n\nPad a numeric string B with zeros on the left, to fill a field\nof the specified width.  B is never truncated.";
   public static final String buffer___add___doc = "x.__add__(y) <==> x+y";
   public static final String buffer___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String buffer___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String buffer___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String buffer___delitem___doc = "x.__delitem__(y) <==> del x[y]";
   public static final String buffer___delslice___doc = "x.__delslice__(i, j) <==> del x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String buffer_doc = "buffer(object [, offset[, size]])\n\nCreate a new buffer object which references the given object.\nThe buffer will reference a slice of the target object from the\nstart of the object (or at the specified offset). The slice will\nextend to the end of the target object (or with the specified size).";
   public static final String buffer___format___doc = "default object formatter";
   public static final String buffer___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String buffer___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String buffer___getslice___doc = "x.__getslice__(i, j) <==> x[i:j]\n           \n           Use of negative indices is not supported.";
   public static final String buffer___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String buffer___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String buffer___len___doc = "x.__len__() <==> len(x)";
   public static final String buffer___mul___doc = "x.__mul__(n) <==> x*n";
   public static final String buffer___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String buffer___reduce___doc = "helper for pickle";
   public static final String buffer___reduce_ex___doc = "helper for pickle";
   public static final String buffer___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String buffer___rmul___doc = "x.__rmul__(n) <==> n*x";
   public static final String buffer___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String buffer___setitem___doc = "x.__setitem__(i, y) <==> x[i]=y";
   public static final String buffer___setslice___doc = "x.__setslice__(i, j, y) <==> x[i:j]=y\n           \n           Use  of negative indices is not supported.";
   public static final String buffer___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String buffer___str___doc = "x.__str__() <==> str(x)";
   public static final String buffer___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String memoryview___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String memoryview___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String memoryview___delitem___doc = "x.__delitem__(y) <==> del x[y]";
   public static final String memoryview_doc = "memoryview(object)\n\nCreate a new memoryview object which references the given object.";
   public static final String memoryview___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String memoryview___format___doc = "default object formatter";
   public static final String memoryview___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String memoryview___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String memoryview___getitem___doc = "x.__getitem__(y) <==> x[y]";
   public static final String memoryview___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String memoryview___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String memoryview___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String memoryview___le___doc = "x.__le__(y) <==> x<=y";
   public static final String memoryview___len___doc = "x.__len__() <==> len(x)";
   public static final String memoryview___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String memoryview___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String memoryview___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String memoryview___reduce___doc = "helper for pickle";
   public static final String memoryview___reduce_ex___doc = "helper for pickle";
   public static final String memoryview___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String memoryview___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String memoryview___setitem___doc = "x.__setitem__(i, y) <==> x[i]=y";
   public static final String memoryview___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String memoryview___str___doc = "x.__str__() <==> str(x)";
   public static final String memoryview___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String memoryview_format_doc = "";
   public static final String memoryview_itemsize_doc = "";
   public static final String memoryview_ndim_doc = "";
   public static final String memoryview_readonly_doc = "";
   public static final String memoryview_shape_doc = "";
   public static final String memoryview_strides_doc = "";
   public static final String memoryview_suboffsets_doc = "";
   public static final String memoryview_tobytes_doc = "";
   public static final String memoryview_tolist_doc = "";
   public static final String function___call___doc = "x.__call__(...) <==> x(...)";
   public static final String function___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String function___closure___doc = "";
   public static final String function___code___doc = "";
   public static final String function___defaults___doc = "";
   public static final String function___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String function___dict___doc = "";
   public static final String function_doc = "function(code, globals[, name[, argdefs[, closure]]])\n\nCreate a function object from a code object and a dictionary.\nThe optional name string overrides the name from the code object.\nThe optional argdefs tuple specifies the default argument values.\nThe optional closure tuple supplies the bindings for free variables.";
   public static final String function___format___doc = "default object formatter";
   public static final String function___get___doc = "descr.__get__(obj[, type]) -> value";
   public static final String function___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String function___globals___doc = "";
   public static final String function___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String function___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String function___module___doc = "str(object) -> string\n\nReturn a nice string representation of the object.\nIf the argument is a string, the return value is the same object.";
   public static final String function___name___doc = "str(object) -> string\n\nReturn a nice string representation of the object.\nIf the argument is a string, the return value is the same object.";
   public static final String function___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String function___reduce___doc = "helper for pickle";
   public static final String function___reduce_ex___doc = "helper for pickle";
   public static final String function___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String function___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String function___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String function___str___doc = "x.__str__() <==> str(x)";
   public static final String function___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String function_func_closure_doc = "";
   public static final String function_func_code_doc = "";
   public static final String function_func_defaults_doc = "";
   public static final String function_func_dict_doc = "";
   public static final String function_func_doc_doc = "";
   public static final String function_func_globals_doc = "";
   public static final String function_func_name_doc = "";
   public static final String instancemethod___call___doc = "x.__call__(...) <==> x(...)";
   public static final String instancemethod___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String instancemethod___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String instancemethod___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String instancemethod_doc = "instancemethod(function, instance, class)\n\nCreate an instance method object.";
   public static final String instancemethod___format___doc = "default object formatter";
   public static final String instancemethod___func___doc = "the function (or other callable) implementing a method";
   public static final String instancemethod___get___doc = "descr.__get__(obj[, type]) -> value";
   public static final String instancemethod___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String instancemethod___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String instancemethod___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String instancemethod___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String instancemethod___reduce___doc = "helper for pickle";
   public static final String instancemethod___reduce_ex___doc = "helper for pickle";
   public static final String instancemethod___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String instancemethod___self___doc = "the instance to which a method is bound; None for unbound methods";
   public static final String instancemethod___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String instancemethod___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String instancemethod___str___doc = "x.__str__() <==> str(x)";
   public static final String instancemethod___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String instancemethod_im_class_doc = "the class associated with a method";
   public static final String instancemethod_im_func_doc = "the function (or other callable) implementing a method";
   public static final String instancemethod_im_self_doc = "the instance to which a method is bound; None for unbound methods";
   public static final String code___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String code___cmp___doc = "x.__cmp__(y) <==> cmp(x,y)";
   public static final String code___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String code_doc = "code(argcount, nlocals, stacksize, flags, codestring, constants, names,\n      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])\n\nCreate a code object.  Not for the faint of heart.";
   public static final String code___eq___doc = "x.__eq__(y) <==> x==y";
   public static final String code___format___doc = "default object formatter";
   public static final String code___ge___doc = "x.__ge__(y) <==> x>=y";
   public static final String code___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String code___gt___doc = "x.__gt__(y) <==> x>y";
   public static final String code___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String code___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String code___le___doc = "x.__le__(y) <==> x<=y";
   public static final String code___lt___doc = "x.__lt__(y) <==> x<y";
   public static final String code___ne___doc = "x.__ne__(y) <==> x!=y";
   public static final String code___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String code___reduce___doc = "helper for pickle";
   public static final String code___reduce_ex___doc = "helper for pickle";
   public static final String code___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String code___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String code___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String code___str___doc = "x.__str__() <==> str(x)";
   public static final String code___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String code_co_argcount_doc = "";
   public static final String code_co_cellvars_doc = "";
   public static final String code_co_code_doc = "";
   public static final String code_co_consts_doc = "";
   public static final String code_co_filename_doc = "";
   public static final String code_co_firstlineno_doc = "";
   public static final String code_co_flags_doc = "";
   public static final String code_co_freevars_doc = "";
   public static final String code_co_lnotab_doc = "";
   public static final String code_co_name_doc = "";
   public static final String code_co_names_doc = "";
   public static final String code_co_nlocals_doc = "";
   public static final String code_co_stacksize_doc = "";
   public static final String code_co_varnames_doc = "";
   public static final String frame___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String frame___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String frame_doc = "";
   public static final String frame___format___doc = "default object formatter";
   public static final String frame___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String frame___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String frame___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String frame___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String frame___reduce___doc = "helper for pickle";
   public static final String frame___reduce_ex___doc = "helper for pickle";
   public static final String frame___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String frame___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String frame___sizeof___doc = "F.__sizeof__() -> size of F in memory, in bytes";
   public static final String frame___str___doc = "x.__str__() <==> str(x)";
   public static final String frame___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String frame_f_back_doc = "";
   public static final String frame_f_builtins_doc = "";
   public static final String frame_f_code_doc = "";
   public static final String frame_f_exc_traceback_doc = "";
   public static final String frame_f_exc_type_doc = "";
   public static final String frame_f_exc_value_doc = "";
   public static final String frame_f_globals_doc = "";
   public static final String frame_f_lasti_doc = "";
   public static final String frame_f_lineno_doc = "";
   public static final String frame_f_locals_doc = "";
   public static final String frame_f_restricted_doc = "";
   public static final String frame_f_trace_doc = "";
   public static final String traceback___class___doc = "type(object) -> the object's type\ntype(name, bases, dict) -> a new type";
   public static final String traceback___delattr___doc = "x.__delattr__('name') <==> del x.name";
   public static final String traceback_doc = "";
   public static final String traceback___format___doc = "default object formatter";
   public static final String traceback___getattribute___doc = "x.__getattribute__('name') <==> x.name";
   public static final String traceback___hash___doc = "x.__hash__() <==> hash(x)";
   public static final String traceback___init___doc = "x.__init__(...) initializes x; see help(type(x)) for signature";
   public static final String traceback___new___doc = "T.__new__(S, ...) -> a new object with type S, a subtype of T";
   public static final String traceback___reduce___doc = "helper for pickle";
   public static final String traceback___reduce_ex___doc = "helper for pickle";
   public static final String traceback___repr___doc = "x.__repr__() <==> repr(x)";
   public static final String traceback___setattr___doc = "x.__setattr__('name', value) <==> x.name = value";
   public static final String traceback___sizeof___doc = "__sizeof__() -> int\nsize of object in memory, in bytes";
   public static final String traceback___str___doc = "x.__str__() <==> str(x)";
   public static final String traceback___subclasshook___doc = "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n";
   public static final String traceback_tb_frame_doc = "";
   public static final String traceback_tb_lasti_doc = "";
   public static final String traceback_tb_lineno_doc = "";
   public static final String traceback_tb_next_doc = "";
   public static final String sre_pattern_doc = "Compiled regular expression objects";
   public static final String sre_pattern_match_doc = "match(string[, pos[, endpos]]) --> match object or None.\n    Matches zero or more characters at the beginning of the string";
   public static final String sre_pattern_findall_doc = "findall(string[, pos[, endpos]]) --> list.\n   Return a list of all non-overlapping matches of pattern in string.";
   public static final String sre_pattern_finditer_doc = "finditer(string[, pos[, endpos]]) --> iterator.\n    Return an iterator over all non-overlapping matches for the \n    RE pattern in string. For each match, the iterator returns a\n    match object.";
   public static final String sre_pattern_search_doc = "search(string[, pos[, endpos]]) --> match object or None.\n    Scan through string looking for a match, and return a corresponding\n    match object instance. Return None if no position in the string matches.";
   public static final String sre_pattern_split_doc = "split(string[, maxsplit = 0])  --> list.\n    Split string by the occurrences of pattern.";
   public static final String sre_pattern_sub_doc = "sub(repl, string[, count = 0]) --> newstring\n    Return the string obtained by replacing the leftmost non-overlapping\n    occurrences of pattern in string by the replacement repl.";
   public static final String sre_pattern_subn_doc = "subn(repl, string[, count = 0]) --> (newstring, number of subs)\n    Return the tuple (new_string, number_of_subs_made) found by replacing\n    the leftmost non-overlapping occurrences of pattern with the\n    replacement repl.";
}
