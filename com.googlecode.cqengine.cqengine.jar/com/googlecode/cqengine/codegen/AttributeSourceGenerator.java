package com.googlecode.cqengine.codegen;

import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class AttributeSourceGenerator {
   static final Map PRIMITIVES_TO_WRAPPERS = new HashMap() {
      {
         this.put(Boolean.TYPE, Boolean.class);
         this.put(Byte.TYPE, Byte.class);
         this.put(Short.TYPE, Short.class);
         this.put(Character.TYPE, Character.class);
         this.put(Integer.TYPE, Integer.class);
         this.put(Long.TYPE, Long.class);
         this.put(Float.TYPE, Float.class);
         this.put(Double.TYPE, Double.class);
      }
   };

   public static String generateAttributesForPastingIntoTargetClass(Class targetClass) {
      return generateAttributesForClass(targetClass, false, "", MemberFilters.FIELDS_ONLY);
   }

   public static String generateAttributesForPastingIntoTargetClass(Class targetClass, MemberFilter memberFilter) {
      return generateAttributesForClass(targetClass, false, "", memberFilter);
   }

   public static String generateSeparateAttributesClass(Class targetClass, String packageOfAttributesClass) {
      return generateAttributesForClass(targetClass, true, packageOfAttributesClass, MemberFilters.ALL_MEMBERS);
   }

   public static String generateSeparateAttributesClass(Class targetClass, String packageOfAttributesClass, MemberFilter memberFilter) {
      return generateAttributesForClass(targetClass, true, packageOfAttributesClass, memberFilter);
   }

   public static String generateSeparateAttributesClass(Class targetClass, Package packageOfAttributesClass) {
      return generateAttributesForClass(targetClass, true, packageOfAttributesClass.getName(), MemberFilters.ALL_MEMBERS);
   }

   public static String generateSeparateAttributesClass(Class targetClass, Package packageOfAttributesClass, MemberFilter memberFilter) {
      return generateAttributesForClass(targetClass, true, packageOfAttributesClass.getName(), memberFilter);
   }

   static String generateAttributesForClass(Class targetClass, boolean separateAttributesClass, String packageOfAttributesClass, MemberFilter memberFilter) {
      StringBuilder sb = new StringBuilder();
      if (separateAttributesClass) {
         sb.append("package ").append(packageOfAttributesClass).append(";\n\n");
         sb.append("import com.googlecode.cqengine.attribute.*;\n");
         sb.append("import com.googlecode.cqengine.query.option.QueryOptions;\n");
         sb.append("import java.util.*;\n");
         String targetClassName = targetClass.getName().replace("$", ".");
         sb.append("import ").append(targetClassName).append(";\n\n");
         sb.append("/**\n");
         sb.append(" * CQEngine attributes for accessing the members of class {@code ").append(targetClassName).append("}.\n");
         sb.append(" * <p/>.\n");
         sb.append(" * Auto-generated by CQEngine's {@code ").append(AttributeSourceGenerator.class.getSimpleName()).append("}.\n");
         sb.append(" */\n");
         sb.append("public class CQ").append(targetClass.getSimpleName()).append(" {");
      }

      Class currentClass = targetClass;
      Set membersEncountered = new HashSet();

      label80:
      while(currentClass != null && currentClass != Object.class) {
         Iterator var7 = getMembers(currentClass).iterator();

         while(true) {
            while(true) {
               Member member;
               int modifiers;
               do {
                  do {
                     do {
                        if (!var7.hasNext()) {
                           currentClass = currentClass.getSuperclass();
                           continue label80;
                        }

                        member = (Member)var7.next();
                     } while(!memberFilter.accept(member));
                  } while(membersEncountered.contains(member.getName()));

                  modifiers = member.getModifiers();
               } while(Modifier.isStatic(modifiers));

               if (Modifier.isPrivate(modifiers)) {
                  if (!separateAttributesClass && currentClass.equals(targetClass)) {
                     sb.append("\n\n");
                     sb.append(generateAttributeForMember(targetClass, member));
                     membersEncountered.add(member.getName());
                  }
               } else if (Modifier.isProtected(modifiers)) {
                  if (!separateAttributesClass || member.getDeclaringClass().getPackage().getName().equals(packageOfAttributesClass)) {
                     sb.append("\n\n");
                     sb.append(generateAttributeForMember(targetClass, member));
                     membersEncountered.add(member.getName());
                  }
               } else if (Modifier.isPublic(modifiers)) {
                  sb.append("\n\n");
                  sb.append(generateAttributeForMember(targetClass, member));
                  membersEncountered.add(member.getName());
               } else if (!separateAttributesClass && currentClass.equals(targetClass) || member.getDeclaringClass().getPackage().getName().equals(packageOfAttributesClass)) {
                  sb.append("\n\n");
                  sb.append(generateAttributeForMember(targetClass, member));
                  membersEncountered.add(member.getName());
               }
            }
         }
      }

      if (separateAttributesClass) {
         sb.append("\n}\n");
      }

      return sb.toString();
   }

   static String generateAttributeForMember(Class enclosingClass, Member member) {
      try {
         MemberType memberType = getMemberType(member);
         if (getType(member).isPrimitive()) {
            return generateSimpleAttribute(enclosingClass.getSimpleName(), ((Class)PRIMITIVES_TO_WRAPPERS.get(getType(member))).getSimpleName(), member.getName(), memberType);
         } else if (Iterable.class.isAssignableFrom(getType(member))) {
            ParameterizedType parameterizedType = getGenericType(member);
            if (parameterizedType.getActualTypeArguments().length != 1) {
               throw new UnsupportedOperationException();
            } else {
               Class genericType = (Class)parameterizedType.getActualTypeArguments()[0];
               return generateMultiValueNullableAttributeForIterable(enclosingClass.getSimpleName(), genericType.getSimpleName(), member.getName(), memberType);
            }
         } else if (getType(member).isArray()) {
            return getType(member).getComponentType().isPrimitive() ? generateMultiValueNullableAttributeForPrimitiveArray(enclosingClass.getSimpleName(), ((Class)PRIMITIVES_TO_WRAPPERS.get(getType(member).getComponentType())).getSimpleName(), getType(member).getComponentType().getSimpleName(), member.getName(), memberType) : generateMultiValueNullableAttributeForObjectArray(enclosingClass.getSimpleName(), getType(member).getComponentType().getSimpleName(), member.getName(), memberType);
         } else {
            return generateSimpleNullableAttribute(enclosingClass.getSimpleName(), getType(member).getSimpleName(), member.getName(), memberType);
         }
      } catch (Exception var5) {
         return "    // *** Note: Could not generate CQEngine attribute automatically for member: " + enclosingClass.getSimpleName() + "." + member.getName() + " ***";
      }
   }

   static String generateSimpleAttribute(String objectType, String attributeType, String memberName, MemberType memberType) {
      return "    /**\n     * CQEngine attribute for accessing " + memberType.description + " {@code " + objectType + "." + memberName + memberType.accessSuffix + "}.\n     */\n    public static final Attribute<" + objectType + ", " + attributeType + "> " + toUpperCaseWithUnderscores(memberName) + " = new SimpleAttribute<" + objectType + ", " + attributeType + ">(\"" + toUpperCaseWithUnderscores(memberName) + "\") {\n        public " + attributeType + " getValue(" + objectType + " " + objectType.toLowerCase() + ", QueryOptions queryOptions) { return " + objectType.toLowerCase() + "." + memberName + memberType.accessSuffix + "; }\n    };";
   }

   static String generateSimpleNullableAttribute(String objectType, String attributeType, String memberName, MemberType memberType) {
      return "    /**\n     * CQEngine attribute for accessing " + memberType.description + " {@code " + objectType + "." + memberName + memberType.accessSuffix + "}.\n     */\n    // Note: For best performance:\n    // - if this " + memberType.description + " cannot " + memberType.produce + " null, replace this SimpleNullableAttribute with a SimpleAttribute\n    public static final Attribute<" + objectType + ", " + attributeType + "> " + toUpperCaseWithUnderscores(memberName) + " = new SimpleNullableAttribute<" + objectType + ", " + attributeType + ">(\"" + toUpperCaseWithUnderscores(memberName) + "\") {\n        public " + attributeType + " getValue(" + objectType + " " + objectType.toLowerCase() + ", QueryOptions queryOptions) { return " + objectType.toLowerCase() + "." + memberName + memberType.accessSuffix + "; }\n    };";
   }

   static String generateMultiValueNullableAttributeForIterable(String objectType, String attributeType, String memberName, MemberType memberType) {
      return "    /**\n     * CQEngine attribute for accessing " + memberType.description + " {@code " + objectType + "." + memberName + memberType.accessSuffix + "}.\n     */\n    // Note: For best performance:\n    // - if the collection cannot contain null elements change true to false in the following constructor, or\n    // - if the collection cannot contain null elements AND the " + memberType.description + " itself cannot " + memberType.produce + " null, replace this\n    //   MultiValueNullableAttribute with a MultiValueAttribute (and change getNullableValues() to getValues())\n    public static final Attribute<" + objectType + ", " + attributeType + "> " + toUpperCaseWithUnderscores(memberName) + " = new MultiValueNullableAttribute<" + objectType + ", " + attributeType + ">(\"" + toUpperCaseWithUnderscores(memberName) + "\", true) {\n        public Iterable<" + attributeType + "> getNullableValues(" + objectType + " " + objectType.toLowerCase() + ", QueryOptions queryOptions) { return " + objectType.toLowerCase() + "." + memberName + memberType.accessSuffix + "; }\n    };";
   }

   static String generateMultiValueNullableAttributeForObjectArray(String objectType, String attributeType, String memberName, MemberType memberType) {
      return "    /**\n     * CQEngine attribute for accessing " + memberType.description + " {@code " + objectType + "." + memberName + memberType.accessSuffix + "}.\n     */\n    // Note: For best performance:\n    // - if the array cannot contain null elements change true to false in the following constructor, or\n    // - if the array cannot contain null elements AND the " + memberType.description + " itself cannot " + memberType.produce + " null, replace this\n    //   MultiValueNullableAttribute with a MultiValueAttribute (and change getNullableValues() to getValues())\n    public static final Attribute<" + objectType + ", " + attributeType + "> " + toUpperCaseWithUnderscores(memberName) + " = new MultiValueNullableAttribute<" + objectType + ", " + attributeType + ">(\"" + toUpperCaseWithUnderscores(memberName) + "\", true) {\n        public Iterable<" + attributeType + "> getNullableValues(" + objectType + " " + objectType.toLowerCase() + ", QueryOptions queryOptions) { return Arrays.asList(" + objectType.toLowerCase() + "." + memberName + memberType.accessSuffix + "); }\n    };";
   }

   static String generateMultiValueNullableAttributeForPrimitiveArray(String objectType, String attributeType, String primitiveType, String memberName, MemberType memberType) {
      return "    /**\n     * CQEngine attribute for accessing " + memberType.description + " {@code " + objectType + "." + memberName + memberType.accessSuffix + "}.\n     */\n    // Note: For best performance:\n    // - if this " + memberType.description + " cannot " + memberType.produce + " null, replace this\n    //   MultiValueNullableAttribute with a MultiValueAttribute (and change getNullableValues() to getValues())\n    public static final Attribute<" + objectType + ", " + attributeType + "> " + toUpperCaseWithUnderscores(memberName) + " = new MultiValueNullableAttribute<" + objectType + ", " + attributeType + ">(\"" + toUpperCaseWithUnderscores(memberName) + "\", false) {\n        public Iterable<" + attributeType + "> getNullableValues(final " + objectType + " " + objectType.toLowerCase() + ", QueryOptions queryOptions) {\n            return new AbstractList<" + attributeType + ">() {\n                public " + attributeType + " get(int i) { return " + objectType.toLowerCase() + "." + memberName + memberType.accessSuffix + "[i]; }\n                public int size() { return " + objectType.toLowerCase() + "." + memberName + memberType.accessSuffix + ".length; }\n            };\n        }\n    };";
   }

   static String toUpperCaseWithUnderscores(String camelCase) {
      String[] words = camelCase.split("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");
      StringBuilder sb = new StringBuilder();
      Iterator iterator = Arrays.asList(words).iterator();

      while(iterator.hasNext()) {
         String word = (String)iterator.next();
         sb.append(word.toUpperCase());
         if (iterator.hasNext()) {
            sb.append("_");
         }
      }

      return sb.toString();
   }

   static List getMembers(Class currentClass) {
      List declaredMembers = new ArrayList();
      Field[] var2 = currentClass.getDeclaredFields();
      int var3 = var2.length;

      int var4;
      for(var4 = 0; var4 < var3; ++var4) {
         Field member = var2[var4];
         if (!member.isSynthetic()) {
            declaredMembers.add(member);
         }
      }

      Method[] var6 = currentClass.getDeclaredMethods();
      var3 = var6.length;

      for(var4 = 0; var4 < var3; ++var4) {
         Method member = var6[var4];
         if (!member.isSynthetic() && !member.isBridge() && !member.getReturnType().equals(Void.TYPE) && member.getParameterTypes().length == 0) {
            declaredMembers.add(member);
         }
      }

      return declaredMembers;
   }

   static MemberType getMemberType(Member member) {
      if (member instanceof Field) {
         return AttributeSourceGenerator.MemberType.FIELD;
      } else if (member instanceof Method) {
         return AttributeSourceGenerator.MemberType.METHOD;
      } else {
         throw new IllegalStateException("Unsupported member type: " + member);
      }
   }

   static Class getType(Member member) {
      if (member instanceof Field) {
         return ((Field)member).getType();
      } else if (member instanceof Method) {
         return ((Method)member).getReturnType();
      } else {
         throw new IllegalStateException("Unsupported member type: " + member);
      }
   }

   static ParameterizedType getGenericType(Member member) {
      if (member instanceof Field) {
         return (ParameterizedType)((Field)member).getGenericType();
      } else if (member instanceof Method) {
         return (ParameterizedType)((Method)member).getGenericReturnType();
      } else {
         throw new IllegalStateException("Unsupported member type: " + member);
      }
   }

   AttributeSourceGenerator() {
   }

   static enum MemberType {
      FIELD("field", "", "be"),
      METHOD("method", "()", "return");

      public final String description;
      public final String accessSuffix;
      public final String produce;

      private MemberType(String description, String accessSuffix, String produce) {
         this.description = description;
         this.accessSuffix = accessSuffix;
         this.produce = produce;
      }
   }
}
